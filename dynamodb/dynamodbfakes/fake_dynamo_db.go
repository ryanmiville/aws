// Code generated by counterfeiter. DO NOT EDIT.
package dynamodbfakes

import (
	"context"
	"sync"

	"github.com/aws/aws-sdk-go/aws/request"
	dynamodba "github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/ryanmiville/aws/dynamodb"
)

type FakeDynamoDB struct {
	BatchExecuteStatementStub        func(*dynamodba.BatchExecuteStatementInput) (*dynamodba.BatchExecuteStatementOutput, error)
	batchExecuteStatementMutex       sync.RWMutex
	batchExecuteStatementArgsForCall []struct {
		arg1 *dynamodba.BatchExecuteStatementInput
	}
	batchExecuteStatementReturns struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}
	batchExecuteStatementReturnsOnCall map[int]struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}
	BatchExecuteStatementRequestStub        func(*dynamodba.BatchExecuteStatementInput) (*request.Request, *dynamodba.BatchExecuteStatementOutput)
	batchExecuteStatementRequestMutex       sync.RWMutex
	batchExecuteStatementRequestArgsForCall []struct {
		arg1 *dynamodba.BatchExecuteStatementInput
	}
	batchExecuteStatementRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.BatchExecuteStatementOutput
	}
	batchExecuteStatementRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.BatchExecuteStatementOutput
	}
	BatchExecuteStatementWithContextStub        func(context.Context, *dynamodba.BatchExecuteStatementInput, ...request.Option) (*dynamodba.BatchExecuteStatementOutput, error)
	batchExecuteStatementWithContextMutex       sync.RWMutex
	batchExecuteStatementWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.BatchExecuteStatementInput
		arg3 []request.Option
	}
	batchExecuteStatementWithContextReturns struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}
	batchExecuteStatementWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}
	BatchGetItemStub        func(*dynamodba.BatchGetItemInput) (*dynamodba.BatchGetItemOutput, error)
	batchGetItemMutex       sync.RWMutex
	batchGetItemArgsForCall []struct {
		arg1 *dynamodba.BatchGetItemInput
	}
	batchGetItemReturns struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}
	batchGetItemReturnsOnCall map[int]struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}
	BatchGetItemPagesStub        func(*dynamodba.BatchGetItemInput, func(*dynamodba.BatchGetItemOutput, bool) bool) error
	batchGetItemPagesMutex       sync.RWMutex
	batchGetItemPagesArgsForCall []struct {
		arg1 *dynamodba.BatchGetItemInput
		arg2 func(*dynamodba.BatchGetItemOutput, bool) bool
	}
	batchGetItemPagesReturns struct {
		result1 error
	}
	batchGetItemPagesReturnsOnCall map[int]struct {
		result1 error
	}
	BatchGetItemPagesWithContextStub        func(context.Context, *dynamodba.BatchGetItemInput, func(*dynamodba.BatchGetItemOutput, bool) bool, ...request.Option) error
	batchGetItemPagesWithContextMutex       sync.RWMutex
	batchGetItemPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.BatchGetItemInput
		arg3 func(*dynamodba.BatchGetItemOutput, bool) bool
		arg4 []request.Option
	}
	batchGetItemPagesWithContextReturns struct {
		result1 error
	}
	batchGetItemPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	BatchGetItemRequestStub        func(*dynamodba.BatchGetItemInput) (*request.Request, *dynamodba.BatchGetItemOutput)
	batchGetItemRequestMutex       sync.RWMutex
	batchGetItemRequestArgsForCall []struct {
		arg1 *dynamodba.BatchGetItemInput
	}
	batchGetItemRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.BatchGetItemOutput
	}
	batchGetItemRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.BatchGetItemOutput
	}
	BatchGetItemWithContextStub        func(context.Context, *dynamodba.BatchGetItemInput, ...request.Option) (*dynamodba.BatchGetItemOutput, error)
	batchGetItemWithContextMutex       sync.RWMutex
	batchGetItemWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.BatchGetItemInput
		arg3 []request.Option
	}
	batchGetItemWithContextReturns struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}
	batchGetItemWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}
	BatchWriteItemStub        func(*dynamodba.BatchWriteItemInput) (*dynamodba.BatchWriteItemOutput, error)
	batchWriteItemMutex       sync.RWMutex
	batchWriteItemArgsForCall []struct {
		arg1 *dynamodba.BatchWriteItemInput
	}
	batchWriteItemReturns struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}
	batchWriteItemReturnsOnCall map[int]struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}
	BatchWriteItemRequestStub        func(*dynamodba.BatchWriteItemInput) (*request.Request, *dynamodba.BatchWriteItemOutput)
	batchWriteItemRequestMutex       sync.RWMutex
	batchWriteItemRequestArgsForCall []struct {
		arg1 *dynamodba.BatchWriteItemInput
	}
	batchWriteItemRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.BatchWriteItemOutput
	}
	batchWriteItemRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.BatchWriteItemOutput
	}
	BatchWriteItemWithContextStub        func(context.Context, *dynamodba.BatchWriteItemInput, ...request.Option) (*dynamodba.BatchWriteItemOutput, error)
	batchWriteItemWithContextMutex       sync.RWMutex
	batchWriteItemWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.BatchWriteItemInput
		arg3 []request.Option
	}
	batchWriteItemWithContextReturns struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}
	batchWriteItemWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}
	CreateBackupStub        func(*dynamodba.CreateBackupInput) (*dynamodba.CreateBackupOutput, error)
	createBackupMutex       sync.RWMutex
	createBackupArgsForCall []struct {
		arg1 *dynamodba.CreateBackupInput
	}
	createBackupReturns struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}
	createBackupReturnsOnCall map[int]struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}
	CreateBackupRequestStub        func(*dynamodba.CreateBackupInput) (*request.Request, *dynamodba.CreateBackupOutput)
	createBackupRequestMutex       sync.RWMutex
	createBackupRequestArgsForCall []struct {
		arg1 *dynamodba.CreateBackupInput
	}
	createBackupRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.CreateBackupOutput
	}
	createBackupRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.CreateBackupOutput
	}
	CreateBackupWithContextStub        func(context.Context, *dynamodba.CreateBackupInput, ...request.Option) (*dynamodba.CreateBackupOutput, error)
	createBackupWithContextMutex       sync.RWMutex
	createBackupWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.CreateBackupInput
		arg3 []request.Option
	}
	createBackupWithContextReturns struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}
	createBackupWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}
	CreateGlobalTableStub        func(*dynamodba.CreateGlobalTableInput) (*dynamodba.CreateGlobalTableOutput, error)
	createGlobalTableMutex       sync.RWMutex
	createGlobalTableArgsForCall []struct {
		arg1 *dynamodba.CreateGlobalTableInput
	}
	createGlobalTableReturns struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}
	createGlobalTableReturnsOnCall map[int]struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}
	CreateGlobalTableRequestStub        func(*dynamodba.CreateGlobalTableInput) (*request.Request, *dynamodba.CreateGlobalTableOutput)
	createGlobalTableRequestMutex       sync.RWMutex
	createGlobalTableRequestArgsForCall []struct {
		arg1 *dynamodba.CreateGlobalTableInput
	}
	createGlobalTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.CreateGlobalTableOutput
	}
	createGlobalTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.CreateGlobalTableOutput
	}
	CreateGlobalTableWithContextStub        func(context.Context, *dynamodba.CreateGlobalTableInput, ...request.Option) (*dynamodba.CreateGlobalTableOutput, error)
	createGlobalTableWithContextMutex       sync.RWMutex
	createGlobalTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.CreateGlobalTableInput
		arg3 []request.Option
	}
	createGlobalTableWithContextReturns struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}
	createGlobalTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}
	CreateTableStub        func(*dynamodba.CreateTableInput) (*dynamodba.CreateTableOutput, error)
	createTableMutex       sync.RWMutex
	createTableArgsForCall []struct {
		arg1 *dynamodba.CreateTableInput
	}
	createTableReturns struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}
	createTableReturnsOnCall map[int]struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}
	CreateTableRequestStub        func(*dynamodba.CreateTableInput) (*request.Request, *dynamodba.CreateTableOutput)
	createTableRequestMutex       sync.RWMutex
	createTableRequestArgsForCall []struct {
		arg1 *dynamodba.CreateTableInput
	}
	createTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.CreateTableOutput
	}
	createTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.CreateTableOutput
	}
	CreateTableWithContextStub        func(context.Context, *dynamodba.CreateTableInput, ...request.Option) (*dynamodba.CreateTableOutput, error)
	createTableWithContextMutex       sync.RWMutex
	createTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.CreateTableInput
		arg3 []request.Option
	}
	createTableWithContextReturns struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}
	createTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}
	DeleteBackupStub        func(*dynamodba.DeleteBackupInput) (*dynamodba.DeleteBackupOutput, error)
	deleteBackupMutex       sync.RWMutex
	deleteBackupArgsForCall []struct {
		arg1 *dynamodba.DeleteBackupInput
	}
	deleteBackupReturns struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}
	deleteBackupReturnsOnCall map[int]struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}
	DeleteBackupRequestStub        func(*dynamodba.DeleteBackupInput) (*request.Request, *dynamodba.DeleteBackupOutput)
	deleteBackupRequestMutex       sync.RWMutex
	deleteBackupRequestArgsForCall []struct {
		arg1 *dynamodba.DeleteBackupInput
	}
	deleteBackupRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DeleteBackupOutput
	}
	deleteBackupRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DeleteBackupOutput
	}
	DeleteBackupWithContextStub        func(context.Context, *dynamodba.DeleteBackupInput, ...request.Option) (*dynamodba.DeleteBackupOutput, error)
	deleteBackupWithContextMutex       sync.RWMutex
	deleteBackupWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DeleteBackupInput
		arg3 []request.Option
	}
	deleteBackupWithContextReturns struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}
	deleteBackupWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}
	DeleteItemStub        func(*dynamodba.DeleteItemInput) (*dynamodba.DeleteItemOutput, error)
	deleteItemMutex       sync.RWMutex
	deleteItemArgsForCall []struct {
		arg1 *dynamodba.DeleteItemInput
	}
	deleteItemReturns struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}
	deleteItemReturnsOnCall map[int]struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}
	DeleteItemRequestStub        func(*dynamodba.DeleteItemInput) (*request.Request, *dynamodba.DeleteItemOutput)
	deleteItemRequestMutex       sync.RWMutex
	deleteItemRequestArgsForCall []struct {
		arg1 *dynamodba.DeleteItemInput
	}
	deleteItemRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DeleteItemOutput
	}
	deleteItemRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DeleteItemOutput
	}
	DeleteItemWithContextStub        func(context.Context, *dynamodba.DeleteItemInput, ...request.Option) (*dynamodba.DeleteItemOutput, error)
	deleteItemWithContextMutex       sync.RWMutex
	deleteItemWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DeleteItemInput
		arg3 []request.Option
	}
	deleteItemWithContextReturns struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}
	deleteItemWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}
	DeleteTableStub        func(*dynamodba.DeleteTableInput) (*dynamodba.DeleteTableOutput, error)
	deleteTableMutex       sync.RWMutex
	deleteTableArgsForCall []struct {
		arg1 *dynamodba.DeleteTableInput
	}
	deleteTableReturns struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}
	deleteTableReturnsOnCall map[int]struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}
	DeleteTableRequestStub        func(*dynamodba.DeleteTableInput) (*request.Request, *dynamodba.DeleteTableOutput)
	deleteTableRequestMutex       sync.RWMutex
	deleteTableRequestArgsForCall []struct {
		arg1 *dynamodba.DeleteTableInput
	}
	deleteTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DeleteTableOutput
	}
	deleteTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DeleteTableOutput
	}
	DeleteTableWithContextStub        func(context.Context, *dynamodba.DeleteTableInput, ...request.Option) (*dynamodba.DeleteTableOutput, error)
	deleteTableWithContextMutex       sync.RWMutex
	deleteTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DeleteTableInput
		arg3 []request.Option
	}
	deleteTableWithContextReturns struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}
	deleteTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}
	DescribeBackupStub        func(*dynamodba.DescribeBackupInput) (*dynamodba.DescribeBackupOutput, error)
	describeBackupMutex       sync.RWMutex
	describeBackupArgsForCall []struct {
		arg1 *dynamodba.DescribeBackupInput
	}
	describeBackupReturns struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}
	describeBackupReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}
	DescribeBackupRequestStub        func(*dynamodba.DescribeBackupInput) (*request.Request, *dynamodba.DescribeBackupOutput)
	describeBackupRequestMutex       sync.RWMutex
	describeBackupRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeBackupInput
	}
	describeBackupRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeBackupOutput
	}
	describeBackupRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeBackupOutput
	}
	DescribeBackupWithContextStub        func(context.Context, *dynamodba.DescribeBackupInput, ...request.Option) (*dynamodba.DescribeBackupOutput, error)
	describeBackupWithContextMutex       sync.RWMutex
	describeBackupWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeBackupInput
		arg3 []request.Option
	}
	describeBackupWithContextReturns struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}
	describeBackupWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}
	DescribeContinuousBackupsStub        func(*dynamodba.DescribeContinuousBackupsInput) (*dynamodba.DescribeContinuousBackupsOutput, error)
	describeContinuousBackupsMutex       sync.RWMutex
	describeContinuousBackupsArgsForCall []struct {
		arg1 *dynamodba.DescribeContinuousBackupsInput
	}
	describeContinuousBackupsReturns struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}
	describeContinuousBackupsReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}
	DescribeContinuousBackupsRequestStub        func(*dynamodba.DescribeContinuousBackupsInput) (*request.Request, *dynamodba.DescribeContinuousBackupsOutput)
	describeContinuousBackupsRequestMutex       sync.RWMutex
	describeContinuousBackupsRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeContinuousBackupsInput
	}
	describeContinuousBackupsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContinuousBackupsOutput
	}
	describeContinuousBackupsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContinuousBackupsOutput
	}
	DescribeContinuousBackupsWithContextStub        func(context.Context, *dynamodba.DescribeContinuousBackupsInput, ...request.Option) (*dynamodba.DescribeContinuousBackupsOutput, error)
	describeContinuousBackupsWithContextMutex       sync.RWMutex
	describeContinuousBackupsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeContinuousBackupsInput
		arg3 []request.Option
	}
	describeContinuousBackupsWithContextReturns struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}
	describeContinuousBackupsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}
	DescribeContributorInsightsStub        func(*dynamodba.DescribeContributorInsightsInput) (*dynamodba.DescribeContributorInsightsOutput, error)
	describeContributorInsightsMutex       sync.RWMutex
	describeContributorInsightsArgsForCall []struct {
		arg1 *dynamodba.DescribeContributorInsightsInput
	}
	describeContributorInsightsReturns struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}
	describeContributorInsightsReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}
	DescribeContributorInsightsRequestStub        func(*dynamodba.DescribeContributorInsightsInput) (*request.Request, *dynamodba.DescribeContributorInsightsOutput)
	describeContributorInsightsRequestMutex       sync.RWMutex
	describeContributorInsightsRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeContributorInsightsInput
	}
	describeContributorInsightsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContributorInsightsOutput
	}
	describeContributorInsightsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContributorInsightsOutput
	}
	DescribeContributorInsightsWithContextStub        func(context.Context, *dynamodba.DescribeContributorInsightsInput, ...request.Option) (*dynamodba.DescribeContributorInsightsOutput, error)
	describeContributorInsightsWithContextMutex       sync.RWMutex
	describeContributorInsightsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeContributorInsightsInput
		arg3 []request.Option
	}
	describeContributorInsightsWithContextReturns struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}
	describeContributorInsightsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}
	DescribeEndpointsStub        func(*dynamodba.DescribeEndpointsInput) (*dynamodba.DescribeEndpointsOutput, error)
	describeEndpointsMutex       sync.RWMutex
	describeEndpointsArgsForCall []struct {
		arg1 *dynamodba.DescribeEndpointsInput
	}
	describeEndpointsReturns struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}
	describeEndpointsReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}
	DescribeEndpointsRequestStub        func(*dynamodba.DescribeEndpointsInput) (*request.Request, *dynamodba.DescribeEndpointsOutput)
	describeEndpointsRequestMutex       sync.RWMutex
	describeEndpointsRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeEndpointsInput
	}
	describeEndpointsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeEndpointsOutput
	}
	describeEndpointsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeEndpointsOutput
	}
	DescribeEndpointsWithContextStub        func(context.Context, *dynamodba.DescribeEndpointsInput, ...request.Option) (*dynamodba.DescribeEndpointsOutput, error)
	describeEndpointsWithContextMutex       sync.RWMutex
	describeEndpointsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeEndpointsInput
		arg3 []request.Option
	}
	describeEndpointsWithContextReturns struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}
	describeEndpointsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}
	DescribeExportStub        func(*dynamodba.DescribeExportInput) (*dynamodba.DescribeExportOutput, error)
	describeExportMutex       sync.RWMutex
	describeExportArgsForCall []struct {
		arg1 *dynamodba.DescribeExportInput
	}
	describeExportReturns struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}
	describeExportReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}
	DescribeExportRequestStub        func(*dynamodba.DescribeExportInput) (*request.Request, *dynamodba.DescribeExportOutput)
	describeExportRequestMutex       sync.RWMutex
	describeExportRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeExportInput
	}
	describeExportRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeExportOutput
	}
	describeExportRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeExportOutput
	}
	DescribeExportWithContextStub        func(context.Context, *dynamodba.DescribeExportInput, ...request.Option) (*dynamodba.DescribeExportOutput, error)
	describeExportWithContextMutex       sync.RWMutex
	describeExportWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeExportInput
		arg3 []request.Option
	}
	describeExportWithContextReturns struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}
	describeExportWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}
	DescribeGlobalTableStub        func(*dynamodba.DescribeGlobalTableInput) (*dynamodba.DescribeGlobalTableOutput, error)
	describeGlobalTableMutex       sync.RWMutex
	describeGlobalTableArgsForCall []struct {
		arg1 *dynamodba.DescribeGlobalTableInput
	}
	describeGlobalTableReturns struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}
	describeGlobalTableReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}
	DescribeGlobalTableRequestStub        func(*dynamodba.DescribeGlobalTableInput) (*request.Request, *dynamodba.DescribeGlobalTableOutput)
	describeGlobalTableRequestMutex       sync.RWMutex
	describeGlobalTableRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeGlobalTableInput
	}
	describeGlobalTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableOutput
	}
	describeGlobalTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableOutput
	}
	DescribeGlobalTableSettingsStub        func(*dynamodba.DescribeGlobalTableSettingsInput) (*dynamodba.DescribeGlobalTableSettingsOutput, error)
	describeGlobalTableSettingsMutex       sync.RWMutex
	describeGlobalTableSettingsArgsForCall []struct {
		arg1 *dynamodba.DescribeGlobalTableSettingsInput
	}
	describeGlobalTableSettingsReturns struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}
	describeGlobalTableSettingsReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}
	DescribeGlobalTableSettingsRequestStub        func(*dynamodba.DescribeGlobalTableSettingsInput) (*request.Request, *dynamodba.DescribeGlobalTableSettingsOutput)
	describeGlobalTableSettingsRequestMutex       sync.RWMutex
	describeGlobalTableSettingsRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeGlobalTableSettingsInput
	}
	describeGlobalTableSettingsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableSettingsOutput
	}
	describeGlobalTableSettingsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableSettingsOutput
	}
	DescribeGlobalTableSettingsWithContextStub        func(context.Context, *dynamodba.DescribeGlobalTableSettingsInput, ...request.Option) (*dynamodba.DescribeGlobalTableSettingsOutput, error)
	describeGlobalTableSettingsWithContextMutex       sync.RWMutex
	describeGlobalTableSettingsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeGlobalTableSettingsInput
		arg3 []request.Option
	}
	describeGlobalTableSettingsWithContextReturns struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}
	describeGlobalTableSettingsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}
	DescribeGlobalTableWithContextStub        func(context.Context, *dynamodba.DescribeGlobalTableInput, ...request.Option) (*dynamodba.DescribeGlobalTableOutput, error)
	describeGlobalTableWithContextMutex       sync.RWMutex
	describeGlobalTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeGlobalTableInput
		arg3 []request.Option
	}
	describeGlobalTableWithContextReturns struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}
	describeGlobalTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}
	DescribeKinesisStreamingDestinationStub        func(*dynamodba.DescribeKinesisStreamingDestinationInput) (*dynamodba.DescribeKinesisStreamingDestinationOutput, error)
	describeKinesisStreamingDestinationMutex       sync.RWMutex
	describeKinesisStreamingDestinationArgsForCall []struct {
		arg1 *dynamodba.DescribeKinesisStreamingDestinationInput
	}
	describeKinesisStreamingDestinationReturns struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}
	describeKinesisStreamingDestinationReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}
	DescribeKinesisStreamingDestinationRequestStub        func(*dynamodba.DescribeKinesisStreamingDestinationInput) (*request.Request, *dynamodba.DescribeKinesisStreamingDestinationOutput)
	describeKinesisStreamingDestinationRequestMutex       sync.RWMutex
	describeKinesisStreamingDestinationRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeKinesisStreamingDestinationInput
	}
	describeKinesisStreamingDestinationRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeKinesisStreamingDestinationOutput
	}
	describeKinesisStreamingDestinationRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeKinesisStreamingDestinationOutput
	}
	DescribeKinesisStreamingDestinationWithContextStub        func(context.Context, *dynamodba.DescribeKinesisStreamingDestinationInput, ...request.Option) (*dynamodba.DescribeKinesisStreamingDestinationOutput, error)
	describeKinesisStreamingDestinationWithContextMutex       sync.RWMutex
	describeKinesisStreamingDestinationWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeKinesisStreamingDestinationInput
		arg3 []request.Option
	}
	describeKinesisStreamingDestinationWithContextReturns struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}
	describeKinesisStreamingDestinationWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}
	DescribeLimitsStub        func(*dynamodba.DescribeLimitsInput) (*dynamodba.DescribeLimitsOutput, error)
	describeLimitsMutex       sync.RWMutex
	describeLimitsArgsForCall []struct {
		arg1 *dynamodba.DescribeLimitsInput
	}
	describeLimitsReturns struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}
	describeLimitsReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}
	DescribeLimitsRequestStub        func(*dynamodba.DescribeLimitsInput) (*request.Request, *dynamodba.DescribeLimitsOutput)
	describeLimitsRequestMutex       sync.RWMutex
	describeLimitsRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeLimitsInput
	}
	describeLimitsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeLimitsOutput
	}
	describeLimitsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeLimitsOutput
	}
	DescribeLimitsWithContextStub        func(context.Context, *dynamodba.DescribeLimitsInput, ...request.Option) (*dynamodba.DescribeLimitsOutput, error)
	describeLimitsWithContextMutex       sync.RWMutex
	describeLimitsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeLimitsInput
		arg3 []request.Option
	}
	describeLimitsWithContextReturns struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}
	describeLimitsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}
	DescribeTableStub        func(*dynamodba.DescribeTableInput) (*dynamodba.DescribeTableOutput, error)
	describeTableMutex       sync.RWMutex
	describeTableArgsForCall []struct {
		arg1 *dynamodba.DescribeTableInput
	}
	describeTableReturns struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}
	describeTableReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}
	DescribeTableReplicaAutoScalingStub        func(*dynamodba.DescribeTableReplicaAutoScalingInput) (*dynamodba.DescribeTableReplicaAutoScalingOutput, error)
	describeTableReplicaAutoScalingMutex       sync.RWMutex
	describeTableReplicaAutoScalingArgsForCall []struct {
		arg1 *dynamodba.DescribeTableReplicaAutoScalingInput
	}
	describeTableReplicaAutoScalingReturns struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}
	describeTableReplicaAutoScalingReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}
	DescribeTableReplicaAutoScalingRequestStub        func(*dynamodba.DescribeTableReplicaAutoScalingInput) (*request.Request, *dynamodba.DescribeTableReplicaAutoScalingOutput)
	describeTableReplicaAutoScalingRequestMutex       sync.RWMutex
	describeTableReplicaAutoScalingRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeTableReplicaAutoScalingInput
	}
	describeTableReplicaAutoScalingRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableReplicaAutoScalingOutput
	}
	describeTableReplicaAutoScalingRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableReplicaAutoScalingOutput
	}
	DescribeTableReplicaAutoScalingWithContextStub        func(context.Context, *dynamodba.DescribeTableReplicaAutoScalingInput, ...request.Option) (*dynamodba.DescribeTableReplicaAutoScalingOutput, error)
	describeTableReplicaAutoScalingWithContextMutex       sync.RWMutex
	describeTableReplicaAutoScalingWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableReplicaAutoScalingInput
		arg3 []request.Option
	}
	describeTableReplicaAutoScalingWithContextReturns struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}
	describeTableReplicaAutoScalingWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}
	DescribeTableRequestStub        func(*dynamodba.DescribeTableInput) (*request.Request, *dynamodba.DescribeTableOutput)
	describeTableRequestMutex       sync.RWMutex
	describeTableRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeTableInput
	}
	describeTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableOutput
	}
	describeTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableOutput
	}
	DescribeTableWithContextStub        func(context.Context, *dynamodba.DescribeTableInput, ...request.Option) (*dynamodba.DescribeTableOutput, error)
	describeTableWithContextMutex       sync.RWMutex
	describeTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableInput
		arg3 []request.Option
	}
	describeTableWithContextReturns struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}
	describeTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}
	DescribeTimeToLiveStub        func(*dynamodba.DescribeTimeToLiveInput) (*dynamodba.DescribeTimeToLiveOutput, error)
	describeTimeToLiveMutex       sync.RWMutex
	describeTimeToLiveArgsForCall []struct {
		arg1 *dynamodba.DescribeTimeToLiveInput
	}
	describeTimeToLiveReturns struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}
	describeTimeToLiveReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}
	DescribeTimeToLiveRequestStub        func(*dynamodba.DescribeTimeToLiveInput) (*request.Request, *dynamodba.DescribeTimeToLiveOutput)
	describeTimeToLiveRequestMutex       sync.RWMutex
	describeTimeToLiveRequestArgsForCall []struct {
		arg1 *dynamodba.DescribeTimeToLiveInput
	}
	describeTimeToLiveRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTimeToLiveOutput
	}
	describeTimeToLiveRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTimeToLiveOutput
	}
	DescribeTimeToLiveWithContextStub        func(context.Context, *dynamodba.DescribeTimeToLiveInput, ...request.Option) (*dynamodba.DescribeTimeToLiveOutput, error)
	describeTimeToLiveWithContextMutex       sync.RWMutex
	describeTimeToLiveWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTimeToLiveInput
		arg3 []request.Option
	}
	describeTimeToLiveWithContextReturns struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}
	describeTimeToLiveWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}
	DisableKinesisStreamingDestinationStub        func(*dynamodba.DisableKinesisStreamingDestinationInput) (*dynamodba.DisableKinesisStreamingDestinationOutput, error)
	disableKinesisStreamingDestinationMutex       sync.RWMutex
	disableKinesisStreamingDestinationArgsForCall []struct {
		arg1 *dynamodba.DisableKinesisStreamingDestinationInput
	}
	disableKinesisStreamingDestinationReturns struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}
	disableKinesisStreamingDestinationReturnsOnCall map[int]struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}
	DisableKinesisStreamingDestinationRequestStub        func(*dynamodba.DisableKinesisStreamingDestinationInput) (*request.Request, *dynamodba.DisableKinesisStreamingDestinationOutput)
	disableKinesisStreamingDestinationRequestMutex       sync.RWMutex
	disableKinesisStreamingDestinationRequestArgsForCall []struct {
		arg1 *dynamodba.DisableKinesisStreamingDestinationInput
	}
	disableKinesisStreamingDestinationRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.DisableKinesisStreamingDestinationOutput
	}
	disableKinesisStreamingDestinationRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.DisableKinesisStreamingDestinationOutput
	}
	DisableKinesisStreamingDestinationWithContextStub        func(context.Context, *dynamodba.DisableKinesisStreamingDestinationInput, ...request.Option) (*dynamodba.DisableKinesisStreamingDestinationOutput, error)
	disableKinesisStreamingDestinationWithContextMutex       sync.RWMutex
	disableKinesisStreamingDestinationWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DisableKinesisStreamingDestinationInput
		arg3 []request.Option
	}
	disableKinesisStreamingDestinationWithContextReturns struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}
	disableKinesisStreamingDestinationWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}
	EnableKinesisStreamingDestinationStub        func(*dynamodba.EnableKinesisStreamingDestinationInput) (*dynamodba.EnableKinesisStreamingDestinationOutput, error)
	enableKinesisStreamingDestinationMutex       sync.RWMutex
	enableKinesisStreamingDestinationArgsForCall []struct {
		arg1 *dynamodba.EnableKinesisStreamingDestinationInput
	}
	enableKinesisStreamingDestinationReturns struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}
	enableKinesisStreamingDestinationReturnsOnCall map[int]struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}
	EnableKinesisStreamingDestinationRequestStub        func(*dynamodba.EnableKinesisStreamingDestinationInput) (*request.Request, *dynamodba.EnableKinesisStreamingDestinationOutput)
	enableKinesisStreamingDestinationRequestMutex       sync.RWMutex
	enableKinesisStreamingDestinationRequestArgsForCall []struct {
		arg1 *dynamodba.EnableKinesisStreamingDestinationInput
	}
	enableKinesisStreamingDestinationRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.EnableKinesisStreamingDestinationOutput
	}
	enableKinesisStreamingDestinationRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.EnableKinesisStreamingDestinationOutput
	}
	EnableKinesisStreamingDestinationWithContextStub        func(context.Context, *dynamodba.EnableKinesisStreamingDestinationInput, ...request.Option) (*dynamodba.EnableKinesisStreamingDestinationOutput, error)
	enableKinesisStreamingDestinationWithContextMutex       sync.RWMutex
	enableKinesisStreamingDestinationWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.EnableKinesisStreamingDestinationInput
		arg3 []request.Option
	}
	enableKinesisStreamingDestinationWithContextReturns struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}
	enableKinesisStreamingDestinationWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}
	ExecuteStatementStub        func(*dynamodba.ExecuteStatementInput) (*dynamodba.ExecuteStatementOutput, error)
	executeStatementMutex       sync.RWMutex
	executeStatementArgsForCall []struct {
		arg1 *dynamodba.ExecuteStatementInput
	}
	executeStatementReturns struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}
	executeStatementReturnsOnCall map[int]struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}
	ExecuteStatementRequestStub        func(*dynamodba.ExecuteStatementInput) (*request.Request, *dynamodba.ExecuteStatementOutput)
	executeStatementRequestMutex       sync.RWMutex
	executeStatementRequestArgsForCall []struct {
		arg1 *dynamodba.ExecuteStatementInput
	}
	executeStatementRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteStatementOutput
	}
	executeStatementRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteStatementOutput
	}
	ExecuteStatementWithContextStub        func(context.Context, *dynamodba.ExecuteStatementInput, ...request.Option) (*dynamodba.ExecuteStatementOutput, error)
	executeStatementWithContextMutex       sync.RWMutex
	executeStatementWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ExecuteStatementInput
		arg3 []request.Option
	}
	executeStatementWithContextReturns struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}
	executeStatementWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}
	ExecuteTransactionStub        func(*dynamodba.ExecuteTransactionInput) (*dynamodba.ExecuteTransactionOutput, error)
	executeTransactionMutex       sync.RWMutex
	executeTransactionArgsForCall []struct {
		arg1 *dynamodba.ExecuteTransactionInput
	}
	executeTransactionReturns struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}
	executeTransactionReturnsOnCall map[int]struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}
	ExecuteTransactionRequestStub        func(*dynamodba.ExecuteTransactionInput) (*request.Request, *dynamodba.ExecuteTransactionOutput)
	executeTransactionRequestMutex       sync.RWMutex
	executeTransactionRequestArgsForCall []struct {
		arg1 *dynamodba.ExecuteTransactionInput
	}
	executeTransactionRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteTransactionOutput
	}
	executeTransactionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteTransactionOutput
	}
	ExecuteTransactionWithContextStub        func(context.Context, *dynamodba.ExecuteTransactionInput, ...request.Option) (*dynamodba.ExecuteTransactionOutput, error)
	executeTransactionWithContextMutex       sync.RWMutex
	executeTransactionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ExecuteTransactionInput
		arg3 []request.Option
	}
	executeTransactionWithContextReturns struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}
	executeTransactionWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}
	ExportTableToPointInTimeStub        func(*dynamodba.ExportTableToPointInTimeInput) (*dynamodba.ExportTableToPointInTimeOutput, error)
	exportTableToPointInTimeMutex       sync.RWMutex
	exportTableToPointInTimeArgsForCall []struct {
		arg1 *dynamodba.ExportTableToPointInTimeInput
	}
	exportTableToPointInTimeReturns struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}
	exportTableToPointInTimeReturnsOnCall map[int]struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}
	ExportTableToPointInTimeRequestStub        func(*dynamodba.ExportTableToPointInTimeInput) (*request.Request, *dynamodba.ExportTableToPointInTimeOutput)
	exportTableToPointInTimeRequestMutex       sync.RWMutex
	exportTableToPointInTimeRequestArgsForCall []struct {
		arg1 *dynamodba.ExportTableToPointInTimeInput
	}
	exportTableToPointInTimeRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ExportTableToPointInTimeOutput
	}
	exportTableToPointInTimeRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ExportTableToPointInTimeOutput
	}
	ExportTableToPointInTimeWithContextStub        func(context.Context, *dynamodba.ExportTableToPointInTimeInput, ...request.Option) (*dynamodba.ExportTableToPointInTimeOutput, error)
	exportTableToPointInTimeWithContextMutex       sync.RWMutex
	exportTableToPointInTimeWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ExportTableToPointInTimeInput
		arg3 []request.Option
	}
	exportTableToPointInTimeWithContextReturns struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}
	exportTableToPointInTimeWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}
	GetItemStub        func(*dynamodba.GetItemInput) (*dynamodba.GetItemOutput, error)
	getItemMutex       sync.RWMutex
	getItemArgsForCall []struct {
		arg1 *dynamodba.GetItemInput
	}
	getItemReturns struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}
	getItemReturnsOnCall map[int]struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}
	GetItemRequestStub        func(*dynamodba.GetItemInput) (*request.Request, *dynamodba.GetItemOutput)
	getItemRequestMutex       sync.RWMutex
	getItemRequestArgsForCall []struct {
		arg1 *dynamodba.GetItemInput
	}
	getItemRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.GetItemOutput
	}
	getItemRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.GetItemOutput
	}
	GetItemWithContextStub        func(context.Context, *dynamodba.GetItemInput, ...request.Option) (*dynamodba.GetItemOutput, error)
	getItemWithContextMutex       sync.RWMutex
	getItemWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.GetItemInput
		arg3 []request.Option
	}
	getItemWithContextReturns struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}
	getItemWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}
	ListBackupsStub        func(*dynamodba.ListBackupsInput) (*dynamodba.ListBackupsOutput, error)
	listBackupsMutex       sync.RWMutex
	listBackupsArgsForCall []struct {
		arg1 *dynamodba.ListBackupsInput
	}
	listBackupsReturns struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}
	listBackupsReturnsOnCall map[int]struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}
	ListBackupsRequestStub        func(*dynamodba.ListBackupsInput) (*request.Request, *dynamodba.ListBackupsOutput)
	listBackupsRequestMutex       sync.RWMutex
	listBackupsRequestArgsForCall []struct {
		arg1 *dynamodba.ListBackupsInput
	}
	listBackupsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ListBackupsOutput
	}
	listBackupsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ListBackupsOutput
	}
	ListBackupsWithContextStub        func(context.Context, *dynamodba.ListBackupsInput, ...request.Option) (*dynamodba.ListBackupsOutput, error)
	listBackupsWithContextMutex       sync.RWMutex
	listBackupsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListBackupsInput
		arg3 []request.Option
	}
	listBackupsWithContextReturns struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}
	listBackupsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}
	ListContributorInsightsStub        func(*dynamodba.ListContributorInsightsInput) (*dynamodba.ListContributorInsightsOutput, error)
	listContributorInsightsMutex       sync.RWMutex
	listContributorInsightsArgsForCall []struct {
		arg1 *dynamodba.ListContributorInsightsInput
	}
	listContributorInsightsReturns struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}
	listContributorInsightsReturnsOnCall map[int]struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}
	ListContributorInsightsPagesStub        func(*dynamodba.ListContributorInsightsInput, func(*dynamodba.ListContributorInsightsOutput, bool) bool) error
	listContributorInsightsPagesMutex       sync.RWMutex
	listContributorInsightsPagesArgsForCall []struct {
		arg1 *dynamodba.ListContributorInsightsInput
		arg2 func(*dynamodba.ListContributorInsightsOutput, bool) bool
	}
	listContributorInsightsPagesReturns struct {
		result1 error
	}
	listContributorInsightsPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListContributorInsightsPagesWithContextStub        func(context.Context, *dynamodba.ListContributorInsightsInput, func(*dynamodba.ListContributorInsightsOutput, bool) bool, ...request.Option) error
	listContributorInsightsPagesWithContextMutex       sync.RWMutex
	listContributorInsightsPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListContributorInsightsInput
		arg3 func(*dynamodba.ListContributorInsightsOutput, bool) bool
		arg4 []request.Option
	}
	listContributorInsightsPagesWithContextReturns struct {
		result1 error
	}
	listContributorInsightsPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListContributorInsightsRequestStub        func(*dynamodba.ListContributorInsightsInput) (*request.Request, *dynamodba.ListContributorInsightsOutput)
	listContributorInsightsRequestMutex       sync.RWMutex
	listContributorInsightsRequestArgsForCall []struct {
		arg1 *dynamodba.ListContributorInsightsInput
	}
	listContributorInsightsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ListContributorInsightsOutput
	}
	listContributorInsightsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ListContributorInsightsOutput
	}
	ListContributorInsightsWithContextStub        func(context.Context, *dynamodba.ListContributorInsightsInput, ...request.Option) (*dynamodba.ListContributorInsightsOutput, error)
	listContributorInsightsWithContextMutex       sync.RWMutex
	listContributorInsightsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListContributorInsightsInput
		arg3 []request.Option
	}
	listContributorInsightsWithContextReturns struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}
	listContributorInsightsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}
	ListExportsStub        func(*dynamodba.ListExportsInput) (*dynamodba.ListExportsOutput, error)
	listExportsMutex       sync.RWMutex
	listExportsArgsForCall []struct {
		arg1 *dynamodba.ListExportsInput
	}
	listExportsReturns struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}
	listExportsReturnsOnCall map[int]struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}
	ListExportsPagesStub        func(*dynamodba.ListExportsInput, func(*dynamodba.ListExportsOutput, bool) bool) error
	listExportsPagesMutex       sync.RWMutex
	listExportsPagesArgsForCall []struct {
		arg1 *dynamodba.ListExportsInput
		arg2 func(*dynamodba.ListExportsOutput, bool) bool
	}
	listExportsPagesReturns struct {
		result1 error
	}
	listExportsPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListExportsPagesWithContextStub        func(context.Context, *dynamodba.ListExportsInput, func(*dynamodba.ListExportsOutput, bool) bool, ...request.Option) error
	listExportsPagesWithContextMutex       sync.RWMutex
	listExportsPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListExportsInput
		arg3 func(*dynamodba.ListExportsOutput, bool) bool
		arg4 []request.Option
	}
	listExportsPagesWithContextReturns struct {
		result1 error
	}
	listExportsPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListExportsRequestStub        func(*dynamodba.ListExportsInput) (*request.Request, *dynamodba.ListExportsOutput)
	listExportsRequestMutex       sync.RWMutex
	listExportsRequestArgsForCall []struct {
		arg1 *dynamodba.ListExportsInput
	}
	listExportsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ListExportsOutput
	}
	listExportsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ListExportsOutput
	}
	ListExportsWithContextStub        func(context.Context, *dynamodba.ListExportsInput, ...request.Option) (*dynamodba.ListExportsOutput, error)
	listExportsWithContextMutex       sync.RWMutex
	listExportsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListExportsInput
		arg3 []request.Option
	}
	listExportsWithContextReturns struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}
	listExportsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}
	ListGlobalTablesStub        func(*dynamodba.ListGlobalTablesInput) (*dynamodba.ListGlobalTablesOutput, error)
	listGlobalTablesMutex       sync.RWMutex
	listGlobalTablesArgsForCall []struct {
		arg1 *dynamodba.ListGlobalTablesInput
	}
	listGlobalTablesReturns struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}
	listGlobalTablesReturnsOnCall map[int]struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}
	ListGlobalTablesRequestStub        func(*dynamodba.ListGlobalTablesInput) (*request.Request, *dynamodba.ListGlobalTablesOutput)
	listGlobalTablesRequestMutex       sync.RWMutex
	listGlobalTablesRequestArgsForCall []struct {
		arg1 *dynamodba.ListGlobalTablesInput
	}
	listGlobalTablesRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ListGlobalTablesOutput
	}
	listGlobalTablesRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ListGlobalTablesOutput
	}
	ListGlobalTablesWithContextStub        func(context.Context, *dynamodba.ListGlobalTablesInput, ...request.Option) (*dynamodba.ListGlobalTablesOutput, error)
	listGlobalTablesWithContextMutex       sync.RWMutex
	listGlobalTablesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListGlobalTablesInput
		arg3 []request.Option
	}
	listGlobalTablesWithContextReturns struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}
	listGlobalTablesWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}
	ListTablesStub        func(*dynamodba.ListTablesInput) (*dynamodba.ListTablesOutput, error)
	listTablesMutex       sync.RWMutex
	listTablesArgsForCall []struct {
		arg1 *dynamodba.ListTablesInput
	}
	listTablesReturns struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}
	listTablesReturnsOnCall map[int]struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}
	ListTablesPagesStub        func(*dynamodba.ListTablesInput, func(*dynamodba.ListTablesOutput, bool) bool) error
	listTablesPagesMutex       sync.RWMutex
	listTablesPagesArgsForCall []struct {
		arg1 *dynamodba.ListTablesInput
		arg2 func(*dynamodba.ListTablesOutput, bool) bool
	}
	listTablesPagesReturns struct {
		result1 error
	}
	listTablesPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListTablesPagesWithContextStub        func(context.Context, *dynamodba.ListTablesInput, func(*dynamodba.ListTablesOutput, bool) bool, ...request.Option) error
	listTablesPagesWithContextMutex       sync.RWMutex
	listTablesPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListTablesInput
		arg3 func(*dynamodba.ListTablesOutput, bool) bool
		arg4 []request.Option
	}
	listTablesPagesWithContextReturns struct {
		result1 error
	}
	listTablesPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListTablesRequestStub        func(*dynamodba.ListTablesInput) (*request.Request, *dynamodba.ListTablesOutput)
	listTablesRequestMutex       sync.RWMutex
	listTablesRequestArgsForCall []struct {
		arg1 *dynamodba.ListTablesInput
	}
	listTablesRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ListTablesOutput
	}
	listTablesRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ListTablesOutput
	}
	ListTablesWithContextStub        func(context.Context, *dynamodba.ListTablesInput, ...request.Option) (*dynamodba.ListTablesOutput, error)
	listTablesWithContextMutex       sync.RWMutex
	listTablesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListTablesInput
		arg3 []request.Option
	}
	listTablesWithContextReturns struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}
	listTablesWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}
	ListTagsOfResourceStub        func(*dynamodba.ListTagsOfResourceInput) (*dynamodba.ListTagsOfResourceOutput, error)
	listTagsOfResourceMutex       sync.RWMutex
	listTagsOfResourceArgsForCall []struct {
		arg1 *dynamodba.ListTagsOfResourceInput
	}
	listTagsOfResourceReturns struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}
	listTagsOfResourceReturnsOnCall map[int]struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}
	ListTagsOfResourceRequestStub        func(*dynamodba.ListTagsOfResourceInput) (*request.Request, *dynamodba.ListTagsOfResourceOutput)
	listTagsOfResourceRequestMutex       sync.RWMutex
	listTagsOfResourceRequestArgsForCall []struct {
		arg1 *dynamodba.ListTagsOfResourceInput
	}
	listTagsOfResourceRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ListTagsOfResourceOutput
	}
	listTagsOfResourceRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ListTagsOfResourceOutput
	}
	ListTagsOfResourceWithContextStub        func(context.Context, *dynamodba.ListTagsOfResourceInput, ...request.Option) (*dynamodba.ListTagsOfResourceOutput, error)
	listTagsOfResourceWithContextMutex       sync.RWMutex
	listTagsOfResourceWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ListTagsOfResourceInput
		arg3 []request.Option
	}
	listTagsOfResourceWithContextReturns struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}
	listTagsOfResourceWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}
	PutItemStub        func(*dynamodba.PutItemInput) (*dynamodba.PutItemOutput, error)
	putItemMutex       sync.RWMutex
	putItemArgsForCall []struct {
		arg1 *dynamodba.PutItemInput
	}
	putItemReturns struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}
	putItemReturnsOnCall map[int]struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}
	PutItemRequestStub        func(*dynamodba.PutItemInput) (*request.Request, *dynamodba.PutItemOutput)
	putItemRequestMutex       sync.RWMutex
	putItemRequestArgsForCall []struct {
		arg1 *dynamodba.PutItemInput
	}
	putItemRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.PutItemOutput
	}
	putItemRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.PutItemOutput
	}
	PutItemWithContextStub        func(context.Context, *dynamodba.PutItemInput, ...request.Option) (*dynamodba.PutItemOutput, error)
	putItemWithContextMutex       sync.RWMutex
	putItemWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.PutItemInput
		arg3 []request.Option
	}
	putItemWithContextReturns struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}
	putItemWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}
	QueryStub        func(*dynamodba.QueryInput) (*dynamodba.QueryOutput, error)
	queryMutex       sync.RWMutex
	queryArgsForCall []struct {
		arg1 *dynamodba.QueryInput
	}
	queryReturns struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}
	queryReturnsOnCall map[int]struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}
	QueryPagesStub        func(*dynamodba.QueryInput, func(*dynamodba.QueryOutput, bool) bool) error
	queryPagesMutex       sync.RWMutex
	queryPagesArgsForCall []struct {
		arg1 *dynamodba.QueryInput
		arg2 func(*dynamodba.QueryOutput, bool) bool
	}
	queryPagesReturns struct {
		result1 error
	}
	queryPagesReturnsOnCall map[int]struct {
		result1 error
	}
	QueryPagesWithContextStub        func(context.Context, *dynamodba.QueryInput, func(*dynamodba.QueryOutput, bool) bool, ...request.Option) error
	queryPagesWithContextMutex       sync.RWMutex
	queryPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.QueryInput
		arg3 func(*dynamodba.QueryOutput, bool) bool
		arg4 []request.Option
	}
	queryPagesWithContextReturns struct {
		result1 error
	}
	queryPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	QueryRequestStub        func(*dynamodba.QueryInput) (*request.Request, *dynamodba.QueryOutput)
	queryRequestMutex       sync.RWMutex
	queryRequestArgsForCall []struct {
		arg1 *dynamodba.QueryInput
	}
	queryRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.QueryOutput
	}
	queryRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.QueryOutput
	}
	QueryWithContextStub        func(context.Context, *dynamodba.QueryInput, ...request.Option) (*dynamodba.QueryOutput, error)
	queryWithContextMutex       sync.RWMutex
	queryWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.QueryInput
		arg3 []request.Option
	}
	queryWithContextReturns struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}
	queryWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}
	RestoreTableFromBackupStub        func(*dynamodba.RestoreTableFromBackupInput) (*dynamodba.RestoreTableFromBackupOutput, error)
	restoreTableFromBackupMutex       sync.RWMutex
	restoreTableFromBackupArgsForCall []struct {
		arg1 *dynamodba.RestoreTableFromBackupInput
	}
	restoreTableFromBackupReturns struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}
	restoreTableFromBackupReturnsOnCall map[int]struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}
	RestoreTableFromBackupRequestStub        func(*dynamodba.RestoreTableFromBackupInput) (*request.Request, *dynamodba.RestoreTableFromBackupOutput)
	restoreTableFromBackupRequestMutex       sync.RWMutex
	restoreTableFromBackupRequestArgsForCall []struct {
		arg1 *dynamodba.RestoreTableFromBackupInput
	}
	restoreTableFromBackupRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableFromBackupOutput
	}
	restoreTableFromBackupRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableFromBackupOutput
	}
	RestoreTableFromBackupWithContextStub        func(context.Context, *dynamodba.RestoreTableFromBackupInput, ...request.Option) (*dynamodba.RestoreTableFromBackupOutput, error)
	restoreTableFromBackupWithContextMutex       sync.RWMutex
	restoreTableFromBackupWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.RestoreTableFromBackupInput
		arg3 []request.Option
	}
	restoreTableFromBackupWithContextReturns struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}
	restoreTableFromBackupWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}
	RestoreTableToPointInTimeStub        func(*dynamodba.RestoreTableToPointInTimeInput) (*dynamodba.RestoreTableToPointInTimeOutput, error)
	restoreTableToPointInTimeMutex       sync.RWMutex
	restoreTableToPointInTimeArgsForCall []struct {
		arg1 *dynamodba.RestoreTableToPointInTimeInput
	}
	restoreTableToPointInTimeReturns struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}
	restoreTableToPointInTimeReturnsOnCall map[int]struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}
	RestoreTableToPointInTimeRequestStub        func(*dynamodba.RestoreTableToPointInTimeInput) (*request.Request, *dynamodba.RestoreTableToPointInTimeOutput)
	restoreTableToPointInTimeRequestMutex       sync.RWMutex
	restoreTableToPointInTimeRequestArgsForCall []struct {
		arg1 *dynamodba.RestoreTableToPointInTimeInput
	}
	restoreTableToPointInTimeRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableToPointInTimeOutput
	}
	restoreTableToPointInTimeRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableToPointInTimeOutput
	}
	RestoreTableToPointInTimeWithContextStub        func(context.Context, *dynamodba.RestoreTableToPointInTimeInput, ...request.Option) (*dynamodba.RestoreTableToPointInTimeOutput, error)
	restoreTableToPointInTimeWithContextMutex       sync.RWMutex
	restoreTableToPointInTimeWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.RestoreTableToPointInTimeInput
		arg3 []request.Option
	}
	restoreTableToPointInTimeWithContextReturns struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}
	restoreTableToPointInTimeWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}
	ScanStub        func(*dynamodba.ScanInput) (*dynamodba.ScanOutput, error)
	scanMutex       sync.RWMutex
	scanArgsForCall []struct {
		arg1 *dynamodba.ScanInput
	}
	scanReturns struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}
	scanReturnsOnCall map[int]struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}
	ScanPagesStub        func(*dynamodba.ScanInput, func(*dynamodba.ScanOutput, bool) bool) error
	scanPagesMutex       sync.RWMutex
	scanPagesArgsForCall []struct {
		arg1 *dynamodba.ScanInput
		arg2 func(*dynamodba.ScanOutput, bool) bool
	}
	scanPagesReturns struct {
		result1 error
	}
	scanPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ScanPagesWithContextStub        func(context.Context, *dynamodba.ScanInput, func(*dynamodba.ScanOutput, bool) bool, ...request.Option) error
	scanPagesWithContextMutex       sync.RWMutex
	scanPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ScanInput
		arg3 func(*dynamodba.ScanOutput, bool) bool
		arg4 []request.Option
	}
	scanPagesWithContextReturns struct {
		result1 error
	}
	scanPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ScanRequestStub        func(*dynamodba.ScanInput) (*request.Request, *dynamodba.ScanOutput)
	scanRequestMutex       sync.RWMutex
	scanRequestArgsForCall []struct {
		arg1 *dynamodba.ScanInput
	}
	scanRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.ScanOutput
	}
	scanRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.ScanOutput
	}
	ScanWithContextStub        func(context.Context, *dynamodba.ScanInput, ...request.Option) (*dynamodba.ScanOutput, error)
	scanWithContextMutex       sync.RWMutex
	scanWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.ScanInput
		arg3 []request.Option
	}
	scanWithContextReturns struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}
	scanWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}
	TagResourceStub        func(*dynamodba.TagResourceInput) (*dynamodba.TagResourceOutput, error)
	tagResourceMutex       sync.RWMutex
	tagResourceArgsForCall []struct {
		arg1 *dynamodba.TagResourceInput
	}
	tagResourceReturns struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}
	tagResourceReturnsOnCall map[int]struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}
	TagResourceRequestStub        func(*dynamodba.TagResourceInput) (*request.Request, *dynamodba.TagResourceOutput)
	tagResourceRequestMutex       sync.RWMutex
	tagResourceRequestArgsForCall []struct {
		arg1 *dynamodba.TagResourceInput
	}
	tagResourceRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.TagResourceOutput
	}
	tagResourceRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.TagResourceOutput
	}
	TagResourceWithContextStub        func(context.Context, *dynamodba.TagResourceInput, ...request.Option) (*dynamodba.TagResourceOutput, error)
	tagResourceWithContextMutex       sync.RWMutex
	tagResourceWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.TagResourceInput
		arg3 []request.Option
	}
	tagResourceWithContextReturns struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}
	tagResourceWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}
	TransactGetItemsStub        func(*dynamodba.TransactGetItemsInput) (*dynamodba.TransactGetItemsOutput, error)
	transactGetItemsMutex       sync.RWMutex
	transactGetItemsArgsForCall []struct {
		arg1 *dynamodba.TransactGetItemsInput
	}
	transactGetItemsReturns struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}
	transactGetItemsReturnsOnCall map[int]struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}
	TransactGetItemsRequestStub        func(*dynamodba.TransactGetItemsInput) (*request.Request, *dynamodba.TransactGetItemsOutput)
	transactGetItemsRequestMutex       sync.RWMutex
	transactGetItemsRequestArgsForCall []struct {
		arg1 *dynamodba.TransactGetItemsInput
	}
	transactGetItemsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.TransactGetItemsOutput
	}
	transactGetItemsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.TransactGetItemsOutput
	}
	TransactGetItemsWithContextStub        func(context.Context, *dynamodba.TransactGetItemsInput, ...request.Option) (*dynamodba.TransactGetItemsOutput, error)
	transactGetItemsWithContextMutex       sync.RWMutex
	transactGetItemsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.TransactGetItemsInput
		arg3 []request.Option
	}
	transactGetItemsWithContextReturns struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}
	transactGetItemsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}
	TransactWriteItemsStub        func(*dynamodba.TransactWriteItemsInput) (*dynamodba.TransactWriteItemsOutput, error)
	transactWriteItemsMutex       sync.RWMutex
	transactWriteItemsArgsForCall []struct {
		arg1 *dynamodba.TransactWriteItemsInput
	}
	transactWriteItemsReturns struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}
	transactWriteItemsReturnsOnCall map[int]struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}
	TransactWriteItemsRequestStub        func(*dynamodba.TransactWriteItemsInput) (*request.Request, *dynamodba.TransactWriteItemsOutput)
	transactWriteItemsRequestMutex       sync.RWMutex
	transactWriteItemsRequestArgsForCall []struct {
		arg1 *dynamodba.TransactWriteItemsInput
	}
	transactWriteItemsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.TransactWriteItemsOutput
	}
	transactWriteItemsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.TransactWriteItemsOutput
	}
	TransactWriteItemsWithContextStub        func(context.Context, *dynamodba.TransactWriteItemsInput, ...request.Option) (*dynamodba.TransactWriteItemsOutput, error)
	transactWriteItemsWithContextMutex       sync.RWMutex
	transactWriteItemsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.TransactWriteItemsInput
		arg3 []request.Option
	}
	transactWriteItemsWithContextReturns struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}
	transactWriteItemsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}
	UntagResourceStub        func(*dynamodba.UntagResourceInput) (*dynamodba.UntagResourceOutput, error)
	untagResourceMutex       sync.RWMutex
	untagResourceArgsForCall []struct {
		arg1 *dynamodba.UntagResourceInput
	}
	untagResourceReturns struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}
	untagResourceReturnsOnCall map[int]struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}
	UntagResourceRequestStub        func(*dynamodba.UntagResourceInput) (*request.Request, *dynamodba.UntagResourceOutput)
	untagResourceRequestMutex       sync.RWMutex
	untagResourceRequestArgsForCall []struct {
		arg1 *dynamodba.UntagResourceInput
	}
	untagResourceRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UntagResourceOutput
	}
	untagResourceRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UntagResourceOutput
	}
	UntagResourceWithContextStub        func(context.Context, *dynamodba.UntagResourceInput, ...request.Option) (*dynamodba.UntagResourceOutput, error)
	untagResourceWithContextMutex       sync.RWMutex
	untagResourceWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UntagResourceInput
		arg3 []request.Option
	}
	untagResourceWithContextReturns struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}
	untagResourceWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}
	UpdateContinuousBackupsStub        func(*dynamodba.UpdateContinuousBackupsInput) (*dynamodba.UpdateContinuousBackupsOutput, error)
	updateContinuousBackupsMutex       sync.RWMutex
	updateContinuousBackupsArgsForCall []struct {
		arg1 *dynamodba.UpdateContinuousBackupsInput
	}
	updateContinuousBackupsReturns struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}
	updateContinuousBackupsReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}
	UpdateContinuousBackupsRequestStub        func(*dynamodba.UpdateContinuousBackupsInput) (*request.Request, *dynamodba.UpdateContinuousBackupsOutput)
	updateContinuousBackupsRequestMutex       sync.RWMutex
	updateContinuousBackupsRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateContinuousBackupsInput
	}
	updateContinuousBackupsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContinuousBackupsOutput
	}
	updateContinuousBackupsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContinuousBackupsOutput
	}
	UpdateContinuousBackupsWithContextStub        func(context.Context, *dynamodba.UpdateContinuousBackupsInput, ...request.Option) (*dynamodba.UpdateContinuousBackupsOutput, error)
	updateContinuousBackupsWithContextMutex       sync.RWMutex
	updateContinuousBackupsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateContinuousBackupsInput
		arg3 []request.Option
	}
	updateContinuousBackupsWithContextReturns struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}
	updateContinuousBackupsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}
	UpdateContributorInsightsStub        func(*dynamodba.UpdateContributorInsightsInput) (*dynamodba.UpdateContributorInsightsOutput, error)
	updateContributorInsightsMutex       sync.RWMutex
	updateContributorInsightsArgsForCall []struct {
		arg1 *dynamodba.UpdateContributorInsightsInput
	}
	updateContributorInsightsReturns struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}
	updateContributorInsightsReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}
	UpdateContributorInsightsRequestStub        func(*dynamodba.UpdateContributorInsightsInput) (*request.Request, *dynamodba.UpdateContributorInsightsOutput)
	updateContributorInsightsRequestMutex       sync.RWMutex
	updateContributorInsightsRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateContributorInsightsInput
	}
	updateContributorInsightsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContributorInsightsOutput
	}
	updateContributorInsightsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContributorInsightsOutput
	}
	UpdateContributorInsightsWithContextStub        func(context.Context, *dynamodba.UpdateContributorInsightsInput, ...request.Option) (*dynamodba.UpdateContributorInsightsOutput, error)
	updateContributorInsightsWithContextMutex       sync.RWMutex
	updateContributorInsightsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateContributorInsightsInput
		arg3 []request.Option
	}
	updateContributorInsightsWithContextReturns struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}
	updateContributorInsightsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}
	UpdateGlobalTableStub        func(*dynamodba.UpdateGlobalTableInput) (*dynamodba.UpdateGlobalTableOutput, error)
	updateGlobalTableMutex       sync.RWMutex
	updateGlobalTableArgsForCall []struct {
		arg1 *dynamodba.UpdateGlobalTableInput
	}
	updateGlobalTableReturns struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}
	updateGlobalTableReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}
	UpdateGlobalTableRequestStub        func(*dynamodba.UpdateGlobalTableInput) (*request.Request, *dynamodba.UpdateGlobalTableOutput)
	updateGlobalTableRequestMutex       sync.RWMutex
	updateGlobalTableRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateGlobalTableInput
	}
	updateGlobalTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableOutput
	}
	updateGlobalTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableOutput
	}
	UpdateGlobalTableSettingsStub        func(*dynamodba.UpdateGlobalTableSettingsInput) (*dynamodba.UpdateGlobalTableSettingsOutput, error)
	updateGlobalTableSettingsMutex       sync.RWMutex
	updateGlobalTableSettingsArgsForCall []struct {
		arg1 *dynamodba.UpdateGlobalTableSettingsInput
	}
	updateGlobalTableSettingsReturns struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}
	updateGlobalTableSettingsReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}
	UpdateGlobalTableSettingsRequestStub        func(*dynamodba.UpdateGlobalTableSettingsInput) (*request.Request, *dynamodba.UpdateGlobalTableSettingsOutput)
	updateGlobalTableSettingsRequestMutex       sync.RWMutex
	updateGlobalTableSettingsRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateGlobalTableSettingsInput
	}
	updateGlobalTableSettingsRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableSettingsOutput
	}
	updateGlobalTableSettingsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableSettingsOutput
	}
	UpdateGlobalTableSettingsWithContextStub        func(context.Context, *dynamodba.UpdateGlobalTableSettingsInput, ...request.Option) (*dynamodba.UpdateGlobalTableSettingsOutput, error)
	updateGlobalTableSettingsWithContextMutex       sync.RWMutex
	updateGlobalTableSettingsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateGlobalTableSettingsInput
		arg3 []request.Option
	}
	updateGlobalTableSettingsWithContextReturns struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}
	updateGlobalTableSettingsWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}
	UpdateGlobalTableWithContextStub        func(context.Context, *dynamodba.UpdateGlobalTableInput, ...request.Option) (*dynamodba.UpdateGlobalTableOutput, error)
	updateGlobalTableWithContextMutex       sync.RWMutex
	updateGlobalTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateGlobalTableInput
		arg3 []request.Option
	}
	updateGlobalTableWithContextReturns struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}
	updateGlobalTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}
	UpdateItemStub        func(*dynamodba.UpdateItemInput) (*dynamodba.UpdateItemOutput, error)
	updateItemMutex       sync.RWMutex
	updateItemArgsForCall []struct {
		arg1 *dynamodba.UpdateItemInput
	}
	updateItemReturns struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}
	updateItemReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}
	UpdateItemRequestStub        func(*dynamodba.UpdateItemInput) (*request.Request, *dynamodba.UpdateItemOutput)
	updateItemRequestMutex       sync.RWMutex
	updateItemRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateItemInput
	}
	updateItemRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateItemOutput
	}
	updateItemRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateItemOutput
	}
	UpdateItemWithContextStub        func(context.Context, *dynamodba.UpdateItemInput, ...request.Option) (*dynamodba.UpdateItemOutput, error)
	updateItemWithContextMutex       sync.RWMutex
	updateItemWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateItemInput
		arg3 []request.Option
	}
	updateItemWithContextReturns struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}
	updateItemWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}
	UpdateTableStub        func(*dynamodba.UpdateTableInput) (*dynamodba.UpdateTableOutput, error)
	updateTableMutex       sync.RWMutex
	updateTableArgsForCall []struct {
		arg1 *dynamodba.UpdateTableInput
	}
	updateTableReturns struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}
	updateTableReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}
	UpdateTableReplicaAutoScalingStub        func(*dynamodba.UpdateTableReplicaAutoScalingInput) (*dynamodba.UpdateTableReplicaAutoScalingOutput, error)
	updateTableReplicaAutoScalingMutex       sync.RWMutex
	updateTableReplicaAutoScalingArgsForCall []struct {
		arg1 *dynamodba.UpdateTableReplicaAutoScalingInput
	}
	updateTableReplicaAutoScalingReturns struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}
	updateTableReplicaAutoScalingReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}
	UpdateTableReplicaAutoScalingRequestStub        func(*dynamodba.UpdateTableReplicaAutoScalingInput) (*request.Request, *dynamodba.UpdateTableReplicaAutoScalingOutput)
	updateTableReplicaAutoScalingRequestMutex       sync.RWMutex
	updateTableReplicaAutoScalingRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateTableReplicaAutoScalingInput
	}
	updateTableReplicaAutoScalingRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableReplicaAutoScalingOutput
	}
	updateTableReplicaAutoScalingRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableReplicaAutoScalingOutput
	}
	UpdateTableReplicaAutoScalingWithContextStub        func(context.Context, *dynamodba.UpdateTableReplicaAutoScalingInput, ...request.Option) (*dynamodba.UpdateTableReplicaAutoScalingOutput, error)
	updateTableReplicaAutoScalingWithContextMutex       sync.RWMutex
	updateTableReplicaAutoScalingWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateTableReplicaAutoScalingInput
		arg3 []request.Option
	}
	updateTableReplicaAutoScalingWithContextReturns struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}
	updateTableReplicaAutoScalingWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}
	UpdateTableRequestStub        func(*dynamodba.UpdateTableInput) (*request.Request, *dynamodba.UpdateTableOutput)
	updateTableRequestMutex       sync.RWMutex
	updateTableRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateTableInput
	}
	updateTableRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableOutput
	}
	updateTableRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableOutput
	}
	UpdateTableWithContextStub        func(context.Context, *dynamodba.UpdateTableInput, ...request.Option) (*dynamodba.UpdateTableOutput, error)
	updateTableWithContextMutex       sync.RWMutex
	updateTableWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateTableInput
		arg3 []request.Option
	}
	updateTableWithContextReturns struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}
	updateTableWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}
	UpdateTimeToLiveStub        func(*dynamodba.UpdateTimeToLiveInput) (*dynamodba.UpdateTimeToLiveOutput, error)
	updateTimeToLiveMutex       sync.RWMutex
	updateTimeToLiveArgsForCall []struct {
		arg1 *dynamodba.UpdateTimeToLiveInput
	}
	updateTimeToLiveReturns struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}
	updateTimeToLiveReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}
	UpdateTimeToLiveRequestStub        func(*dynamodba.UpdateTimeToLiveInput) (*request.Request, *dynamodba.UpdateTimeToLiveOutput)
	updateTimeToLiveRequestMutex       sync.RWMutex
	updateTimeToLiveRequestArgsForCall []struct {
		arg1 *dynamodba.UpdateTimeToLiveInput
	}
	updateTimeToLiveRequestReturns struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTimeToLiveOutput
	}
	updateTimeToLiveRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTimeToLiveOutput
	}
	UpdateTimeToLiveWithContextStub        func(context.Context, *dynamodba.UpdateTimeToLiveInput, ...request.Option) (*dynamodba.UpdateTimeToLiveOutput, error)
	updateTimeToLiveWithContextMutex       sync.RWMutex
	updateTimeToLiveWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateTimeToLiveInput
		arg3 []request.Option
	}
	updateTimeToLiveWithContextReturns struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}
	updateTimeToLiveWithContextReturnsOnCall map[int]struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}
	WaitUntilTableExistsStub        func(*dynamodba.DescribeTableInput) error
	waitUntilTableExistsMutex       sync.RWMutex
	waitUntilTableExistsArgsForCall []struct {
		arg1 *dynamodba.DescribeTableInput
	}
	waitUntilTableExistsReturns struct {
		result1 error
	}
	waitUntilTableExistsReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilTableExistsWithContextStub        func(context.Context, *dynamodba.DescribeTableInput, ...request.WaiterOption) error
	waitUntilTableExistsWithContextMutex       sync.RWMutex
	waitUntilTableExistsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableInput
		arg3 []request.WaiterOption
	}
	waitUntilTableExistsWithContextReturns struct {
		result1 error
	}
	waitUntilTableExistsWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilTableNotExistsStub        func(*dynamodba.DescribeTableInput) error
	waitUntilTableNotExistsMutex       sync.RWMutex
	waitUntilTableNotExistsArgsForCall []struct {
		arg1 *dynamodba.DescribeTableInput
	}
	waitUntilTableNotExistsReturns struct {
		result1 error
	}
	waitUntilTableNotExistsReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilTableNotExistsWithContextStub        func(context.Context, *dynamodba.DescribeTableInput, ...request.WaiterOption) error
	waitUntilTableNotExistsWithContextMutex       sync.RWMutex
	waitUntilTableNotExistsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableInput
		arg3 []request.WaiterOption
	}
	waitUntilTableNotExistsWithContextReturns struct {
		result1 error
	}
	waitUntilTableNotExistsWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDynamoDB) BatchExecuteStatement(arg1 *dynamodba.BatchExecuteStatementInput) (*dynamodba.BatchExecuteStatementOutput, error) {
	fake.batchExecuteStatementMutex.Lock()
	ret, specificReturn := fake.batchExecuteStatementReturnsOnCall[len(fake.batchExecuteStatementArgsForCall)]
	fake.batchExecuteStatementArgsForCall = append(fake.batchExecuteStatementArgsForCall, struct {
		arg1 *dynamodba.BatchExecuteStatementInput
	}{arg1})
	fake.recordInvocation("BatchExecuteStatement", []interface{}{arg1})
	fake.batchExecuteStatementMutex.Unlock()
	if fake.BatchExecuteStatementStub != nil {
		return fake.BatchExecuteStatementStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchExecuteStatementReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchExecuteStatementCallCount() int {
	fake.batchExecuteStatementMutex.RLock()
	defer fake.batchExecuteStatementMutex.RUnlock()
	return len(fake.batchExecuteStatementArgsForCall)
}

func (fake *FakeDynamoDB) BatchExecuteStatementCalls(stub func(*dynamodba.BatchExecuteStatementInput) (*dynamodba.BatchExecuteStatementOutput, error)) {
	fake.batchExecuteStatementMutex.Lock()
	defer fake.batchExecuteStatementMutex.Unlock()
	fake.BatchExecuteStatementStub = stub
}

func (fake *FakeDynamoDB) BatchExecuteStatementArgsForCall(i int) *dynamodba.BatchExecuteStatementInput {
	fake.batchExecuteStatementMutex.RLock()
	defer fake.batchExecuteStatementMutex.RUnlock()
	argsForCall := fake.batchExecuteStatementArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) BatchExecuteStatementReturns(result1 *dynamodba.BatchExecuteStatementOutput, result2 error) {
	fake.batchExecuteStatementMutex.Lock()
	defer fake.batchExecuteStatementMutex.Unlock()
	fake.BatchExecuteStatementStub = nil
	fake.batchExecuteStatementReturns = struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchExecuteStatementReturnsOnCall(i int, result1 *dynamodba.BatchExecuteStatementOutput, result2 error) {
	fake.batchExecuteStatementMutex.Lock()
	defer fake.batchExecuteStatementMutex.Unlock()
	fake.BatchExecuteStatementStub = nil
	if fake.batchExecuteStatementReturnsOnCall == nil {
		fake.batchExecuteStatementReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.BatchExecuteStatementOutput
			result2 error
		})
	}
	fake.batchExecuteStatementReturnsOnCall[i] = struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchExecuteStatementRequest(arg1 *dynamodba.BatchExecuteStatementInput) (*request.Request, *dynamodba.BatchExecuteStatementOutput) {
	fake.batchExecuteStatementRequestMutex.Lock()
	ret, specificReturn := fake.batchExecuteStatementRequestReturnsOnCall[len(fake.batchExecuteStatementRequestArgsForCall)]
	fake.batchExecuteStatementRequestArgsForCall = append(fake.batchExecuteStatementRequestArgsForCall, struct {
		arg1 *dynamodba.BatchExecuteStatementInput
	}{arg1})
	fake.recordInvocation("BatchExecuteStatementRequest", []interface{}{arg1})
	fake.batchExecuteStatementRequestMutex.Unlock()
	if fake.BatchExecuteStatementRequestStub != nil {
		return fake.BatchExecuteStatementRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchExecuteStatementRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchExecuteStatementRequestCallCount() int {
	fake.batchExecuteStatementRequestMutex.RLock()
	defer fake.batchExecuteStatementRequestMutex.RUnlock()
	return len(fake.batchExecuteStatementRequestArgsForCall)
}

func (fake *FakeDynamoDB) BatchExecuteStatementRequestCalls(stub func(*dynamodba.BatchExecuteStatementInput) (*request.Request, *dynamodba.BatchExecuteStatementOutput)) {
	fake.batchExecuteStatementRequestMutex.Lock()
	defer fake.batchExecuteStatementRequestMutex.Unlock()
	fake.BatchExecuteStatementRequestStub = stub
}

func (fake *FakeDynamoDB) BatchExecuteStatementRequestArgsForCall(i int) *dynamodba.BatchExecuteStatementInput {
	fake.batchExecuteStatementRequestMutex.RLock()
	defer fake.batchExecuteStatementRequestMutex.RUnlock()
	argsForCall := fake.batchExecuteStatementRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) BatchExecuteStatementRequestReturns(result1 *request.Request, result2 *dynamodba.BatchExecuteStatementOutput) {
	fake.batchExecuteStatementRequestMutex.Lock()
	defer fake.batchExecuteStatementRequestMutex.Unlock()
	fake.BatchExecuteStatementRequestStub = nil
	fake.batchExecuteStatementRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.BatchExecuteStatementOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchExecuteStatementRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.BatchExecuteStatementOutput) {
	fake.batchExecuteStatementRequestMutex.Lock()
	defer fake.batchExecuteStatementRequestMutex.Unlock()
	fake.BatchExecuteStatementRequestStub = nil
	if fake.batchExecuteStatementRequestReturnsOnCall == nil {
		fake.batchExecuteStatementRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.BatchExecuteStatementOutput
		})
	}
	fake.batchExecuteStatementRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.BatchExecuteStatementOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchExecuteStatementWithContext(arg1 context.Context, arg2 *dynamodba.BatchExecuteStatementInput, arg3 ...request.Option) (*dynamodba.BatchExecuteStatementOutput, error) {
	fake.batchExecuteStatementWithContextMutex.Lock()
	ret, specificReturn := fake.batchExecuteStatementWithContextReturnsOnCall[len(fake.batchExecuteStatementWithContextArgsForCall)]
	fake.batchExecuteStatementWithContextArgsForCall = append(fake.batchExecuteStatementWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.BatchExecuteStatementInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("BatchExecuteStatementWithContext", []interface{}{arg1, arg2, arg3})
	fake.batchExecuteStatementWithContextMutex.Unlock()
	if fake.BatchExecuteStatementWithContextStub != nil {
		return fake.BatchExecuteStatementWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchExecuteStatementWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchExecuteStatementWithContextCallCount() int {
	fake.batchExecuteStatementWithContextMutex.RLock()
	defer fake.batchExecuteStatementWithContextMutex.RUnlock()
	return len(fake.batchExecuteStatementWithContextArgsForCall)
}

func (fake *FakeDynamoDB) BatchExecuteStatementWithContextCalls(stub func(context.Context, *dynamodba.BatchExecuteStatementInput, ...request.Option) (*dynamodba.BatchExecuteStatementOutput, error)) {
	fake.batchExecuteStatementWithContextMutex.Lock()
	defer fake.batchExecuteStatementWithContextMutex.Unlock()
	fake.BatchExecuteStatementWithContextStub = stub
}

func (fake *FakeDynamoDB) BatchExecuteStatementWithContextArgsForCall(i int) (context.Context, *dynamodba.BatchExecuteStatementInput, []request.Option) {
	fake.batchExecuteStatementWithContextMutex.RLock()
	defer fake.batchExecuteStatementWithContextMutex.RUnlock()
	argsForCall := fake.batchExecuteStatementWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) BatchExecuteStatementWithContextReturns(result1 *dynamodba.BatchExecuteStatementOutput, result2 error) {
	fake.batchExecuteStatementWithContextMutex.Lock()
	defer fake.batchExecuteStatementWithContextMutex.Unlock()
	fake.BatchExecuteStatementWithContextStub = nil
	fake.batchExecuteStatementWithContextReturns = struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchExecuteStatementWithContextReturnsOnCall(i int, result1 *dynamodba.BatchExecuteStatementOutput, result2 error) {
	fake.batchExecuteStatementWithContextMutex.Lock()
	defer fake.batchExecuteStatementWithContextMutex.Unlock()
	fake.BatchExecuteStatementWithContextStub = nil
	if fake.batchExecuteStatementWithContextReturnsOnCall == nil {
		fake.batchExecuteStatementWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.BatchExecuteStatementOutput
			result2 error
		})
	}
	fake.batchExecuteStatementWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.BatchExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchGetItem(arg1 *dynamodba.BatchGetItemInput) (*dynamodba.BatchGetItemOutput, error) {
	fake.batchGetItemMutex.Lock()
	ret, specificReturn := fake.batchGetItemReturnsOnCall[len(fake.batchGetItemArgsForCall)]
	fake.batchGetItemArgsForCall = append(fake.batchGetItemArgsForCall, struct {
		arg1 *dynamodba.BatchGetItemInput
	}{arg1})
	fake.recordInvocation("BatchGetItem", []interface{}{arg1})
	fake.batchGetItemMutex.Unlock()
	if fake.BatchGetItemStub != nil {
		return fake.BatchGetItemStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchGetItemReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchGetItemCallCount() int {
	fake.batchGetItemMutex.RLock()
	defer fake.batchGetItemMutex.RUnlock()
	return len(fake.batchGetItemArgsForCall)
}

func (fake *FakeDynamoDB) BatchGetItemCalls(stub func(*dynamodba.BatchGetItemInput) (*dynamodba.BatchGetItemOutput, error)) {
	fake.batchGetItemMutex.Lock()
	defer fake.batchGetItemMutex.Unlock()
	fake.BatchGetItemStub = stub
}

func (fake *FakeDynamoDB) BatchGetItemArgsForCall(i int) *dynamodba.BatchGetItemInput {
	fake.batchGetItemMutex.RLock()
	defer fake.batchGetItemMutex.RUnlock()
	argsForCall := fake.batchGetItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) BatchGetItemReturns(result1 *dynamodba.BatchGetItemOutput, result2 error) {
	fake.batchGetItemMutex.Lock()
	defer fake.batchGetItemMutex.Unlock()
	fake.BatchGetItemStub = nil
	fake.batchGetItemReturns = struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchGetItemReturnsOnCall(i int, result1 *dynamodba.BatchGetItemOutput, result2 error) {
	fake.batchGetItemMutex.Lock()
	defer fake.batchGetItemMutex.Unlock()
	fake.BatchGetItemStub = nil
	if fake.batchGetItemReturnsOnCall == nil {
		fake.batchGetItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.BatchGetItemOutput
			result2 error
		})
	}
	fake.batchGetItemReturnsOnCall[i] = struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchGetItemPages(arg1 *dynamodba.BatchGetItemInput, arg2 func(*dynamodba.BatchGetItemOutput, bool) bool) error {
	fake.batchGetItemPagesMutex.Lock()
	ret, specificReturn := fake.batchGetItemPagesReturnsOnCall[len(fake.batchGetItemPagesArgsForCall)]
	fake.batchGetItemPagesArgsForCall = append(fake.batchGetItemPagesArgsForCall, struct {
		arg1 *dynamodba.BatchGetItemInput
		arg2 func(*dynamodba.BatchGetItemOutput, bool) bool
	}{arg1, arg2})
	fake.recordInvocation("BatchGetItemPages", []interface{}{arg1, arg2})
	fake.batchGetItemPagesMutex.Unlock()
	if fake.BatchGetItemPagesStub != nil {
		return fake.BatchGetItemPagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.batchGetItemPagesReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) BatchGetItemPagesCallCount() int {
	fake.batchGetItemPagesMutex.RLock()
	defer fake.batchGetItemPagesMutex.RUnlock()
	return len(fake.batchGetItemPagesArgsForCall)
}

func (fake *FakeDynamoDB) BatchGetItemPagesCalls(stub func(*dynamodba.BatchGetItemInput, func(*dynamodba.BatchGetItemOutput, bool) bool) error) {
	fake.batchGetItemPagesMutex.Lock()
	defer fake.batchGetItemPagesMutex.Unlock()
	fake.BatchGetItemPagesStub = stub
}

func (fake *FakeDynamoDB) BatchGetItemPagesArgsForCall(i int) (*dynamodba.BatchGetItemInput, func(*dynamodba.BatchGetItemOutput, bool) bool) {
	fake.batchGetItemPagesMutex.RLock()
	defer fake.batchGetItemPagesMutex.RUnlock()
	argsForCall := fake.batchGetItemPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDynamoDB) BatchGetItemPagesReturns(result1 error) {
	fake.batchGetItemPagesMutex.Lock()
	defer fake.batchGetItemPagesMutex.Unlock()
	fake.BatchGetItemPagesStub = nil
	fake.batchGetItemPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) BatchGetItemPagesReturnsOnCall(i int, result1 error) {
	fake.batchGetItemPagesMutex.Lock()
	defer fake.batchGetItemPagesMutex.Unlock()
	fake.BatchGetItemPagesStub = nil
	if fake.batchGetItemPagesReturnsOnCall == nil {
		fake.batchGetItemPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.batchGetItemPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) BatchGetItemPagesWithContext(arg1 context.Context, arg2 *dynamodba.BatchGetItemInput, arg3 func(*dynamodba.BatchGetItemOutput, bool) bool, arg4 ...request.Option) error {
	fake.batchGetItemPagesWithContextMutex.Lock()
	ret, specificReturn := fake.batchGetItemPagesWithContextReturnsOnCall[len(fake.batchGetItemPagesWithContextArgsForCall)]
	fake.batchGetItemPagesWithContextArgsForCall = append(fake.batchGetItemPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.BatchGetItemInput
		arg3 func(*dynamodba.BatchGetItemOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("BatchGetItemPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.batchGetItemPagesWithContextMutex.Unlock()
	if fake.BatchGetItemPagesWithContextStub != nil {
		return fake.BatchGetItemPagesWithContextStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.batchGetItemPagesWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) BatchGetItemPagesWithContextCallCount() int {
	fake.batchGetItemPagesWithContextMutex.RLock()
	defer fake.batchGetItemPagesWithContextMutex.RUnlock()
	return len(fake.batchGetItemPagesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) BatchGetItemPagesWithContextCalls(stub func(context.Context, *dynamodba.BatchGetItemInput, func(*dynamodba.BatchGetItemOutput, bool) bool, ...request.Option) error) {
	fake.batchGetItemPagesWithContextMutex.Lock()
	defer fake.batchGetItemPagesWithContextMutex.Unlock()
	fake.BatchGetItemPagesWithContextStub = stub
}

func (fake *FakeDynamoDB) BatchGetItemPagesWithContextArgsForCall(i int) (context.Context, *dynamodba.BatchGetItemInput, func(*dynamodba.BatchGetItemOutput, bool) bool, []request.Option) {
	fake.batchGetItemPagesWithContextMutex.RLock()
	defer fake.batchGetItemPagesWithContextMutex.RUnlock()
	argsForCall := fake.batchGetItemPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDynamoDB) BatchGetItemPagesWithContextReturns(result1 error) {
	fake.batchGetItemPagesWithContextMutex.Lock()
	defer fake.batchGetItemPagesWithContextMutex.Unlock()
	fake.BatchGetItemPagesWithContextStub = nil
	fake.batchGetItemPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) BatchGetItemPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.batchGetItemPagesWithContextMutex.Lock()
	defer fake.batchGetItemPagesWithContextMutex.Unlock()
	fake.BatchGetItemPagesWithContextStub = nil
	if fake.batchGetItemPagesWithContextReturnsOnCall == nil {
		fake.batchGetItemPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.batchGetItemPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) BatchGetItemRequest(arg1 *dynamodba.BatchGetItemInput) (*request.Request, *dynamodba.BatchGetItemOutput) {
	fake.batchGetItemRequestMutex.Lock()
	ret, specificReturn := fake.batchGetItemRequestReturnsOnCall[len(fake.batchGetItemRequestArgsForCall)]
	fake.batchGetItemRequestArgsForCall = append(fake.batchGetItemRequestArgsForCall, struct {
		arg1 *dynamodba.BatchGetItemInput
	}{arg1})
	fake.recordInvocation("BatchGetItemRequest", []interface{}{arg1})
	fake.batchGetItemRequestMutex.Unlock()
	if fake.BatchGetItemRequestStub != nil {
		return fake.BatchGetItemRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchGetItemRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchGetItemRequestCallCount() int {
	fake.batchGetItemRequestMutex.RLock()
	defer fake.batchGetItemRequestMutex.RUnlock()
	return len(fake.batchGetItemRequestArgsForCall)
}

func (fake *FakeDynamoDB) BatchGetItemRequestCalls(stub func(*dynamodba.BatchGetItemInput) (*request.Request, *dynamodba.BatchGetItemOutput)) {
	fake.batchGetItemRequestMutex.Lock()
	defer fake.batchGetItemRequestMutex.Unlock()
	fake.BatchGetItemRequestStub = stub
}

func (fake *FakeDynamoDB) BatchGetItemRequestArgsForCall(i int) *dynamodba.BatchGetItemInput {
	fake.batchGetItemRequestMutex.RLock()
	defer fake.batchGetItemRequestMutex.RUnlock()
	argsForCall := fake.batchGetItemRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) BatchGetItemRequestReturns(result1 *request.Request, result2 *dynamodba.BatchGetItemOutput) {
	fake.batchGetItemRequestMutex.Lock()
	defer fake.batchGetItemRequestMutex.Unlock()
	fake.BatchGetItemRequestStub = nil
	fake.batchGetItemRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.BatchGetItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchGetItemRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.BatchGetItemOutput) {
	fake.batchGetItemRequestMutex.Lock()
	defer fake.batchGetItemRequestMutex.Unlock()
	fake.BatchGetItemRequestStub = nil
	if fake.batchGetItemRequestReturnsOnCall == nil {
		fake.batchGetItemRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.BatchGetItemOutput
		})
	}
	fake.batchGetItemRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.BatchGetItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchGetItemWithContext(arg1 context.Context, arg2 *dynamodba.BatchGetItemInput, arg3 ...request.Option) (*dynamodba.BatchGetItemOutput, error) {
	fake.batchGetItemWithContextMutex.Lock()
	ret, specificReturn := fake.batchGetItemWithContextReturnsOnCall[len(fake.batchGetItemWithContextArgsForCall)]
	fake.batchGetItemWithContextArgsForCall = append(fake.batchGetItemWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.BatchGetItemInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("BatchGetItemWithContext", []interface{}{arg1, arg2, arg3})
	fake.batchGetItemWithContextMutex.Unlock()
	if fake.BatchGetItemWithContextStub != nil {
		return fake.BatchGetItemWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchGetItemWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchGetItemWithContextCallCount() int {
	fake.batchGetItemWithContextMutex.RLock()
	defer fake.batchGetItemWithContextMutex.RUnlock()
	return len(fake.batchGetItemWithContextArgsForCall)
}

func (fake *FakeDynamoDB) BatchGetItemWithContextCalls(stub func(context.Context, *dynamodba.BatchGetItemInput, ...request.Option) (*dynamodba.BatchGetItemOutput, error)) {
	fake.batchGetItemWithContextMutex.Lock()
	defer fake.batchGetItemWithContextMutex.Unlock()
	fake.BatchGetItemWithContextStub = stub
}

func (fake *FakeDynamoDB) BatchGetItemWithContextArgsForCall(i int) (context.Context, *dynamodba.BatchGetItemInput, []request.Option) {
	fake.batchGetItemWithContextMutex.RLock()
	defer fake.batchGetItemWithContextMutex.RUnlock()
	argsForCall := fake.batchGetItemWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) BatchGetItemWithContextReturns(result1 *dynamodba.BatchGetItemOutput, result2 error) {
	fake.batchGetItemWithContextMutex.Lock()
	defer fake.batchGetItemWithContextMutex.Unlock()
	fake.BatchGetItemWithContextStub = nil
	fake.batchGetItemWithContextReturns = struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchGetItemWithContextReturnsOnCall(i int, result1 *dynamodba.BatchGetItemOutput, result2 error) {
	fake.batchGetItemWithContextMutex.Lock()
	defer fake.batchGetItemWithContextMutex.Unlock()
	fake.BatchGetItemWithContextStub = nil
	if fake.batchGetItemWithContextReturnsOnCall == nil {
		fake.batchGetItemWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.BatchGetItemOutput
			result2 error
		})
	}
	fake.batchGetItemWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.BatchGetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchWriteItem(arg1 *dynamodba.BatchWriteItemInput) (*dynamodba.BatchWriteItemOutput, error) {
	fake.batchWriteItemMutex.Lock()
	ret, specificReturn := fake.batchWriteItemReturnsOnCall[len(fake.batchWriteItemArgsForCall)]
	fake.batchWriteItemArgsForCall = append(fake.batchWriteItemArgsForCall, struct {
		arg1 *dynamodba.BatchWriteItemInput
	}{arg1})
	fake.recordInvocation("BatchWriteItem", []interface{}{arg1})
	fake.batchWriteItemMutex.Unlock()
	if fake.BatchWriteItemStub != nil {
		return fake.BatchWriteItemStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchWriteItemReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchWriteItemCallCount() int {
	fake.batchWriteItemMutex.RLock()
	defer fake.batchWriteItemMutex.RUnlock()
	return len(fake.batchWriteItemArgsForCall)
}

func (fake *FakeDynamoDB) BatchWriteItemCalls(stub func(*dynamodba.BatchWriteItemInput) (*dynamodba.BatchWriteItemOutput, error)) {
	fake.batchWriteItemMutex.Lock()
	defer fake.batchWriteItemMutex.Unlock()
	fake.BatchWriteItemStub = stub
}

func (fake *FakeDynamoDB) BatchWriteItemArgsForCall(i int) *dynamodba.BatchWriteItemInput {
	fake.batchWriteItemMutex.RLock()
	defer fake.batchWriteItemMutex.RUnlock()
	argsForCall := fake.batchWriteItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) BatchWriteItemReturns(result1 *dynamodba.BatchWriteItemOutput, result2 error) {
	fake.batchWriteItemMutex.Lock()
	defer fake.batchWriteItemMutex.Unlock()
	fake.BatchWriteItemStub = nil
	fake.batchWriteItemReturns = struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchWriteItemReturnsOnCall(i int, result1 *dynamodba.BatchWriteItemOutput, result2 error) {
	fake.batchWriteItemMutex.Lock()
	defer fake.batchWriteItemMutex.Unlock()
	fake.BatchWriteItemStub = nil
	if fake.batchWriteItemReturnsOnCall == nil {
		fake.batchWriteItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.BatchWriteItemOutput
			result2 error
		})
	}
	fake.batchWriteItemReturnsOnCall[i] = struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchWriteItemRequest(arg1 *dynamodba.BatchWriteItemInput) (*request.Request, *dynamodba.BatchWriteItemOutput) {
	fake.batchWriteItemRequestMutex.Lock()
	ret, specificReturn := fake.batchWriteItemRequestReturnsOnCall[len(fake.batchWriteItemRequestArgsForCall)]
	fake.batchWriteItemRequestArgsForCall = append(fake.batchWriteItemRequestArgsForCall, struct {
		arg1 *dynamodba.BatchWriteItemInput
	}{arg1})
	fake.recordInvocation("BatchWriteItemRequest", []interface{}{arg1})
	fake.batchWriteItemRequestMutex.Unlock()
	if fake.BatchWriteItemRequestStub != nil {
		return fake.BatchWriteItemRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchWriteItemRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchWriteItemRequestCallCount() int {
	fake.batchWriteItemRequestMutex.RLock()
	defer fake.batchWriteItemRequestMutex.RUnlock()
	return len(fake.batchWriteItemRequestArgsForCall)
}

func (fake *FakeDynamoDB) BatchWriteItemRequestCalls(stub func(*dynamodba.BatchWriteItemInput) (*request.Request, *dynamodba.BatchWriteItemOutput)) {
	fake.batchWriteItemRequestMutex.Lock()
	defer fake.batchWriteItemRequestMutex.Unlock()
	fake.BatchWriteItemRequestStub = stub
}

func (fake *FakeDynamoDB) BatchWriteItemRequestArgsForCall(i int) *dynamodba.BatchWriteItemInput {
	fake.batchWriteItemRequestMutex.RLock()
	defer fake.batchWriteItemRequestMutex.RUnlock()
	argsForCall := fake.batchWriteItemRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) BatchWriteItemRequestReturns(result1 *request.Request, result2 *dynamodba.BatchWriteItemOutput) {
	fake.batchWriteItemRequestMutex.Lock()
	defer fake.batchWriteItemRequestMutex.Unlock()
	fake.BatchWriteItemRequestStub = nil
	fake.batchWriteItemRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.BatchWriteItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchWriteItemRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.BatchWriteItemOutput) {
	fake.batchWriteItemRequestMutex.Lock()
	defer fake.batchWriteItemRequestMutex.Unlock()
	fake.BatchWriteItemRequestStub = nil
	if fake.batchWriteItemRequestReturnsOnCall == nil {
		fake.batchWriteItemRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.BatchWriteItemOutput
		})
	}
	fake.batchWriteItemRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.BatchWriteItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchWriteItemWithContext(arg1 context.Context, arg2 *dynamodba.BatchWriteItemInput, arg3 ...request.Option) (*dynamodba.BatchWriteItemOutput, error) {
	fake.batchWriteItemWithContextMutex.Lock()
	ret, specificReturn := fake.batchWriteItemWithContextReturnsOnCall[len(fake.batchWriteItemWithContextArgsForCall)]
	fake.batchWriteItemWithContextArgsForCall = append(fake.batchWriteItemWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.BatchWriteItemInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("BatchWriteItemWithContext", []interface{}{arg1, arg2, arg3})
	fake.batchWriteItemWithContextMutex.Unlock()
	if fake.BatchWriteItemWithContextStub != nil {
		return fake.BatchWriteItemWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.batchWriteItemWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) BatchWriteItemWithContextCallCount() int {
	fake.batchWriteItemWithContextMutex.RLock()
	defer fake.batchWriteItemWithContextMutex.RUnlock()
	return len(fake.batchWriteItemWithContextArgsForCall)
}

func (fake *FakeDynamoDB) BatchWriteItemWithContextCalls(stub func(context.Context, *dynamodba.BatchWriteItemInput, ...request.Option) (*dynamodba.BatchWriteItemOutput, error)) {
	fake.batchWriteItemWithContextMutex.Lock()
	defer fake.batchWriteItemWithContextMutex.Unlock()
	fake.BatchWriteItemWithContextStub = stub
}

func (fake *FakeDynamoDB) BatchWriteItemWithContextArgsForCall(i int) (context.Context, *dynamodba.BatchWriteItemInput, []request.Option) {
	fake.batchWriteItemWithContextMutex.RLock()
	defer fake.batchWriteItemWithContextMutex.RUnlock()
	argsForCall := fake.batchWriteItemWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) BatchWriteItemWithContextReturns(result1 *dynamodba.BatchWriteItemOutput, result2 error) {
	fake.batchWriteItemWithContextMutex.Lock()
	defer fake.batchWriteItemWithContextMutex.Unlock()
	fake.BatchWriteItemWithContextStub = nil
	fake.batchWriteItemWithContextReturns = struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) BatchWriteItemWithContextReturnsOnCall(i int, result1 *dynamodba.BatchWriteItemOutput, result2 error) {
	fake.batchWriteItemWithContextMutex.Lock()
	defer fake.batchWriteItemWithContextMutex.Unlock()
	fake.BatchWriteItemWithContextStub = nil
	if fake.batchWriteItemWithContextReturnsOnCall == nil {
		fake.batchWriteItemWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.BatchWriteItemOutput
			result2 error
		})
	}
	fake.batchWriteItemWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.BatchWriteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateBackup(arg1 *dynamodba.CreateBackupInput) (*dynamodba.CreateBackupOutput, error) {
	fake.createBackupMutex.Lock()
	ret, specificReturn := fake.createBackupReturnsOnCall[len(fake.createBackupArgsForCall)]
	fake.createBackupArgsForCall = append(fake.createBackupArgsForCall, struct {
		arg1 *dynamodba.CreateBackupInput
	}{arg1})
	fake.recordInvocation("CreateBackup", []interface{}{arg1})
	fake.createBackupMutex.Unlock()
	if fake.CreateBackupStub != nil {
		return fake.CreateBackupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createBackupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateBackupCallCount() int {
	fake.createBackupMutex.RLock()
	defer fake.createBackupMutex.RUnlock()
	return len(fake.createBackupArgsForCall)
}

func (fake *FakeDynamoDB) CreateBackupCalls(stub func(*dynamodba.CreateBackupInput) (*dynamodba.CreateBackupOutput, error)) {
	fake.createBackupMutex.Lock()
	defer fake.createBackupMutex.Unlock()
	fake.CreateBackupStub = stub
}

func (fake *FakeDynamoDB) CreateBackupArgsForCall(i int) *dynamodba.CreateBackupInput {
	fake.createBackupMutex.RLock()
	defer fake.createBackupMutex.RUnlock()
	argsForCall := fake.createBackupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) CreateBackupReturns(result1 *dynamodba.CreateBackupOutput, result2 error) {
	fake.createBackupMutex.Lock()
	defer fake.createBackupMutex.Unlock()
	fake.CreateBackupStub = nil
	fake.createBackupReturns = struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateBackupReturnsOnCall(i int, result1 *dynamodba.CreateBackupOutput, result2 error) {
	fake.createBackupMutex.Lock()
	defer fake.createBackupMutex.Unlock()
	fake.CreateBackupStub = nil
	if fake.createBackupReturnsOnCall == nil {
		fake.createBackupReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.CreateBackupOutput
			result2 error
		})
	}
	fake.createBackupReturnsOnCall[i] = struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateBackupRequest(arg1 *dynamodba.CreateBackupInput) (*request.Request, *dynamodba.CreateBackupOutput) {
	fake.createBackupRequestMutex.Lock()
	ret, specificReturn := fake.createBackupRequestReturnsOnCall[len(fake.createBackupRequestArgsForCall)]
	fake.createBackupRequestArgsForCall = append(fake.createBackupRequestArgsForCall, struct {
		arg1 *dynamodba.CreateBackupInput
	}{arg1})
	fake.recordInvocation("CreateBackupRequest", []interface{}{arg1})
	fake.createBackupRequestMutex.Unlock()
	if fake.CreateBackupRequestStub != nil {
		return fake.CreateBackupRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createBackupRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateBackupRequestCallCount() int {
	fake.createBackupRequestMutex.RLock()
	defer fake.createBackupRequestMutex.RUnlock()
	return len(fake.createBackupRequestArgsForCall)
}

func (fake *FakeDynamoDB) CreateBackupRequestCalls(stub func(*dynamodba.CreateBackupInput) (*request.Request, *dynamodba.CreateBackupOutput)) {
	fake.createBackupRequestMutex.Lock()
	defer fake.createBackupRequestMutex.Unlock()
	fake.CreateBackupRequestStub = stub
}

func (fake *FakeDynamoDB) CreateBackupRequestArgsForCall(i int) *dynamodba.CreateBackupInput {
	fake.createBackupRequestMutex.RLock()
	defer fake.createBackupRequestMutex.RUnlock()
	argsForCall := fake.createBackupRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) CreateBackupRequestReturns(result1 *request.Request, result2 *dynamodba.CreateBackupOutput) {
	fake.createBackupRequestMutex.Lock()
	defer fake.createBackupRequestMutex.Unlock()
	fake.CreateBackupRequestStub = nil
	fake.createBackupRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.CreateBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateBackupRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.CreateBackupOutput) {
	fake.createBackupRequestMutex.Lock()
	defer fake.createBackupRequestMutex.Unlock()
	fake.CreateBackupRequestStub = nil
	if fake.createBackupRequestReturnsOnCall == nil {
		fake.createBackupRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.CreateBackupOutput
		})
	}
	fake.createBackupRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.CreateBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateBackupWithContext(arg1 context.Context, arg2 *dynamodba.CreateBackupInput, arg3 ...request.Option) (*dynamodba.CreateBackupOutput, error) {
	fake.createBackupWithContextMutex.Lock()
	ret, specificReturn := fake.createBackupWithContextReturnsOnCall[len(fake.createBackupWithContextArgsForCall)]
	fake.createBackupWithContextArgsForCall = append(fake.createBackupWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.CreateBackupInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateBackupWithContext", []interface{}{arg1, arg2, arg3})
	fake.createBackupWithContextMutex.Unlock()
	if fake.CreateBackupWithContextStub != nil {
		return fake.CreateBackupWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createBackupWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateBackupWithContextCallCount() int {
	fake.createBackupWithContextMutex.RLock()
	defer fake.createBackupWithContextMutex.RUnlock()
	return len(fake.createBackupWithContextArgsForCall)
}

func (fake *FakeDynamoDB) CreateBackupWithContextCalls(stub func(context.Context, *dynamodba.CreateBackupInput, ...request.Option) (*dynamodba.CreateBackupOutput, error)) {
	fake.createBackupWithContextMutex.Lock()
	defer fake.createBackupWithContextMutex.Unlock()
	fake.CreateBackupWithContextStub = stub
}

func (fake *FakeDynamoDB) CreateBackupWithContextArgsForCall(i int) (context.Context, *dynamodba.CreateBackupInput, []request.Option) {
	fake.createBackupWithContextMutex.RLock()
	defer fake.createBackupWithContextMutex.RUnlock()
	argsForCall := fake.createBackupWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) CreateBackupWithContextReturns(result1 *dynamodba.CreateBackupOutput, result2 error) {
	fake.createBackupWithContextMutex.Lock()
	defer fake.createBackupWithContextMutex.Unlock()
	fake.CreateBackupWithContextStub = nil
	fake.createBackupWithContextReturns = struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateBackupWithContextReturnsOnCall(i int, result1 *dynamodba.CreateBackupOutput, result2 error) {
	fake.createBackupWithContextMutex.Lock()
	defer fake.createBackupWithContextMutex.Unlock()
	fake.CreateBackupWithContextStub = nil
	if fake.createBackupWithContextReturnsOnCall == nil {
		fake.createBackupWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.CreateBackupOutput
			result2 error
		})
	}
	fake.createBackupWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.CreateBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateGlobalTable(arg1 *dynamodba.CreateGlobalTableInput) (*dynamodba.CreateGlobalTableOutput, error) {
	fake.createGlobalTableMutex.Lock()
	ret, specificReturn := fake.createGlobalTableReturnsOnCall[len(fake.createGlobalTableArgsForCall)]
	fake.createGlobalTableArgsForCall = append(fake.createGlobalTableArgsForCall, struct {
		arg1 *dynamodba.CreateGlobalTableInput
	}{arg1})
	fake.recordInvocation("CreateGlobalTable", []interface{}{arg1})
	fake.createGlobalTableMutex.Unlock()
	if fake.CreateGlobalTableStub != nil {
		return fake.CreateGlobalTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createGlobalTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateGlobalTableCallCount() int {
	fake.createGlobalTableMutex.RLock()
	defer fake.createGlobalTableMutex.RUnlock()
	return len(fake.createGlobalTableArgsForCall)
}

func (fake *FakeDynamoDB) CreateGlobalTableCalls(stub func(*dynamodba.CreateGlobalTableInput) (*dynamodba.CreateGlobalTableOutput, error)) {
	fake.createGlobalTableMutex.Lock()
	defer fake.createGlobalTableMutex.Unlock()
	fake.CreateGlobalTableStub = stub
}

func (fake *FakeDynamoDB) CreateGlobalTableArgsForCall(i int) *dynamodba.CreateGlobalTableInput {
	fake.createGlobalTableMutex.RLock()
	defer fake.createGlobalTableMutex.RUnlock()
	argsForCall := fake.createGlobalTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) CreateGlobalTableReturns(result1 *dynamodba.CreateGlobalTableOutput, result2 error) {
	fake.createGlobalTableMutex.Lock()
	defer fake.createGlobalTableMutex.Unlock()
	fake.CreateGlobalTableStub = nil
	fake.createGlobalTableReturns = struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateGlobalTableReturnsOnCall(i int, result1 *dynamodba.CreateGlobalTableOutput, result2 error) {
	fake.createGlobalTableMutex.Lock()
	defer fake.createGlobalTableMutex.Unlock()
	fake.CreateGlobalTableStub = nil
	if fake.createGlobalTableReturnsOnCall == nil {
		fake.createGlobalTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.CreateGlobalTableOutput
			result2 error
		})
	}
	fake.createGlobalTableReturnsOnCall[i] = struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateGlobalTableRequest(arg1 *dynamodba.CreateGlobalTableInput) (*request.Request, *dynamodba.CreateGlobalTableOutput) {
	fake.createGlobalTableRequestMutex.Lock()
	ret, specificReturn := fake.createGlobalTableRequestReturnsOnCall[len(fake.createGlobalTableRequestArgsForCall)]
	fake.createGlobalTableRequestArgsForCall = append(fake.createGlobalTableRequestArgsForCall, struct {
		arg1 *dynamodba.CreateGlobalTableInput
	}{arg1})
	fake.recordInvocation("CreateGlobalTableRequest", []interface{}{arg1})
	fake.createGlobalTableRequestMutex.Unlock()
	if fake.CreateGlobalTableRequestStub != nil {
		return fake.CreateGlobalTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createGlobalTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateGlobalTableRequestCallCount() int {
	fake.createGlobalTableRequestMutex.RLock()
	defer fake.createGlobalTableRequestMutex.RUnlock()
	return len(fake.createGlobalTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) CreateGlobalTableRequestCalls(stub func(*dynamodba.CreateGlobalTableInput) (*request.Request, *dynamodba.CreateGlobalTableOutput)) {
	fake.createGlobalTableRequestMutex.Lock()
	defer fake.createGlobalTableRequestMutex.Unlock()
	fake.CreateGlobalTableRequestStub = stub
}

func (fake *FakeDynamoDB) CreateGlobalTableRequestArgsForCall(i int) *dynamodba.CreateGlobalTableInput {
	fake.createGlobalTableRequestMutex.RLock()
	defer fake.createGlobalTableRequestMutex.RUnlock()
	argsForCall := fake.createGlobalTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) CreateGlobalTableRequestReturns(result1 *request.Request, result2 *dynamodba.CreateGlobalTableOutput) {
	fake.createGlobalTableRequestMutex.Lock()
	defer fake.createGlobalTableRequestMutex.Unlock()
	fake.CreateGlobalTableRequestStub = nil
	fake.createGlobalTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.CreateGlobalTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateGlobalTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.CreateGlobalTableOutput) {
	fake.createGlobalTableRequestMutex.Lock()
	defer fake.createGlobalTableRequestMutex.Unlock()
	fake.CreateGlobalTableRequestStub = nil
	if fake.createGlobalTableRequestReturnsOnCall == nil {
		fake.createGlobalTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.CreateGlobalTableOutput
		})
	}
	fake.createGlobalTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.CreateGlobalTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateGlobalTableWithContext(arg1 context.Context, arg2 *dynamodba.CreateGlobalTableInput, arg3 ...request.Option) (*dynamodba.CreateGlobalTableOutput, error) {
	fake.createGlobalTableWithContextMutex.Lock()
	ret, specificReturn := fake.createGlobalTableWithContextReturnsOnCall[len(fake.createGlobalTableWithContextArgsForCall)]
	fake.createGlobalTableWithContextArgsForCall = append(fake.createGlobalTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.CreateGlobalTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateGlobalTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.createGlobalTableWithContextMutex.Unlock()
	if fake.CreateGlobalTableWithContextStub != nil {
		return fake.CreateGlobalTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createGlobalTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateGlobalTableWithContextCallCount() int {
	fake.createGlobalTableWithContextMutex.RLock()
	defer fake.createGlobalTableWithContextMutex.RUnlock()
	return len(fake.createGlobalTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) CreateGlobalTableWithContextCalls(stub func(context.Context, *dynamodba.CreateGlobalTableInput, ...request.Option) (*dynamodba.CreateGlobalTableOutput, error)) {
	fake.createGlobalTableWithContextMutex.Lock()
	defer fake.createGlobalTableWithContextMutex.Unlock()
	fake.CreateGlobalTableWithContextStub = stub
}

func (fake *FakeDynamoDB) CreateGlobalTableWithContextArgsForCall(i int) (context.Context, *dynamodba.CreateGlobalTableInput, []request.Option) {
	fake.createGlobalTableWithContextMutex.RLock()
	defer fake.createGlobalTableWithContextMutex.RUnlock()
	argsForCall := fake.createGlobalTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) CreateGlobalTableWithContextReturns(result1 *dynamodba.CreateGlobalTableOutput, result2 error) {
	fake.createGlobalTableWithContextMutex.Lock()
	defer fake.createGlobalTableWithContextMutex.Unlock()
	fake.CreateGlobalTableWithContextStub = nil
	fake.createGlobalTableWithContextReturns = struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateGlobalTableWithContextReturnsOnCall(i int, result1 *dynamodba.CreateGlobalTableOutput, result2 error) {
	fake.createGlobalTableWithContextMutex.Lock()
	defer fake.createGlobalTableWithContextMutex.Unlock()
	fake.CreateGlobalTableWithContextStub = nil
	if fake.createGlobalTableWithContextReturnsOnCall == nil {
		fake.createGlobalTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.CreateGlobalTableOutput
			result2 error
		})
	}
	fake.createGlobalTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.CreateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateTable(arg1 *dynamodba.CreateTableInput) (*dynamodba.CreateTableOutput, error) {
	fake.createTableMutex.Lock()
	ret, specificReturn := fake.createTableReturnsOnCall[len(fake.createTableArgsForCall)]
	fake.createTableArgsForCall = append(fake.createTableArgsForCall, struct {
		arg1 *dynamodba.CreateTableInput
	}{arg1})
	fake.recordInvocation("CreateTable", []interface{}{arg1})
	fake.createTableMutex.Unlock()
	if fake.CreateTableStub != nil {
		return fake.CreateTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateTableCallCount() int {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	return len(fake.createTableArgsForCall)
}

func (fake *FakeDynamoDB) CreateTableCalls(stub func(*dynamodba.CreateTableInput) (*dynamodba.CreateTableOutput, error)) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = stub
}

func (fake *FakeDynamoDB) CreateTableArgsForCall(i int) *dynamodba.CreateTableInput {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	argsForCall := fake.createTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) CreateTableReturns(result1 *dynamodba.CreateTableOutput, result2 error) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = nil
	fake.createTableReturns = struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateTableReturnsOnCall(i int, result1 *dynamodba.CreateTableOutput, result2 error) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = nil
	if fake.createTableReturnsOnCall == nil {
		fake.createTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.CreateTableOutput
			result2 error
		})
	}
	fake.createTableReturnsOnCall[i] = struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateTableRequest(arg1 *dynamodba.CreateTableInput) (*request.Request, *dynamodba.CreateTableOutput) {
	fake.createTableRequestMutex.Lock()
	ret, specificReturn := fake.createTableRequestReturnsOnCall[len(fake.createTableRequestArgsForCall)]
	fake.createTableRequestArgsForCall = append(fake.createTableRequestArgsForCall, struct {
		arg1 *dynamodba.CreateTableInput
	}{arg1})
	fake.recordInvocation("CreateTableRequest", []interface{}{arg1})
	fake.createTableRequestMutex.Unlock()
	if fake.CreateTableRequestStub != nil {
		return fake.CreateTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateTableRequestCallCount() int {
	fake.createTableRequestMutex.RLock()
	defer fake.createTableRequestMutex.RUnlock()
	return len(fake.createTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) CreateTableRequestCalls(stub func(*dynamodba.CreateTableInput) (*request.Request, *dynamodba.CreateTableOutput)) {
	fake.createTableRequestMutex.Lock()
	defer fake.createTableRequestMutex.Unlock()
	fake.CreateTableRequestStub = stub
}

func (fake *FakeDynamoDB) CreateTableRequestArgsForCall(i int) *dynamodba.CreateTableInput {
	fake.createTableRequestMutex.RLock()
	defer fake.createTableRequestMutex.RUnlock()
	argsForCall := fake.createTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) CreateTableRequestReturns(result1 *request.Request, result2 *dynamodba.CreateTableOutput) {
	fake.createTableRequestMutex.Lock()
	defer fake.createTableRequestMutex.Unlock()
	fake.CreateTableRequestStub = nil
	fake.createTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.CreateTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.CreateTableOutput) {
	fake.createTableRequestMutex.Lock()
	defer fake.createTableRequestMutex.Unlock()
	fake.CreateTableRequestStub = nil
	if fake.createTableRequestReturnsOnCall == nil {
		fake.createTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.CreateTableOutput
		})
	}
	fake.createTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.CreateTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateTableWithContext(arg1 context.Context, arg2 *dynamodba.CreateTableInput, arg3 ...request.Option) (*dynamodba.CreateTableOutput, error) {
	fake.createTableWithContextMutex.Lock()
	ret, specificReturn := fake.createTableWithContextReturnsOnCall[len(fake.createTableWithContextArgsForCall)]
	fake.createTableWithContextArgsForCall = append(fake.createTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.CreateTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.createTableWithContextMutex.Unlock()
	if fake.CreateTableWithContextStub != nil {
		return fake.CreateTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) CreateTableWithContextCallCount() int {
	fake.createTableWithContextMutex.RLock()
	defer fake.createTableWithContextMutex.RUnlock()
	return len(fake.createTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) CreateTableWithContextCalls(stub func(context.Context, *dynamodba.CreateTableInput, ...request.Option) (*dynamodba.CreateTableOutput, error)) {
	fake.createTableWithContextMutex.Lock()
	defer fake.createTableWithContextMutex.Unlock()
	fake.CreateTableWithContextStub = stub
}

func (fake *FakeDynamoDB) CreateTableWithContextArgsForCall(i int) (context.Context, *dynamodba.CreateTableInput, []request.Option) {
	fake.createTableWithContextMutex.RLock()
	defer fake.createTableWithContextMutex.RUnlock()
	argsForCall := fake.createTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) CreateTableWithContextReturns(result1 *dynamodba.CreateTableOutput, result2 error) {
	fake.createTableWithContextMutex.Lock()
	defer fake.createTableWithContextMutex.Unlock()
	fake.CreateTableWithContextStub = nil
	fake.createTableWithContextReturns = struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) CreateTableWithContextReturnsOnCall(i int, result1 *dynamodba.CreateTableOutput, result2 error) {
	fake.createTableWithContextMutex.Lock()
	defer fake.createTableWithContextMutex.Unlock()
	fake.CreateTableWithContextStub = nil
	if fake.createTableWithContextReturnsOnCall == nil {
		fake.createTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.CreateTableOutput
			result2 error
		})
	}
	fake.createTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.CreateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteBackup(arg1 *dynamodba.DeleteBackupInput) (*dynamodba.DeleteBackupOutput, error) {
	fake.deleteBackupMutex.Lock()
	ret, specificReturn := fake.deleteBackupReturnsOnCall[len(fake.deleteBackupArgsForCall)]
	fake.deleteBackupArgsForCall = append(fake.deleteBackupArgsForCall, struct {
		arg1 *dynamodba.DeleteBackupInput
	}{arg1})
	fake.recordInvocation("DeleteBackup", []interface{}{arg1})
	fake.deleteBackupMutex.Unlock()
	if fake.DeleteBackupStub != nil {
		return fake.DeleteBackupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteBackupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteBackupCallCount() int {
	fake.deleteBackupMutex.RLock()
	defer fake.deleteBackupMutex.RUnlock()
	return len(fake.deleteBackupArgsForCall)
}

func (fake *FakeDynamoDB) DeleteBackupCalls(stub func(*dynamodba.DeleteBackupInput) (*dynamodba.DeleteBackupOutput, error)) {
	fake.deleteBackupMutex.Lock()
	defer fake.deleteBackupMutex.Unlock()
	fake.DeleteBackupStub = stub
}

func (fake *FakeDynamoDB) DeleteBackupArgsForCall(i int) *dynamodba.DeleteBackupInput {
	fake.deleteBackupMutex.RLock()
	defer fake.deleteBackupMutex.RUnlock()
	argsForCall := fake.deleteBackupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DeleteBackupReturns(result1 *dynamodba.DeleteBackupOutput, result2 error) {
	fake.deleteBackupMutex.Lock()
	defer fake.deleteBackupMutex.Unlock()
	fake.DeleteBackupStub = nil
	fake.deleteBackupReturns = struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteBackupReturnsOnCall(i int, result1 *dynamodba.DeleteBackupOutput, result2 error) {
	fake.deleteBackupMutex.Lock()
	defer fake.deleteBackupMutex.Unlock()
	fake.DeleteBackupStub = nil
	if fake.deleteBackupReturnsOnCall == nil {
		fake.deleteBackupReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DeleteBackupOutput
			result2 error
		})
	}
	fake.deleteBackupReturnsOnCall[i] = struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteBackupRequest(arg1 *dynamodba.DeleteBackupInput) (*request.Request, *dynamodba.DeleteBackupOutput) {
	fake.deleteBackupRequestMutex.Lock()
	ret, specificReturn := fake.deleteBackupRequestReturnsOnCall[len(fake.deleteBackupRequestArgsForCall)]
	fake.deleteBackupRequestArgsForCall = append(fake.deleteBackupRequestArgsForCall, struct {
		arg1 *dynamodba.DeleteBackupInput
	}{arg1})
	fake.recordInvocation("DeleteBackupRequest", []interface{}{arg1})
	fake.deleteBackupRequestMutex.Unlock()
	if fake.DeleteBackupRequestStub != nil {
		return fake.DeleteBackupRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteBackupRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteBackupRequestCallCount() int {
	fake.deleteBackupRequestMutex.RLock()
	defer fake.deleteBackupRequestMutex.RUnlock()
	return len(fake.deleteBackupRequestArgsForCall)
}

func (fake *FakeDynamoDB) DeleteBackupRequestCalls(stub func(*dynamodba.DeleteBackupInput) (*request.Request, *dynamodba.DeleteBackupOutput)) {
	fake.deleteBackupRequestMutex.Lock()
	defer fake.deleteBackupRequestMutex.Unlock()
	fake.DeleteBackupRequestStub = stub
}

func (fake *FakeDynamoDB) DeleteBackupRequestArgsForCall(i int) *dynamodba.DeleteBackupInput {
	fake.deleteBackupRequestMutex.RLock()
	defer fake.deleteBackupRequestMutex.RUnlock()
	argsForCall := fake.deleteBackupRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DeleteBackupRequestReturns(result1 *request.Request, result2 *dynamodba.DeleteBackupOutput) {
	fake.deleteBackupRequestMutex.Lock()
	defer fake.deleteBackupRequestMutex.Unlock()
	fake.DeleteBackupRequestStub = nil
	fake.deleteBackupRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DeleteBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteBackupRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DeleteBackupOutput) {
	fake.deleteBackupRequestMutex.Lock()
	defer fake.deleteBackupRequestMutex.Unlock()
	fake.DeleteBackupRequestStub = nil
	if fake.deleteBackupRequestReturnsOnCall == nil {
		fake.deleteBackupRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DeleteBackupOutput
		})
	}
	fake.deleteBackupRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DeleteBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteBackupWithContext(arg1 context.Context, arg2 *dynamodba.DeleteBackupInput, arg3 ...request.Option) (*dynamodba.DeleteBackupOutput, error) {
	fake.deleteBackupWithContextMutex.Lock()
	ret, specificReturn := fake.deleteBackupWithContextReturnsOnCall[len(fake.deleteBackupWithContextArgsForCall)]
	fake.deleteBackupWithContextArgsForCall = append(fake.deleteBackupWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DeleteBackupInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteBackupWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteBackupWithContextMutex.Unlock()
	if fake.DeleteBackupWithContextStub != nil {
		return fake.DeleteBackupWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteBackupWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteBackupWithContextCallCount() int {
	fake.deleteBackupWithContextMutex.RLock()
	defer fake.deleteBackupWithContextMutex.RUnlock()
	return len(fake.deleteBackupWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DeleteBackupWithContextCalls(stub func(context.Context, *dynamodba.DeleteBackupInput, ...request.Option) (*dynamodba.DeleteBackupOutput, error)) {
	fake.deleteBackupWithContextMutex.Lock()
	defer fake.deleteBackupWithContextMutex.Unlock()
	fake.DeleteBackupWithContextStub = stub
}

func (fake *FakeDynamoDB) DeleteBackupWithContextArgsForCall(i int) (context.Context, *dynamodba.DeleteBackupInput, []request.Option) {
	fake.deleteBackupWithContextMutex.RLock()
	defer fake.deleteBackupWithContextMutex.RUnlock()
	argsForCall := fake.deleteBackupWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DeleteBackupWithContextReturns(result1 *dynamodba.DeleteBackupOutput, result2 error) {
	fake.deleteBackupWithContextMutex.Lock()
	defer fake.deleteBackupWithContextMutex.Unlock()
	fake.DeleteBackupWithContextStub = nil
	fake.deleteBackupWithContextReturns = struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteBackupWithContextReturnsOnCall(i int, result1 *dynamodba.DeleteBackupOutput, result2 error) {
	fake.deleteBackupWithContextMutex.Lock()
	defer fake.deleteBackupWithContextMutex.Unlock()
	fake.DeleteBackupWithContextStub = nil
	if fake.deleteBackupWithContextReturnsOnCall == nil {
		fake.deleteBackupWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DeleteBackupOutput
			result2 error
		})
	}
	fake.deleteBackupWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DeleteBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteItem(arg1 *dynamodba.DeleteItemInput) (*dynamodba.DeleteItemOutput, error) {
	fake.deleteItemMutex.Lock()
	ret, specificReturn := fake.deleteItemReturnsOnCall[len(fake.deleteItemArgsForCall)]
	fake.deleteItemArgsForCall = append(fake.deleteItemArgsForCall, struct {
		arg1 *dynamodba.DeleteItemInput
	}{arg1})
	fake.recordInvocation("DeleteItem", []interface{}{arg1})
	fake.deleteItemMutex.Unlock()
	if fake.DeleteItemStub != nil {
		return fake.DeleteItemStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteItemReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteItemCallCount() int {
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	return len(fake.deleteItemArgsForCall)
}

func (fake *FakeDynamoDB) DeleteItemCalls(stub func(*dynamodba.DeleteItemInput) (*dynamodba.DeleteItemOutput, error)) {
	fake.deleteItemMutex.Lock()
	defer fake.deleteItemMutex.Unlock()
	fake.DeleteItemStub = stub
}

func (fake *FakeDynamoDB) DeleteItemArgsForCall(i int) *dynamodba.DeleteItemInput {
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	argsForCall := fake.deleteItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DeleteItemReturns(result1 *dynamodba.DeleteItemOutput, result2 error) {
	fake.deleteItemMutex.Lock()
	defer fake.deleteItemMutex.Unlock()
	fake.DeleteItemStub = nil
	fake.deleteItemReturns = struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteItemReturnsOnCall(i int, result1 *dynamodba.DeleteItemOutput, result2 error) {
	fake.deleteItemMutex.Lock()
	defer fake.deleteItemMutex.Unlock()
	fake.DeleteItemStub = nil
	if fake.deleteItemReturnsOnCall == nil {
		fake.deleteItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DeleteItemOutput
			result2 error
		})
	}
	fake.deleteItemReturnsOnCall[i] = struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteItemRequest(arg1 *dynamodba.DeleteItemInput) (*request.Request, *dynamodba.DeleteItemOutput) {
	fake.deleteItemRequestMutex.Lock()
	ret, specificReturn := fake.deleteItemRequestReturnsOnCall[len(fake.deleteItemRequestArgsForCall)]
	fake.deleteItemRequestArgsForCall = append(fake.deleteItemRequestArgsForCall, struct {
		arg1 *dynamodba.DeleteItemInput
	}{arg1})
	fake.recordInvocation("DeleteItemRequest", []interface{}{arg1})
	fake.deleteItemRequestMutex.Unlock()
	if fake.DeleteItemRequestStub != nil {
		return fake.DeleteItemRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteItemRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteItemRequestCallCount() int {
	fake.deleteItemRequestMutex.RLock()
	defer fake.deleteItemRequestMutex.RUnlock()
	return len(fake.deleteItemRequestArgsForCall)
}

func (fake *FakeDynamoDB) DeleteItemRequestCalls(stub func(*dynamodba.DeleteItemInput) (*request.Request, *dynamodba.DeleteItemOutput)) {
	fake.deleteItemRequestMutex.Lock()
	defer fake.deleteItemRequestMutex.Unlock()
	fake.DeleteItemRequestStub = stub
}

func (fake *FakeDynamoDB) DeleteItemRequestArgsForCall(i int) *dynamodba.DeleteItemInput {
	fake.deleteItemRequestMutex.RLock()
	defer fake.deleteItemRequestMutex.RUnlock()
	argsForCall := fake.deleteItemRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DeleteItemRequestReturns(result1 *request.Request, result2 *dynamodba.DeleteItemOutput) {
	fake.deleteItemRequestMutex.Lock()
	defer fake.deleteItemRequestMutex.Unlock()
	fake.DeleteItemRequestStub = nil
	fake.deleteItemRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DeleteItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteItemRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DeleteItemOutput) {
	fake.deleteItemRequestMutex.Lock()
	defer fake.deleteItemRequestMutex.Unlock()
	fake.DeleteItemRequestStub = nil
	if fake.deleteItemRequestReturnsOnCall == nil {
		fake.deleteItemRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DeleteItemOutput
		})
	}
	fake.deleteItemRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DeleteItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteItemWithContext(arg1 context.Context, arg2 *dynamodba.DeleteItemInput, arg3 ...request.Option) (*dynamodba.DeleteItemOutput, error) {
	fake.deleteItemWithContextMutex.Lock()
	ret, specificReturn := fake.deleteItemWithContextReturnsOnCall[len(fake.deleteItemWithContextArgsForCall)]
	fake.deleteItemWithContextArgsForCall = append(fake.deleteItemWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DeleteItemInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteItemWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteItemWithContextMutex.Unlock()
	if fake.DeleteItemWithContextStub != nil {
		return fake.DeleteItemWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteItemWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteItemWithContextCallCount() int {
	fake.deleteItemWithContextMutex.RLock()
	defer fake.deleteItemWithContextMutex.RUnlock()
	return len(fake.deleteItemWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DeleteItemWithContextCalls(stub func(context.Context, *dynamodba.DeleteItemInput, ...request.Option) (*dynamodba.DeleteItemOutput, error)) {
	fake.deleteItemWithContextMutex.Lock()
	defer fake.deleteItemWithContextMutex.Unlock()
	fake.DeleteItemWithContextStub = stub
}

func (fake *FakeDynamoDB) DeleteItemWithContextArgsForCall(i int) (context.Context, *dynamodba.DeleteItemInput, []request.Option) {
	fake.deleteItemWithContextMutex.RLock()
	defer fake.deleteItemWithContextMutex.RUnlock()
	argsForCall := fake.deleteItemWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DeleteItemWithContextReturns(result1 *dynamodba.DeleteItemOutput, result2 error) {
	fake.deleteItemWithContextMutex.Lock()
	defer fake.deleteItemWithContextMutex.Unlock()
	fake.DeleteItemWithContextStub = nil
	fake.deleteItemWithContextReturns = struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteItemWithContextReturnsOnCall(i int, result1 *dynamodba.DeleteItemOutput, result2 error) {
	fake.deleteItemWithContextMutex.Lock()
	defer fake.deleteItemWithContextMutex.Unlock()
	fake.DeleteItemWithContextStub = nil
	if fake.deleteItemWithContextReturnsOnCall == nil {
		fake.deleteItemWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DeleteItemOutput
			result2 error
		})
	}
	fake.deleteItemWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DeleteItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteTable(arg1 *dynamodba.DeleteTableInput) (*dynamodba.DeleteTableOutput, error) {
	fake.deleteTableMutex.Lock()
	ret, specificReturn := fake.deleteTableReturnsOnCall[len(fake.deleteTableArgsForCall)]
	fake.deleteTableArgsForCall = append(fake.deleteTableArgsForCall, struct {
		arg1 *dynamodba.DeleteTableInput
	}{arg1})
	fake.recordInvocation("DeleteTable", []interface{}{arg1})
	fake.deleteTableMutex.Unlock()
	if fake.DeleteTableStub != nil {
		return fake.DeleteTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteTableCallCount() int {
	fake.deleteTableMutex.RLock()
	defer fake.deleteTableMutex.RUnlock()
	return len(fake.deleteTableArgsForCall)
}

func (fake *FakeDynamoDB) DeleteTableCalls(stub func(*dynamodba.DeleteTableInput) (*dynamodba.DeleteTableOutput, error)) {
	fake.deleteTableMutex.Lock()
	defer fake.deleteTableMutex.Unlock()
	fake.DeleteTableStub = stub
}

func (fake *FakeDynamoDB) DeleteTableArgsForCall(i int) *dynamodba.DeleteTableInput {
	fake.deleteTableMutex.RLock()
	defer fake.deleteTableMutex.RUnlock()
	argsForCall := fake.deleteTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DeleteTableReturns(result1 *dynamodba.DeleteTableOutput, result2 error) {
	fake.deleteTableMutex.Lock()
	defer fake.deleteTableMutex.Unlock()
	fake.DeleteTableStub = nil
	fake.deleteTableReturns = struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteTableReturnsOnCall(i int, result1 *dynamodba.DeleteTableOutput, result2 error) {
	fake.deleteTableMutex.Lock()
	defer fake.deleteTableMutex.Unlock()
	fake.DeleteTableStub = nil
	if fake.deleteTableReturnsOnCall == nil {
		fake.deleteTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DeleteTableOutput
			result2 error
		})
	}
	fake.deleteTableReturnsOnCall[i] = struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteTableRequest(arg1 *dynamodba.DeleteTableInput) (*request.Request, *dynamodba.DeleteTableOutput) {
	fake.deleteTableRequestMutex.Lock()
	ret, specificReturn := fake.deleteTableRequestReturnsOnCall[len(fake.deleteTableRequestArgsForCall)]
	fake.deleteTableRequestArgsForCall = append(fake.deleteTableRequestArgsForCall, struct {
		arg1 *dynamodba.DeleteTableInput
	}{arg1})
	fake.recordInvocation("DeleteTableRequest", []interface{}{arg1})
	fake.deleteTableRequestMutex.Unlock()
	if fake.DeleteTableRequestStub != nil {
		return fake.DeleteTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteTableRequestCallCount() int {
	fake.deleteTableRequestMutex.RLock()
	defer fake.deleteTableRequestMutex.RUnlock()
	return len(fake.deleteTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) DeleteTableRequestCalls(stub func(*dynamodba.DeleteTableInput) (*request.Request, *dynamodba.DeleteTableOutput)) {
	fake.deleteTableRequestMutex.Lock()
	defer fake.deleteTableRequestMutex.Unlock()
	fake.DeleteTableRequestStub = stub
}

func (fake *FakeDynamoDB) DeleteTableRequestArgsForCall(i int) *dynamodba.DeleteTableInput {
	fake.deleteTableRequestMutex.RLock()
	defer fake.deleteTableRequestMutex.RUnlock()
	argsForCall := fake.deleteTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DeleteTableRequestReturns(result1 *request.Request, result2 *dynamodba.DeleteTableOutput) {
	fake.deleteTableRequestMutex.Lock()
	defer fake.deleteTableRequestMutex.Unlock()
	fake.DeleteTableRequestStub = nil
	fake.deleteTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DeleteTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DeleteTableOutput) {
	fake.deleteTableRequestMutex.Lock()
	defer fake.deleteTableRequestMutex.Unlock()
	fake.DeleteTableRequestStub = nil
	if fake.deleteTableRequestReturnsOnCall == nil {
		fake.deleteTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DeleteTableOutput
		})
	}
	fake.deleteTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DeleteTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteTableWithContext(arg1 context.Context, arg2 *dynamodba.DeleteTableInput, arg3 ...request.Option) (*dynamodba.DeleteTableOutput, error) {
	fake.deleteTableWithContextMutex.Lock()
	ret, specificReturn := fake.deleteTableWithContextReturnsOnCall[len(fake.deleteTableWithContextArgsForCall)]
	fake.deleteTableWithContextArgsForCall = append(fake.deleteTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DeleteTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteTableWithContextMutex.Unlock()
	if fake.DeleteTableWithContextStub != nil {
		return fake.DeleteTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DeleteTableWithContextCallCount() int {
	fake.deleteTableWithContextMutex.RLock()
	defer fake.deleteTableWithContextMutex.RUnlock()
	return len(fake.deleteTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DeleteTableWithContextCalls(stub func(context.Context, *dynamodba.DeleteTableInput, ...request.Option) (*dynamodba.DeleteTableOutput, error)) {
	fake.deleteTableWithContextMutex.Lock()
	defer fake.deleteTableWithContextMutex.Unlock()
	fake.DeleteTableWithContextStub = stub
}

func (fake *FakeDynamoDB) DeleteTableWithContextArgsForCall(i int) (context.Context, *dynamodba.DeleteTableInput, []request.Option) {
	fake.deleteTableWithContextMutex.RLock()
	defer fake.deleteTableWithContextMutex.RUnlock()
	argsForCall := fake.deleteTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DeleteTableWithContextReturns(result1 *dynamodba.DeleteTableOutput, result2 error) {
	fake.deleteTableWithContextMutex.Lock()
	defer fake.deleteTableWithContextMutex.Unlock()
	fake.DeleteTableWithContextStub = nil
	fake.deleteTableWithContextReturns = struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DeleteTableWithContextReturnsOnCall(i int, result1 *dynamodba.DeleteTableOutput, result2 error) {
	fake.deleteTableWithContextMutex.Lock()
	defer fake.deleteTableWithContextMutex.Unlock()
	fake.DeleteTableWithContextStub = nil
	if fake.deleteTableWithContextReturnsOnCall == nil {
		fake.deleteTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DeleteTableOutput
			result2 error
		})
	}
	fake.deleteTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DeleteTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeBackup(arg1 *dynamodba.DescribeBackupInput) (*dynamodba.DescribeBackupOutput, error) {
	fake.describeBackupMutex.Lock()
	ret, specificReturn := fake.describeBackupReturnsOnCall[len(fake.describeBackupArgsForCall)]
	fake.describeBackupArgsForCall = append(fake.describeBackupArgsForCall, struct {
		arg1 *dynamodba.DescribeBackupInput
	}{arg1})
	fake.recordInvocation("DescribeBackup", []interface{}{arg1})
	fake.describeBackupMutex.Unlock()
	if fake.DescribeBackupStub != nil {
		return fake.DescribeBackupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeBackupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeBackupCallCount() int {
	fake.describeBackupMutex.RLock()
	defer fake.describeBackupMutex.RUnlock()
	return len(fake.describeBackupArgsForCall)
}

func (fake *FakeDynamoDB) DescribeBackupCalls(stub func(*dynamodba.DescribeBackupInput) (*dynamodba.DescribeBackupOutput, error)) {
	fake.describeBackupMutex.Lock()
	defer fake.describeBackupMutex.Unlock()
	fake.DescribeBackupStub = stub
}

func (fake *FakeDynamoDB) DescribeBackupArgsForCall(i int) *dynamodba.DescribeBackupInput {
	fake.describeBackupMutex.RLock()
	defer fake.describeBackupMutex.RUnlock()
	argsForCall := fake.describeBackupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeBackupReturns(result1 *dynamodba.DescribeBackupOutput, result2 error) {
	fake.describeBackupMutex.Lock()
	defer fake.describeBackupMutex.Unlock()
	fake.DescribeBackupStub = nil
	fake.describeBackupReturns = struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeBackupReturnsOnCall(i int, result1 *dynamodba.DescribeBackupOutput, result2 error) {
	fake.describeBackupMutex.Lock()
	defer fake.describeBackupMutex.Unlock()
	fake.DescribeBackupStub = nil
	if fake.describeBackupReturnsOnCall == nil {
		fake.describeBackupReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeBackupOutput
			result2 error
		})
	}
	fake.describeBackupReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeBackupRequest(arg1 *dynamodba.DescribeBackupInput) (*request.Request, *dynamodba.DescribeBackupOutput) {
	fake.describeBackupRequestMutex.Lock()
	ret, specificReturn := fake.describeBackupRequestReturnsOnCall[len(fake.describeBackupRequestArgsForCall)]
	fake.describeBackupRequestArgsForCall = append(fake.describeBackupRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeBackupInput
	}{arg1})
	fake.recordInvocation("DescribeBackupRequest", []interface{}{arg1})
	fake.describeBackupRequestMutex.Unlock()
	if fake.DescribeBackupRequestStub != nil {
		return fake.DescribeBackupRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeBackupRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeBackupRequestCallCount() int {
	fake.describeBackupRequestMutex.RLock()
	defer fake.describeBackupRequestMutex.RUnlock()
	return len(fake.describeBackupRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeBackupRequestCalls(stub func(*dynamodba.DescribeBackupInput) (*request.Request, *dynamodba.DescribeBackupOutput)) {
	fake.describeBackupRequestMutex.Lock()
	defer fake.describeBackupRequestMutex.Unlock()
	fake.DescribeBackupRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeBackupRequestArgsForCall(i int) *dynamodba.DescribeBackupInput {
	fake.describeBackupRequestMutex.RLock()
	defer fake.describeBackupRequestMutex.RUnlock()
	argsForCall := fake.describeBackupRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeBackupRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeBackupOutput) {
	fake.describeBackupRequestMutex.Lock()
	defer fake.describeBackupRequestMutex.Unlock()
	fake.DescribeBackupRequestStub = nil
	fake.describeBackupRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeBackupRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeBackupOutput) {
	fake.describeBackupRequestMutex.Lock()
	defer fake.describeBackupRequestMutex.Unlock()
	fake.DescribeBackupRequestStub = nil
	if fake.describeBackupRequestReturnsOnCall == nil {
		fake.describeBackupRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeBackupOutput
		})
	}
	fake.describeBackupRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeBackupWithContext(arg1 context.Context, arg2 *dynamodba.DescribeBackupInput, arg3 ...request.Option) (*dynamodba.DescribeBackupOutput, error) {
	fake.describeBackupWithContextMutex.Lock()
	ret, specificReturn := fake.describeBackupWithContextReturnsOnCall[len(fake.describeBackupWithContextArgsForCall)]
	fake.describeBackupWithContextArgsForCall = append(fake.describeBackupWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeBackupInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeBackupWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeBackupWithContextMutex.Unlock()
	if fake.DescribeBackupWithContextStub != nil {
		return fake.DescribeBackupWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeBackupWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeBackupWithContextCallCount() int {
	fake.describeBackupWithContextMutex.RLock()
	defer fake.describeBackupWithContextMutex.RUnlock()
	return len(fake.describeBackupWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeBackupWithContextCalls(stub func(context.Context, *dynamodba.DescribeBackupInput, ...request.Option) (*dynamodba.DescribeBackupOutput, error)) {
	fake.describeBackupWithContextMutex.Lock()
	defer fake.describeBackupWithContextMutex.Unlock()
	fake.DescribeBackupWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeBackupWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeBackupInput, []request.Option) {
	fake.describeBackupWithContextMutex.RLock()
	defer fake.describeBackupWithContextMutex.RUnlock()
	argsForCall := fake.describeBackupWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeBackupWithContextReturns(result1 *dynamodba.DescribeBackupOutput, result2 error) {
	fake.describeBackupWithContextMutex.Lock()
	defer fake.describeBackupWithContextMutex.Unlock()
	fake.DescribeBackupWithContextStub = nil
	fake.describeBackupWithContextReturns = struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeBackupWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeBackupOutput, result2 error) {
	fake.describeBackupWithContextMutex.Lock()
	defer fake.describeBackupWithContextMutex.Unlock()
	fake.DescribeBackupWithContextStub = nil
	if fake.describeBackupWithContextReturnsOnCall == nil {
		fake.describeBackupWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeBackupOutput
			result2 error
		})
	}
	fake.describeBackupWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContinuousBackups(arg1 *dynamodba.DescribeContinuousBackupsInput) (*dynamodba.DescribeContinuousBackupsOutput, error) {
	fake.describeContinuousBackupsMutex.Lock()
	ret, specificReturn := fake.describeContinuousBackupsReturnsOnCall[len(fake.describeContinuousBackupsArgsForCall)]
	fake.describeContinuousBackupsArgsForCall = append(fake.describeContinuousBackupsArgsForCall, struct {
		arg1 *dynamodba.DescribeContinuousBackupsInput
	}{arg1})
	fake.recordInvocation("DescribeContinuousBackups", []interface{}{arg1})
	fake.describeContinuousBackupsMutex.Unlock()
	if fake.DescribeContinuousBackupsStub != nil {
		return fake.DescribeContinuousBackupsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeContinuousBackupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsCallCount() int {
	fake.describeContinuousBackupsMutex.RLock()
	defer fake.describeContinuousBackupsMutex.RUnlock()
	return len(fake.describeContinuousBackupsArgsForCall)
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsCalls(stub func(*dynamodba.DescribeContinuousBackupsInput) (*dynamodba.DescribeContinuousBackupsOutput, error)) {
	fake.describeContinuousBackupsMutex.Lock()
	defer fake.describeContinuousBackupsMutex.Unlock()
	fake.DescribeContinuousBackupsStub = stub
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsArgsForCall(i int) *dynamodba.DescribeContinuousBackupsInput {
	fake.describeContinuousBackupsMutex.RLock()
	defer fake.describeContinuousBackupsMutex.RUnlock()
	argsForCall := fake.describeContinuousBackupsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsReturns(result1 *dynamodba.DescribeContinuousBackupsOutput, result2 error) {
	fake.describeContinuousBackupsMutex.Lock()
	defer fake.describeContinuousBackupsMutex.Unlock()
	fake.DescribeContinuousBackupsStub = nil
	fake.describeContinuousBackupsReturns = struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsReturnsOnCall(i int, result1 *dynamodba.DescribeContinuousBackupsOutput, result2 error) {
	fake.describeContinuousBackupsMutex.Lock()
	defer fake.describeContinuousBackupsMutex.Unlock()
	fake.DescribeContinuousBackupsStub = nil
	if fake.describeContinuousBackupsReturnsOnCall == nil {
		fake.describeContinuousBackupsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeContinuousBackupsOutput
			result2 error
		})
	}
	fake.describeContinuousBackupsReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsRequest(arg1 *dynamodba.DescribeContinuousBackupsInput) (*request.Request, *dynamodba.DescribeContinuousBackupsOutput) {
	fake.describeContinuousBackupsRequestMutex.Lock()
	ret, specificReturn := fake.describeContinuousBackupsRequestReturnsOnCall[len(fake.describeContinuousBackupsRequestArgsForCall)]
	fake.describeContinuousBackupsRequestArgsForCall = append(fake.describeContinuousBackupsRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeContinuousBackupsInput
	}{arg1})
	fake.recordInvocation("DescribeContinuousBackupsRequest", []interface{}{arg1})
	fake.describeContinuousBackupsRequestMutex.Unlock()
	if fake.DescribeContinuousBackupsRequestStub != nil {
		return fake.DescribeContinuousBackupsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeContinuousBackupsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsRequestCallCount() int {
	fake.describeContinuousBackupsRequestMutex.RLock()
	defer fake.describeContinuousBackupsRequestMutex.RUnlock()
	return len(fake.describeContinuousBackupsRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsRequestCalls(stub func(*dynamodba.DescribeContinuousBackupsInput) (*request.Request, *dynamodba.DescribeContinuousBackupsOutput)) {
	fake.describeContinuousBackupsRequestMutex.Lock()
	defer fake.describeContinuousBackupsRequestMutex.Unlock()
	fake.DescribeContinuousBackupsRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsRequestArgsForCall(i int) *dynamodba.DescribeContinuousBackupsInput {
	fake.describeContinuousBackupsRequestMutex.RLock()
	defer fake.describeContinuousBackupsRequestMutex.RUnlock()
	argsForCall := fake.describeContinuousBackupsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeContinuousBackupsOutput) {
	fake.describeContinuousBackupsRequestMutex.Lock()
	defer fake.describeContinuousBackupsRequestMutex.Unlock()
	fake.DescribeContinuousBackupsRequestStub = nil
	fake.describeContinuousBackupsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContinuousBackupsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeContinuousBackupsOutput) {
	fake.describeContinuousBackupsRequestMutex.Lock()
	defer fake.describeContinuousBackupsRequestMutex.Unlock()
	fake.DescribeContinuousBackupsRequestStub = nil
	if fake.describeContinuousBackupsRequestReturnsOnCall == nil {
		fake.describeContinuousBackupsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeContinuousBackupsOutput
		})
	}
	fake.describeContinuousBackupsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContinuousBackupsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeContinuousBackupsInput, arg3 ...request.Option) (*dynamodba.DescribeContinuousBackupsOutput, error) {
	fake.describeContinuousBackupsWithContextMutex.Lock()
	ret, specificReturn := fake.describeContinuousBackupsWithContextReturnsOnCall[len(fake.describeContinuousBackupsWithContextArgsForCall)]
	fake.describeContinuousBackupsWithContextArgsForCall = append(fake.describeContinuousBackupsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeContinuousBackupsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeContinuousBackupsWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeContinuousBackupsWithContextMutex.Unlock()
	if fake.DescribeContinuousBackupsWithContextStub != nil {
		return fake.DescribeContinuousBackupsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeContinuousBackupsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsWithContextCallCount() int {
	fake.describeContinuousBackupsWithContextMutex.RLock()
	defer fake.describeContinuousBackupsWithContextMutex.RUnlock()
	return len(fake.describeContinuousBackupsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsWithContextCalls(stub func(context.Context, *dynamodba.DescribeContinuousBackupsInput, ...request.Option) (*dynamodba.DescribeContinuousBackupsOutput, error)) {
	fake.describeContinuousBackupsWithContextMutex.Lock()
	defer fake.describeContinuousBackupsWithContextMutex.Unlock()
	fake.DescribeContinuousBackupsWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeContinuousBackupsInput, []request.Option) {
	fake.describeContinuousBackupsWithContextMutex.RLock()
	defer fake.describeContinuousBackupsWithContextMutex.RUnlock()
	argsForCall := fake.describeContinuousBackupsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsWithContextReturns(result1 *dynamodba.DescribeContinuousBackupsOutput, result2 error) {
	fake.describeContinuousBackupsWithContextMutex.Lock()
	defer fake.describeContinuousBackupsWithContextMutex.Unlock()
	fake.DescribeContinuousBackupsWithContextStub = nil
	fake.describeContinuousBackupsWithContextReturns = struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContinuousBackupsWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeContinuousBackupsOutput, result2 error) {
	fake.describeContinuousBackupsWithContextMutex.Lock()
	defer fake.describeContinuousBackupsWithContextMutex.Unlock()
	fake.DescribeContinuousBackupsWithContextStub = nil
	if fake.describeContinuousBackupsWithContextReturnsOnCall == nil {
		fake.describeContinuousBackupsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeContinuousBackupsOutput
			result2 error
		})
	}
	fake.describeContinuousBackupsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContributorInsights(arg1 *dynamodba.DescribeContributorInsightsInput) (*dynamodba.DescribeContributorInsightsOutput, error) {
	fake.describeContributorInsightsMutex.Lock()
	ret, specificReturn := fake.describeContributorInsightsReturnsOnCall[len(fake.describeContributorInsightsArgsForCall)]
	fake.describeContributorInsightsArgsForCall = append(fake.describeContributorInsightsArgsForCall, struct {
		arg1 *dynamodba.DescribeContributorInsightsInput
	}{arg1})
	fake.recordInvocation("DescribeContributorInsights", []interface{}{arg1})
	fake.describeContributorInsightsMutex.Unlock()
	if fake.DescribeContributorInsightsStub != nil {
		return fake.DescribeContributorInsightsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeContributorInsightsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeContributorInsightsCallCount() int {
	fake.describeContributorInsightsMutex.RLock()
	defer fake.describeContributorInsightsMutex.RUnlock()
	return len(fake.describeContributorInsightsArgsForCall)
}

func (fake *FakeDynamoDB) DescribeContributorInsightsCalls(stub func(*dynamodba.DescribeContributorInsightsInput) (*dynamodba.DescribeContributorInsightsOutput, error)) {
	fake.describeContributorInsightsMutex.Lock()
	defer fake.describeContributorInsightsMutex.Unlock()
	fake.DescribeContributorInsightsStub = stub
}

func (fake *FakeDynamoDB) DescribeContributorInsightsArgsForCall(i int) *dynamodba.DescribeContributorInsightsInput {
	fake.describeContributorInsightsMutex.RLock()
	defer fake.describeContributorInsightsMutex.RUnlock()
	argsForCall := fake.describeContributorInsightsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeContributorInsightsReturns(result1 *dynamodba.DescribeContributorInsightsOutput, result2 error) {
	fake.describeContributorInsightsMutex.Lock()
	defer fake.describeContributorInsightsMutex.Unlock()
	fake.DescribeContributorInsightsStub = nil
	fake.describeContributorInsightsReturns = struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContributorInsightsReturnsOnCall(i int, result1 *dynamodba.DescribeContributorInsightsOutput, result2 error) {
	fake.describeContributorInsightsMutex.Lock()
	defer fake.describeContributorInsightsMutex.Unlock()
	fake.DescribeContributorInsightsStub = nil
	if fake.describeContributorInsightsReturnsOnCall == nil {
		fake.describeContributorInsightsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeContributorInsightsOutput
			result2 error
		})
	}
	fake.describeContributorInsightsReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContributorInsightsRequest(arg1 *dynamodba.DescribeContributorInsightsInput) (*request.Request, *dynamodba.DescribeContributorInsightsOutput) {
	fake.describeContributorInsightsRequestMutex.Lock()
	ret, specificReturn := fake.describeContributorInsightsRequestReturnsOnCall[len(fake.describeContributorInsightsRequestArgsForCall)]
	fake.describeContributorInsightsRequestArgsForCall = append(fake.describeContributorInsightsRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeContributorInsightsInput
	}{arg1})
	fake.recordInvocation("DescribeContributorInsightsRequest", []interface{}{arg1})
	fake.describeContributorInsightsRequestMutex.Unlock()
	if fake.DescribeContributorInsightsRequestStub != nil {
		return fake.DescribeContributorInsightsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeContributorInsightsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeContributorInsightsRequestCallCount() int {
	fake.describeContributorInsightsRequestMutex.RLock()
	defer fake.describeContributorInsightsRequestMutex.RUnlock()
	return len(fake.describeContributorInsightsRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeContributorInsightsRequestCalls(stub func(*dynamodba.DescribeContributorInsightsInput) (*request.Request, *dynamodba.DescribeContributorInsightsOutput)) {
	fake.describeContributorInsightsRequestMutex.Lock()
	defer fake.describeContributorInsightsRequestMutex.Unlock()
	fake.DescribeContributorInsightsRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeContributorInsightsRequestArgsForCall(i int) *dynamodba.DescribeContributorInsightsInput {
	fake.describeContributorInsightsRequestMutex.RLock()
	defer fake.describeContributorInsightsRequestMutex.RUnlock()
	argsForCall := fake.describeContributorInsightsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeContributorInsightsRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeContributorInsightsOutput) {
	fake.describeContributorInsightsRequestMutex.Lock()
	defer fake.describeContributorInsightsRequestMutex.Unlock()
	fake.DescribeContributorInsightsRequestStub = nil
	fake.describeContributorInsightsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContributorInsightsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContributorInsightsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeContributorInsightsOutput) {
	fake.describeContributorInsightsRequestMutex.Lock()
	defer fake.describeContributorInsightsRequestMutex.Unlock()
	fake.DescribeContributorInsightsRequestStub = nil
	if fake.describeContributorInsightsRequestReturnsOnCall == nil {
		fake.describeContributorInsightsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeContributorInsightsOutput
		})
	}
	fake.describeContributorInsightsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeContributorInsightsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContributorInsightsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeContributorInsightsInput, arg3 ...request.Option) (*dynamodba.DescribeContributorInsightsOutput, error) {
	fake.describeContributorInsightsWithContextMutex.Lock()
	ret, specificReturn := fake.describeContributorInsightsWithContextReturnsOnCall[len(fake.describeContributorInsightsWithContextArgsForCall)]
	fake.describeContributorInsightsWithContextArgsForCall = append(fake.describeContributorInsightsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeContributorInsightsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeContributorInsightsWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeContributorInsightsWithContextMutex.Unlock()
	if fake.DescribeContributorInsightsWithContextStub != nil {
		return fake.DescribeContributorInsightsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeContributorInsightsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeContributorInsightsWithContextCallCount() int {
	fake.describeContributorInsightsWithContextMutex.RLock()
	defer fake.describeContributorInsightsWithContextMutex.RUnlock()
	return len(fake.describeContributorInsightsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeContributorInsightsWithContextCalls(stub func(context.Context, *dynamodba.DescribeContributorInsightsInput, ...request.Option) (*dynamodba.DescribeContributorInsightsOutput, error)) {
	fake.describeContributorInsightsWithContextMutex.Lock()
	defer fake.describeContributorInsightsWithContextMutex.Unlock()
	fake.DescribeContributorInsightsWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeContributorInsightsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeContributorInsightsInput, []request.Option) {
	fake.describeContributorInsightsWithContextMutex.RLock()
	defer fake.describeContributorInsightsWithContextMutex.RUnlock()
	argsForCall := fake.describeContributorInsightsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeContributorInsightsWithContextReturns(result1 *dynamodba.DescribeContributorInsightsOutput, result2 error) {
	fake.describeContributorInsightsWithContextMutex.Lock()
	defer fake.describeContributorInsightsWithContextMutex.Unlock()
	fake.DescribeContributorInsightsWithContextStub = nil
	fake.describeContributorInsightsWithContextReturns = struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeContributorInsightsWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeContributorInsightsOutput, result2 error) {
	fake.describeContributorInsightsWithContextMutex.Lock()
	defer fake.describeContributorInsightsWithContextMutex.Unlock()
	fake.DescribeContributorInsightsWithContextStub = nil
	if fake.describeContributorInsightsWithContextReturnsOnCall == nil {
		fake.describeContributorInsightsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeContributorInsightsOutput
			result2 error
		})
	}
	fake.describeContributorInsightsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeEndpoints(arg1 *dynamodba.DescribeEndpointsInput) (*dynamodba.DescribeEndpointsOutput, error) {
	fake.describeEndpointsMutex.Lock()
	ret, specificReturn := fake.describeEndpointsReturnsOnCall[len(fake.describeEndpointsArgsForCall)]
	fake.describeEndpointsArgsForCall = append(fake.describeEndpointsArgsForCall, struct {
		arg1 *dynamodba.DescribeEndpointsInput
	}{arg1})
	fake.recordInvocation("DescribeEndpoints", []interface{}{arg1})
	fake.describeEndpointsMutex.Unlock()
	if fake.DescribeEndpointsStub != nil {
		return fake.DescribeEndpointsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeEndpointsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeEndpointsCallCount() int {
	fake.describeEndpointsMutex.RLock()
	defer fake.describeEndpointsMutex.RUnlock()
	return len(fake.describeEndpointsArgsForCall)
}

func (fake *FakeDynamoDB) DescribeEndpointsCalls(stub func(*dynamodba.DescribeEndpointsInput) (*dynamodba.DescribeEndpointsOutput, error)) {
	fake.describeEndpointsMutex.Lock()
	defer fake.describeEndpointsMutex.Unlock()
	fake.DescribeEndpointsStub = stub
}

func (fake *FakeDynamoDB) DescribeEndpointsArgsForCall(i int) *dynamodba.DescribeEndpointsInput {
	fake.describeEndpointsMutex.RLock()
	defer fake.describeEndpointsMutex.RUnlock()
	argsForCall := fake.describeEndpointsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeEndpointsReturns(result1 *dynamodba.DescribeEndpointsOutput, result2 error) {
	fake.describeEndpointsMutex.Lock()
	defer fake.describeEndpointsMutex.Unlock()
	fake.DescribeEndpointsStub = nil
	fake.describeEndpointsReturns = struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeEndpointsReturnsOnCall(i int, result1 *dynamodba.DescribeEndpointsOutput, result2 error) {
	fake.describeEndpointsMutex.Lock()
	defer fake.describeEndpointsMutex.Unlock()
	fake.DescribeEndpointsStub = nil
	if fake.describeEndpointsReturnsOnCall == nil {
		fake.describeEndpointsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeEndpointsOutput
			result2 error
		})
	}
	fake.describeEndpointsReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeEndpointsRequest(arg1 *dynamodba.DescribeEndpointsInput) (*request.Request, *dynamodba.DescribeEndpointsOutput) {
	fake.describeEndpointsRequestMutex.Lock()
	ret, specificReturn := fake.describeEndpointsRequestReturnsOnCall[len(fake.describeEndpointsRequestArgsForCall)]
	fake.describeEndpointsRequestArgsForCall = append(fake.describeEndpointsRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeEndpointsInput
	}{arg1})
	fake.recordInvocation("DescribeEndpointsRequest", []interface{}{arg1})
	fake.describeEndpointsRequestMutex.Unlock()
	if fake.DescribeEndpointsRequestStub != nil {
		return fake.DescribeEndpointsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeEndpointsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeEndpointsRequestCallCount() int {
	fake.describeEndpointsRequestMutex.RLock()
	defer fake.describeEndpointsRequestMutex.RUnlock()
	return len(fake.describeEndpointsRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeEndpointsRequestCalls(stub func(*dynamodba.DescribeEndpointsInput) (*request.Request, *dynamodba.DescribeEndpointsOutput)) {
	fake.describeEndpointsRequestMutex.Lock()
	defer fake.describeEndpointsRequestMutex.Unlock()
	fake.DescribeEndpointsRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeEndpointsRequestArgsForCall(i int) *dynamodba.DescribeEndpointsInput {
	fake.describeEndpointsRequestMutex.RLock()
	defer fake.describeEndpointsRequestMutex.RUnlock()
	argsForCall := fake.describeEndpointsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeEndpointsRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeEndpointsOutput) {
	fake.describeEndpointsRequestMutex.Lock()
	defer fake.describeEndpointsRequestMutex.Unlock()
	fake.DescribeEndpointsRequestStub = nil
	fake.describeEndpointsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeEndpointsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeEndpointsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeEndpointsOutput) {
	fake.describeEndpointsRequestMutex.Lock()
	defer fake.describeEndpointsRequestMutex.Unlock()
	fake.DescribeEndpointsRequestStub = nil
	if fake.describeEndpointsRequestReturnsOnCall == nil {
		fake.describeEndpointsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeEndpointsOutput
		})
	}
	fake.describeEndpointsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeEndpointsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeEndpointsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeEndpointsInput, arg3 ...request.Option) (*dynamodba.DescribeEndpointsOutput, error) {
	fake.describeEndpointsWithContextMutex.Lock()
	ret, specificReturn := fake.describeEndpointsWithContextReturnsOnCall[len(fake.describeEndpointsWithContextArgsForCall)]
	fake.describeEndpointsWithContextArgsForCall = append(fake.describeEndpointsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeEndpointsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeEndpointsWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeEndpointsWithContextMutex.Unlock()
	if fake.DescribeEndpointsWithContextStub != nil {
		return fake.DescribeEndpointsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeEndpointsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeEndpointsWithContextCallCount() int {
	fake.describeEndpointsWithContextMutex.RLock()
	defer fake.describeEndpointsWithContextMutex.RUnlock()
	return len(fake.describeEndpointsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeEndpointsWithContextCalls(stub func(context.Context, *dynamodba.DescribeEndpointsInput, ...request.Option) (*dynamodba.DescribeEndpointsOutput, error)) {
	fake.describeEndpointsWithContextMutex.Lock()
	defer fake.describeEndpointsWithContextMutex.Unlock()
	fake.DescribeEndpointsWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeEndpointsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeEndpointsInput, []request.Option) {
	fake.describeEndpointsWithContextMutex.RLock()
	defer fake.describeEndpointsWithContextMutex.RUnlock()
	argsForCall := fake.describeEndpointsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeEndpointsWithContextReturns(result1 *dynamodba.DescribeEndpointsOutput, result2 error) {
	fake.describeEndpointsWithContextMutex.Lock()
	defer fake.describeEndpointsWithContextMutex.Unlock()
	fake.DescribeEndpointsWithContextStub = nil
	fake.describeEndpointsWithContextReturns = struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeEndpointsWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeEndpointsOutput, result2 error) {
	fake.describeEndpointsWithContextMutex.Lock()
	defer fake.describeEndpointsWithContextMutex.Unlock()
	fake.DescribeEndpointsWithContextStub = nil
	if fake.describeEndpointsWithContextReturnsOnCall == nil {
		fake.describeEndpointsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeEndpointsOutput
			result2 error
		})
	}
	fake.describeEndpointsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeEndpointsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeExport(arg1 *dynamodba.DescribeExportInput) (*dynamodba.DescribeExportOutput, error) {
	fake.describeExportMutex.Lock()
	ret, specificReturn := fake.describeExportReturnsOnCall[len(fake.describeExportArgsForCall)]
	fake.describeExportArgsForCall = append(fake.describeExportArgsForCall, struct {
		arg1 *dynamodba.DescribeExportInput
	}{arg1})
	fake.recordInvocation("DescribeExport", []interface{}{arg1})
	fake.describeExportMutex.Unlock()
	if fake.DescribeExportStub != nil {
		return fake.DescribeExportStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeExportReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeExportCallCount() int {
	fake.describeExportMutex.RLock()
	defer fake.describeExportMutex.RUnlock()
	return len(fake.describeExportArgsForCall)
}

func (fake *FakeDynamoDB) DescribeExportCalls(stub func(*dynamodba.DescribeExportInput) (*dynamodba.DescribeExportOutput, error)) {
	fake.describeExportMutex.Lock()
	defer fake.describeExportMutex.Unlock()
	fake.DescribeExportStub = stub
}

func (fake *FakeDynamoDB) DescribeExportArgsForCall(i int) *dynamodba.DescribeExportInput {
	fake.describeExportMutex.RLock()
	defer fake.describeExportMutex.RUnlock()
	argsForCall := fake.describeExportArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeExportReturns(result1 *dynamodba.DescribeExportOutput, result2 error) {
	fake.describeExportMutex.Lock()
	defer fake.describeExportMutex.Unlock()
	fake.DescribeExportStub = nil
	fake.describeExportReturns = struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeExportReturnsOnCall(i int, result1 *dynamodba.DescribeExportOutput, result2 error) {
	fake.describeExportMutex.Lock()
	defer fake.describeExportMutex.Unlock()
	fake.DescribeExportStub = nil
	if fake.describeExportReturnsOnCall == nil {
		fake.describeExportReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeExportOutput
			result2 error
		})
	}
	fake.describeExportReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeExportRequest(arg1 *dynamodba.DescribeExportInput) (*request.Request, *dynamodba.DescribeExportOutput) {
	fake.describeExportRequestMutex.Lock()
	ret, specificReturn := fake.describeExportRequestReturnsOnCall[len(fake.describeExportRequestArgsForCall)]
	fake.describeExportRequestArgsForCall = append(fake.describeExportRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeExportInput
	}{arg1})
	fake.recordInvocation("DescribeExportRequest", []interface{}{arg1})
	fake.describeExportRequestMutex.Unlock()
	if fake.DescribeExportRequestStub != nil {
		return fake.DescribeExportRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeExportRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeExportRequestCallCount() int {
	fake.describeExportRequestMutex.RLock()
	defer fake.describeExportRequestMutex.RUnlock()
	return len(fake.describeExportRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeExportRequestCalls(stub func(*dynamodba.DescribeExportInput) (*request.Request, *dynamodba.DescribeExportOutput)) {
	fake.describeExportRequestMutex.Lock()
	defer fake.describeExportRequestMutex.Unlock()
	fake.DescribeExportRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeExportRequestArgsForCall(i int) *dynamodba.DescribeExportInput {
	fake.describeExportRequestMutex.RLock()
	defer fake.describeExportRequestMutex.RUnlock()
	argsForCall := fake.describeExportRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeExportRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeExportOutput) {
	fake.describeExportRequestMutex.Lock()
	defer fake.describeExportRequestMutex.Unlock()
	fake.DescribeExportRequestStub = nil
	fake.describeExportRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeExportOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeExportRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeExportOutput) {
	fake.describeExportRequestMutex.Lock()
	defer fake.describeExportRequestMutex.Unlock()
	fake.DescribeExportRequestStub = nil
	if fake.describeExportRequestReturnsOnCall == nil {
		fake.describeExportRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeExportOutput
		})
	}
	fake.describeExportRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeExportOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeExportWithContext(arg1 context.Context, arg2 *dynamodba.DescribeExportInput, arg3 ...request.Option) (*dynamodba.DescribeExportOutput, error) {
	fake.describeExportWithContextMutex.Lock()
	ret, specificReturn := fake.describeExportWithContextReturnsOnCall[len(fake.describeExportWithContextArgsForCall)]
	fake.describeExportWithContextArgsForCall = append(fake.describeExportWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeExportInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeExportWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeExportWithContextMutex.Unlock()
	if fake.DescribeExportWithContextStub != nil {
		return fake.DescribeExportWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeExportWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeExportWithContextCallCount() int {
	fake.describeExportWithContextMutex.RLock()
	defer fake.describeExportWithContextMutex.RUnlock()
	return len(fake.describeExportWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeExportWithContextCalls(stub func(context.Context, *dynamodba.DescribeExportInput, ...request.Option) (*dynamodba.DescribeExportOutput, error)) {
	fake.describeExportWithContextMutex.Lock()
	defer fake.describeExportWithContextMutex.Unlock()
	fake.DescribeExportWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeExportWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeExportInput, []request.Option) {
	fake.describeExportWithContextMutex.RLock()
	defer fake.describeExportWithContextMutex.RUnlock()
	argsForCall := fake.describeExportWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeExportWithContextReturns(result1 *dynamodba.DescribeExportOutput, result2 error) {
	fake.describeExportWithContextMutex.Lock()
	defer fake.describeExportWithContextMutex.Unlock()
	fake.DescribeExportWithContextStub = nil
	fake.describeExportWithContextReturns = struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeExportWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeExportOutput, result2 error) {
	fake.describeExportWithContextMutex.Lock()
	defer fake.describeExportWithContextMutex.Unlock()
	fake.DescribeExportWithContextStub = nil
	if fake.describeExportWithContextReturnsOnCall == nil {
		fake.describeExportWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeExportOutput
			result2 error
		})
	}
	fake.describeExportWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeExportOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTable(arg1 *dynamodba.DescribeGlobalTableInput) (*dynamodba.DescribeGlobalTableOutput, error) {
	fake.describeGlobalTableMutex.Lock()
	ret, specificReturn := fake.describeGlobalTableReturnsOnCall[len(fake.describeGlobalTableArgsForCall)]
	fake.describeGlobalTableArgsForCall = append(fake.describeGlobalTableArgsForCall, struct {
		arg1 *dynamodba.DescribeGlobalTableInput
	}{arg1})
	fake.recordInvocation("DescribeGlobalTable", []interface{}{arg1})
	fake.describeGlobalTableMutex.Unlock()
	if fake.DescribeGlobalTableStub != nil {
		return fake.DescribeGlobalTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeGlobalTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeGlobalTableCallCount() int {
	fake.describeGlobalTableMutex.RLock()
	defer fake.describeGlobalTableMutex.RUnlock()
	return len(fake.describeGlobalTableArgsForCall)
}

func (fake *FakeDynamoDB) DescribeGlobalTableCalls(stub func(*dynamodba.DescribeGlobalTableInput) (*dynamodba.DescribeGlobalTableOutput, error)) {
	fake.describeGlobalTableMutex.Lock()
	defer fake.describeGlobalTableMutex.Unlock()
	fake.DescribeGlobalTableStub = stub
}

func (fake *FakeDynamoDB) DescribeGlobalTableArgsForCall(i int) *dynamodba.DescribeGlobalTableInput {
	fake.describeGlobalTableMutex.RLock()
	defer fake.describeGlobalTableMutex.RUnlock()
	argsForCall := fake.describeGlobalTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeGlobalTableReturns(result1 *dynamodba.DescribeGlobalTableOutput, result2 error) {
	fake.describeGlobalTableMutex.Lock()
	defer fake.describeGlobalTableMutex.Unlock()
	fake.DescribeGlobalTableStub = nil
	fake.describeGlobalTableReturns = struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableReturnsOnCall(i int, result1 *dynamodba.DescribeGlobalTableOutput, result2 error) {
	fake.describeGlobalTableMutex.Lock()
	defer fake.describeGlobalTableMutex.Unlock()
	fake.DescribeGlobalTableStub = nil
	if fake.describeGlobalTableReturnsOnCall == nil {
		fake.describeGlobalTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeGlobalTableOutput
			result2 error
		})
	}
	fake.describeGlobalTableReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableRequest(arg1 *dynamodba.DescribeGlobalTableInput) (*request.Request, *dynamodba.DescribeGlobalTableOutput) {
	fake.describeGlobalTableRequestMutex.Lock()
	ret, specificReturn := fake.describeGlobalTableRequestReturnsOnCall[len(fake.describeGlobalTableRequestArgsForCall)]
	fake.describeGlobalTableRequestArgsForCall = append(fake.describeGlobalTableRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeGlobalTableInput
	}{arg1})
	fake.recordInvocation("DescribeGlobalTableRequest", []interface{}{arg1})
	fake.describeGlobalTableRequestMutex.Unlock()
	if fake.DescribeGlobalTableRequestStub != nil {
		return fake.DescribeGlobalTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeGlobalTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeGlobalTableRequestCallCount() int {
	fake.describeGlobalTableRequestMutex.RLock()
	defer fake.describeGlobalTableRequestMutex.RUnlock()
	return len(fake.describeGlobalTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeGlobalTableRequestCalls(stub func(*dynamodba.DescribeGlobalTableInput) (*request.Request, *dynamodba.DescribeGlobalTableOutput)) {
	fake.describeGlobalTableRequestMutex.Lock()
	defer fake.describeGlobalTableRequestMutex.Unlock()
	fake.DescribeGlobalTableRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeGlobalTableRequestArgsForCall(i int) *dynamodba.DescribeGlobalTableInput {
	fake.describeGlobalTableRequestMutex.RLock()
	defer fake.describeGlobalTableRequestMutex.RUnlock()
	argsForCall := fake.describeGlobalTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeGlobalTableRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeGlobalTableOutput) {
	fake.describeGlobalTableRequestMutex.Lock()
	defer fake.describeGlobalTableRequestMutex.Unlock()
	fake.DescribeGlobalTableRequestStub = nil
	fake.describeGlobalTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeGlobalTableOutput) {
	fake.describeGlobalTableRequestMutex.Lock()
	defer fake.describeGlobalTableRequestMutex.Unlock()
	fake.DescribeGlobalTableRequestStub = nil
	if fake.describeGlobalTableRequestReturnsOnCall == nil {
		fake.describeGlobalTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeGlobalTableOutput
		})
	}
	fake.describeGlobalTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettings(arg1 *dynamodba.DescribeGlobalTableSettingsInput) (*dynamodba.DescribeGlobalTableSettingsOutput, error) {
	fake.describeGlobalTableSettingsMutex.Lock()
	ret, specificReturn := fake.describeGlobalTableSettingsReturnsOnCall[len(fake.describeGlobalTableSettingsArgsForCall)]
	fake.describeGlobalTableSettingsArgsForCall = append(fake.describeGlobalTableSettingsArgsForCall, struct {
		arg1 *dynamodba.DescribeGlobalTableSettingsInput
	}{arg1})
	fake.recordInvocation("DescribeGlobalTableSettings", []interface{}{arg1})
	fake.describeGlobalTableSettingsMutex.Unlock()
	if fake.DescribeGlobalTableSettingsStub != nil {
		return fake.DescribeGlobalTableSettingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeGlobalTableSettingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsCallCount() int {
	fake.describeGlobalTableSettingsMutex.RLock()
	defer fake.describeGlobalTableSettingsMutex.RUnlock()
	return len(fake.describeGlobalTableSettingsArgsForCall)
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsCalls(stub func(*dynamodba.DescribeGlobalTableSettingsInput) (*dynamodba.DescribeGlobalTableSettingsOutput, error)) {
	fake.describeGlobalTableSettingsMutex.Lock()
	defer fake.describeGlobalTableSettingsMutex.Unlock()
	fake.DescribeGlobalTableSettingsStub = stub
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsArgsForCall(i int) *dynamodba.DescribeGlobalTableSettingsInput {
	fake.describeGlobalTableSettingsMutex.RLock()
	defer fake.describeGlobalTableSettingsMutex.RUnlock()
	argsForCall := fake.describeGlobalTableSettingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsReturns(result1 *dynamodba.DescribeGlobalTableSettingsOutput, result2 error) {
	fake.describeGlobalTableSettingsMutex.Lock()
	defer fake.describeGlobalTableSettingsMutex.Unlock()
	fake.DescribeGlobalTableSettingsStub = nil
	fake.describeGlobalTableSettingsReturns = struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsReturnsOnCall(i int, result1 *dynamodba.DescribeGlobalTableSettingsOutput, result2 error) {
	fake.describeGlobalTableSettingsMutex.Lock()
	defer fake.describeGlobalTableSettingsMutex.Unlock()
	fake.DescribeGlobalTableSettingsStub = nil
	if fake.describeGlobalTableSettingsReturnsOnCall == nil {
		fake.describeGlobalTableSettingsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeGlobalTableSettingsOutput
			result2 error
		})
	}
	fake.describeGlobalTableSettingsReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsRequest(arg1 *dynamodba.DescribeGlobalTableSettingsInput) (*request.Request, *dynamodba.DescribeGlobalTableSettingsOutput) {
	fake.describeGlobalTableSettingsRequestMutex.Lock()
	ret, specificReturn := fake.describeGlobalTableSettingsRequestReturnsOnCall[len(fake.describeGlobalTableSettingsRequestArgsForCall)]
	fake.describeGlobalTableSettingsRequestArgsForCall = append(fake.describeGlobalTableSettingsRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeGlobalTableSettingsInput
	}{arg1})
	fake.recordInvocation("DescribeGlobalTableSettingsRequest", []interface{}{arg1})
	fake.describeGlobalTableSettingsRequestMutex.Unlock()
	if fake.DescribeGlobalTableSettingsRequestStub != nil {
		return fake.DescribeGlobalTableSettingsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeGlobalTableSettingsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsRequestCallCount() int {
	fake.describeGlobalTableSettingsRequestMutex.RLock()
	defer fake.describeGlobalTableSettingsRequestMutex.RUnlock()
	return len(fake.describeGlobalTableSettingsRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsRequestCalls(stub func(*dynamodba.DescribeGlobalTableSettingsInput) (*request.Request, *dynamodba.DescribeGlobalTableSettingsOutput)) {
	fake.describeGlobalTableSettingsRequestMutex.Lock()
	defer fake.describeGlobalTableSettingsRequestMutex.Unlock()
	fake.DescribeGlobalTableSettingsRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsRequestArgsForCall(i int) *dynamodba.DescribeGlobalTableSettingsInput {
	fake.describeGlobalTableSettingsRequestMutex.RLock()
	defer fake.describeGlobalTableSettingsRequestMutex.RUnlock()
	argsForCall := fake.describeGlobalTableSettingsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeGlobalTableSettingsOutput) {
	fake.describeGlobalTableSettingsRequestMutex.Lock()
	defer fake.describeGlobalTableSettingsRequestMutex.Unlock()
	fake.DescribeGlobalTableSettingsRequestStub = nil
	fake.describeGlobalTableSettingsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableSettingsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeGlobalTableSettingsOutput) {
	fake.describeGlobalTableSettingsRequestMutex.Lock()
	defer fake.describeGlobalTableSettingsRequestMutex.Unlock()
	fake.DescribeGlobalTableSettingsRequestStub = nil
	if fake.describeGlobalTableSettingsRequestReturnsOnCall == nil {
		fake.describeGlobalTableSettingsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeGlobalTableSettingsOutput
		})
	}
	fake.describeGlobalTableSettingsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeGlobalTableSettingsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeGlobalTableSettingsInput, arg3 ...request.Option) (*dynamodba.DescribeGlobalTableSettingsOutput, error) {
	fake.describeGlobalTableSettingsWithContextMutex.Lock()
	ret, specificReturn := fake.describeGlobalTableSettingsWithContextReturnsOnCall[len(fake.describeGlobalTableSettingsWithContextArgsForCall)]
	fake.describeGlobalTableSettingsWithContextArgsForCall = append(fake.describeGlobalTableSettingsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeGlobalTableSettingsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeGlobalTableSettingsWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeGlobalTableSettingsWithContextMutex.Unlock()
	if fake.DescribeGlobalTableSettingsWithContextStub != nil {
		return fake.DescribeGlobalTableSettingsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeGlobalTableSettingsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsWithContextCallCount() int {
	fake.describeGlobalTableSettingsWithContextMutex.RLock()
	defer fake.describeGlobalTableSettingsWithContextMutex.RUnlock()
	return len(fake.describeGlobalTableSettingsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsWithContextCalls(stub func(context.Context, *dynamodba.DescribeGlobalTableSettingsInput, ...request.Option) (*dynamodba.DescribeGlobalTableSettingsOutput, error)) {
	fake.describeGlobalTableSettingsWithContextMutex.Lock()
	defer fake.describeGlobalTableSettingsWithContextMutex.Unlock()
	fake.DescribeGlobalTableSettingsWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeGlobalTableSettingsInput, []request.Option) {
	fake.describeGlobalTableSettingsWithContextMutex.RLock()
	defer fake.describeGlobalTableSettingsWithContextMutex.RUnlock()
	argsForCall := fake.describeGlobalTableSettingsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsWithContextReturns(result1 *dynamodba.DescribeGlobalTableSettingsOutput, result2 error) {
	fake.describeGlobalTableSettingsWithContextMutex.Lock()
	defer fake.describeGlobalTableSettingsWithContextMutex.Unlock()
	fake.DescribeGlobalTableSettingsWithContextStub = nil
	fake.describeGlobalTableSettingsWithContextReturns = struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableSettingsWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeGlobalTableSettingsOutput, result2 error) {
	fake.describeGlobalTableSettingsWithContextMutex.Lock()
	defer fake.describeGlobalTableSettingsWithContextMutex.Unlock()
	fake.DescribeGlobalTableSettingsWithContextStub = nil
	if fake.describeGlobalTableSettingsWithContextReturnsOnCall == nil {
		fake.describeGlobalTableSettingsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeGlobalTableSettingsOutput
			result2 error
		})
	}
	fake.describeGlobalTableSettingsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableWithContext(arg1 context.Context, arg2 *dynamodba.DescribeGlobalTableInput, arg3 ...request.Option) (*dynamodba.DescribeGlobalTableOutput, error) {
	fake.describeGlobalTableWithContextMutex.Lock()
	ret, specificReturn := fake.describeGlobalTableWithContextReturnsOnCall[len(fake.describeGlobalTableWithContextArgsForCall)]
	fake.describeGlobalTableWithContextArgsForCall = append(fake.describeGlobalTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeGlobalTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeGlobalTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeGlobalTableWithContextMutex.Unlock()
	if fake.DescribeGlobalTableWithContextStub != nil {
		return fake.DescribeGlobalTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeGlobalTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeGlobalTableWithContextCallCount() int {
	fake.describeGlobalTableWithContextMutex.RLock()
	defer fake.describeGlobalTableWithContextMutex.RUnlock()
	return len(fake.describeGlobalTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeGlobalTableWithContextCalls(stub func(context.Context, *dynamodba.DescribeGlobalTableInput, ...request.Option) (*dynamodba.DescribeGlobalTableOutput, error)) {
	fake.describeGlobalTableWithContextMutex.Lock()
	defer fake.describeGlobalTableWithContextMutex.Unlock()
	fake.DescribeGlobalTableWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeGlobalTableWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeGlobalTableInput, []request.Option) {
	fake.describeGlobalTableWithContextMutex.RLock()
	defer fake.describeGlobalTableWithContextMutex.RUnlock()
	argsForCall := fake.describeGlobalTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeGlobalTableWithContextReturns(result1 *dynamodba.DescribeGlobalTableOutput, result2 error) {
	fake.describeGlobalTableWithContextMutex.Lock()
	defer fake.describeGlobalTableWithContextMutex.Unlock()
	fake.DescribeGlobalTableWithContextStub = nil
	fake.describeGlobalTableWithContextReturns = struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeGlobalTableWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeGlobalTableOutput, result2 error) {
	fake.describeGlobalTableWithContextMutex.Lock()
	defer fake.describeGlobalTableWithContextMutex.Unlock()
	fake.DescribeGlobalTableWithContextStub = nil
	if fake.describeGlobalTableWithContextReturnsOnCall == nil {
		fake.describeGlobalTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeGlobalTableOutput
			result2 error
		})
	}
	fake.describeGlobalTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestination(arg1 *dynamodba.DescribeKinesisStreamingDestinationInput) (*dynamodba.DescribeKinesisStreamingDestinationOutput, error) {
	fake.describeKinesisStreamingDestinationMutex.Lock()
	ret, specificReturn := fake.describeKinesisStreamingDestinationReturnsOnCall[len(fake.describeKinesisStreamingDestinationArgsForCall)]
	fake.describeKinesisStreamingDestinationArgsForCall = append(fake.describeKinesisStreamingDestinationArgsForCall, struct {
		arg1 *dynamodba.DescribeKinesisStreamingDestinationInput
	}{arg1})
	fake.recordInvocation("DescribeKinesisStreamingDestination", []interface{}{arg1})
	fake.describeKinesisStreamingDestinationMutex.Unlock()
	if fake.DescribeKinesisStreamingDestinationStub != nil {
		return fake.DescribeKinesisStreamingDestinationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeKinesisStreamingDestinationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationCallCount() int {
	fake.describeKinesisStreamingDestinationMutex.RLock()
	defer fake.describeKinesisStreamingDestinationMutex.RUnlock()
	return len(fake.describeKinesisStreamingDestinationArgsForCall)
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationCalls(stub func(*dynamodba.DescribeKinesisStreamingDestinationInput) (*dynamodba.DescribeKinesisStreamingDestinationOutput, error)) {
	fake.describeKinesisStreamingDestinationMutex.Lock()
	defer fake.describeKinesisStreamingDestinationMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationStub = stub
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationArgsForCall(i int) *dynamodba.DescribeKinesisStreamingDestinationInput {
	fake.describeKinesisStreamingDestinationMutex.RLock()
	defer fake.describeKinesisStreamingDestinationMutex.RUnlock()
	argsForCall := fake.describeKinesisStreamingDestinationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationReturns(result1 *dynamodba.DescribeKinesisStreamingDestinationOutput, result2 error) {
	fake.describeKinesisStreamingDestinationMutex.Lock()
	defer fake.describeKinesisStreamingDestinationMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationStub = nil
	fake.describeKinesisStreamingDestinationReturns = struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationReturnsOnCall(i int, result1 *dynamodba.DescribeKinesisStreamingDestinationOutput, result2 error) {
	fake.describeKinesisStreamingDestinationMutex.Lock()
	defer fake.describeKinesisStreamingDestinationMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationStub = nil
	if fake.describeKinesisStreamingDestinationReturnsOnCall == nil {
		fake.describeKinesisStreamingDestinationReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
			result2 error
		})
	}
	fake.describeKinesisStreamingDestinationReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationRequest(arg1 *dynamodba.DescribeKinesisStreamingDestinationInput) (*request.Request, *dynamodba.DescribeKinesisStreamingDestinationOutput) {
	fake.describeKinesisStreamingDestinationRequestMutex.Lock()
	ret, specificReturn := fake.describeKinesisStreamingDestinationRequestReturnsOnCall[len(fake.describeKinesisStreamingDestinationRequestArgsForCall)]
	fake.describeKinesisStreamingDestinationRequestArgsForCall = append(fake.describeKinesisStreamingDestinationRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeKinesisStreamingDestinationInput
	}{arg1})
	fake.recordInvocation("DescribeKinesisStreamingDestinationRequest", []interface{}{arg1})
	fake.describeKinesisStreamingDestinationRequestMutex.Unlock()
	if fake.DescribeKinesisStreamingDestinationRequestStub != nil {
		return fake.DescribeKinesisStreamingDestinationRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeKinesisStreamingDestinationRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationRequestCallCount() int {
	fake.describeKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.describeKinesisStreamingDestinationRequestMutex.RUnlock()
	return len(fake.describeKinesisStreamingDestinationRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationRequestCalls(stub func(*dynamodba.DescribeKinesisStreamingDestinationInput) (*request.Request, *dynamodba.DescribeKinesisStreamingDestinationOutput)) {
	fake.describeKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.describeKinesisStreamingDestinationRequestMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationRequestArgsForCall(i int) *dynamodba.DescribeKinesisStreamingDestinationInput {
	fake.describeKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.describeKinesisStreamingDestinationRequestMutex.RUnlock()
	argsForCall := fake.describeKinesisStreamingDestinationRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeKinesisStreamingDestinationOutput) {
	fake.describeKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.describeKinesisStreamingDestinationRequestMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationRequestStub = nil
	fake.describeKinesisStreamingDestinationRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeKinesisStreamingDestinationOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeKinesisStreamingDestinationOutput) {
	fake.describeKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.describeKinesisStreamingDestinationRequestMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationRequestStub = nil
	if fake.describeKinesisStreamingDestinationRequestReturnsOnCall == nil {
		fake.describeKinesisStreamingDestinationRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeKinesisStreamingDestinationOutput
		})
	}
	fake.describeKinesisStreamingDestinationRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeKinesisStreamingDestinationOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationWithContext(arg1 context.Context, arg2 *dynamodba.DescribeKinesisStreamingDestinationInput, arg3 ...request.Option) (*dynamodba.DescribeKinesisStreamingDestinationOutput, error) {
	fake.describeKinesisStreamingDestinationWithContextMutex.Lock()
	ret, specificReturn := fake.describeKinesisStreamingDestinationWithContextReturnsOnCall[len(fake.describeKinesisStreamingDestinationWithContextArgsForCall)]
	fake.describeKinesisStreamingDestinationWithContextArgsForCall = append(fake.describeKinesisStreamingDestinationWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeKinesisStreamingDestinationInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeKinesisStreamingDestinationWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeKinesisStreamingDestinationWithContextMutex.Unlock()
	if fake.DescribeKinesisStreamingDestinationWithContextStub != nil {
		return fake.DescribeKinesisStreamingDestinationWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeKinesisStreamingDestinationWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationWithContextCallCount() int {
	fake.describeKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.describeKinesisStreamingDestinationWithContextMutex.RUnlock()
	return len(fake.describeKinesisStreamingDestinationWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationWithContextCalls(stub func(context.Context, *dynamodba.DescribeKinesisStreamingDestinationInput, ...request.Option) (*dynamodba.DescribeKinesisStreamingDestinationOutput, error)) {
	fake.describeKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.describeKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeKinesisStreamingDestinationInput, []request.Option) {
	fake.describeKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.describeKinesisStreamingDestinationWithContextMutex.RUnlock()
	argsForCall := fake.describeKinesisStreamingDestinationWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationWithContextReturns(result1 *dynamodba.DescribeKinesisStreamingDestinationOutput, result2 error) {
	fake.describeKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.describeKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationWithContextStub = nil
	fake.describeKinesisStreamingDestinationWithContextReturns = struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeKinesisStreamingDestinationWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeKinesisStreamingDestinationOutput, result2 error) {
	fake.describeKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.describeKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.DescribeKinesisStreamingDestinationWithContextStub = nil
	if fake.describeKinesisStreamingDestinationWithContextReturnsOnCall == nil {
		fake.describeKinesisStreamingDestinationWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
			result2 error
		})
	}
	fake.describeKinesisStreamingDestinationWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeLimits(arg1 *dynamodba.DescribeLimitsInput) (*dynamodba.DescribeLimitsOutput, error) {
	fake.describeLimitsMutex.Lock()
	ret, specificReturn := fake.describeLimitsReturnsOnCall[len(fake.describeLimitsArgsForCall)]
	fake.describeLimitsArgsForCall = append(fake.describeLimitsArgsForCall, struct {
		arg1 *dynamodba.DescribeLimitsInput
	}{arg1})
	fake.recordInvocation("DescribeLimits", []interface{}{arg1})
	fake.describeLimitsMutex.Unlock()
	if fake.DescribeLimitsStub != nil {
		return fake.DescribeLimitsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeLimitsCallCount() int {
	fake.describeLimitsMutex.RLock()
	defer fake.describeLimitsMutex.RUnlock()
	return len(fake.describeLimitsArgsForCall)
}

func (fake *FakeDynamoDB) DescribeLimitsCalls(stub func(*dynamodba.DescribeLimitsInput) (*dynamodba.DescribeLimitsOutput, error)) {
	fake.describeLimitsMutex.Lock()
	defer fake.describeLimitsMutex.Unlock()
	fake.DescribeLimitsStub = stub
}

func (fake *FakeDynamoDB) DescribeLimitsArgsForCall(i int) *dynamodba.DescribeLimitsInput {
	fake.describeLimitsMutex.RLock()
	defer fake.describeLimitsMutex.RUnlock()
	argsForCall := fake.describeLimitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeLimitsReturns(result1 *dynamodba.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsMutex.Lock()
	defer fake.describeLimitsMutex.Unlock()
	fake.DescribeLimitsStub = nil
	fake.describeLimitsReturns = struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeLimitsReturnsOnCall(i int, result1 *dynamodba.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsMutex.Lock()
	defer fake.describeLimitsMutex.Unlock()
	fake.DescribeLimitsStub = nil
	if fake.describeLimitsReturnsOnCall == nil {
		fake.describeLimitsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeLimitsOutput
			result2 error
		})
	}
	fake.describeLimitsReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeLimitsRequest(arg1 *dynamodba.DescribeLimitsInput) (*request.Request, *dynamodba.DescribeLimitsOutput) {
	fake.describeLimitsRequestMutex.Lock()
	ret, specificReturn := fake.describeLimitsRequestReturnsOnCall[len(fake.describeLimitsRequestArgsForCall)]
	fake.describeLimitsRequestArgsForCall = append(fake.describeLimitsRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeLimitsInput
	}{arg1})
	fake.recordInvocation("DescribeLimitsRequest", []interface{}{arg1})
	fake.describeLimitsRequestMutex.Unlock()
	if fake.DescribeLimitsRequestStub != nil {
		return fake.DescribeLimitsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeLimitsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeLimitsRequestCallCount() int {
	fake.describeLimitsRequestMutex.RLock()
	defer fake.describeLimitsRequestMutex.RUnlock()
	return len(fake.describeLimitsRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeLimitsRequestCalls(stub func(*dynamodba.DescribeLimitsInput) (*request.Request, *dynamodba.DescribeLimitsOutput)) {
	fake.describeLimitsRequestMutex.Lock()
	defer fake.describeLimitsRequestMutex.Unlock()
	fake.DescribeLimitsRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeLimitsRequestArgsForCall(i int) *dynamodba.DescribeLimitsInput {
	fake.describeLimitsRequestMutex.RLock()
	defer fake.describeLimitsRequestMutex.RUnlock()
	argsForCall := fake.describeLimitsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeLimitsRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeLimitsOutput) {
	fake.describeLimitsRequestMutex.Lock()
	defer fake.describeLimitsRequestMutex.Unlock()
	fake.DescribeLimitsRequestStub = nil
	fake.describeLimitsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeLimitsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeLimitsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeLimitsOutput) {
	fake.describeLimitsRequestMutex.Lock()
	defer fake.describeLimitsRequestMutex.Unlock()
	fake.DescribeLimitsRequestStub = nil
	if fake.describeLimitsRequestReturnsOnCall == nil {
		fake.describeLimitsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeLimitsOutput
		})
	}
	fake.describeLimitsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeLimitsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeLimitsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeLimitsInput, arg3 ...request.Option) (*dynamodba.DescribeLimitsOutput, error) {
	fake.describeLimitsWithContextMutex.Lock()
	ret, specificReturn := fake.describeLimitsWithContextReturnsOnCall[len(fake.describeLimitsWithContextArgsForCall)]
	fake.describeLimitsWithContextArgsForCall = append(fake.describeLimitsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeLimitsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeLimitsWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeLimitsWithContextMutex.Unlock()
	if fake.DescribeLimitsWithContextStub != nil {
		return fake.DescribeLimitsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeLimitsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeLimitsWithContextCallCount() int {
	fake.describeLimitsWithContextMutex.RLock()
	defer fake.describeLimitsWithContextMutex.RUnlock()
	return len(fake.describeLimitsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeLimitsWithContextCalls(stub func(context.Context, *dynamodba.DescribeLimitsInput, ...request.Option) (*dynamodba.DescribeLimitsOutput, error)) {
	fake.describeLimitsWithContextMutex.Lock()
	defer fake.describeLimitsWithContextMutex.Unlock()
	fake.DescribeLimitsWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeLimitsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeLimitsInput, []request.Option) {
	fake.describeLimitsWithContextMutex.RLock()
	defer fake.describeLimitsWithContextMutex.RUnlock()
	argsForCall := fake.describeLimitsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeLimitsWithContextReturns(result1 *dynamodba.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsWithContextMutex.Lock()
	defer fake.describeLimitsWithContextMutex.Unlock()
	fake.DescribeLimitsWithContextStub = nil
	fake.describeLimitsWithContextReturns = struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeLimitsWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsWithContextMutex.Lock()
	defer fake.describeLimitsWithContextMutex.Unlock()
	fake.DescribeLimitsWithContextStub = nil
	if fake.describeLimitsWithContextReturnsOnCall == nil {
		fake.describeLimitsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeLimitsOutput
			result2 error
		})
	}
	fake.describeLimitsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTable(arg1 *dynamodba.DescribeTableInput) (*dynamodba.DescribeTableOutput, error) {
	fake.describeTableMutex.Lock()
	ret, specificReturn := fake.describeTableReturnsOnCall[len(fake.describeTableArgsForCall)]
	fake.describeTableArgsForCall = append(fake.describeTableArgsForCall, struct {
		arg1 *dynamodba.DescribeTableInput
	}{arg1})
	fake.recordInvocation("DescribeTable", []interface{}{arg1})
	fake.describeTableMutex.Unlock()
	if fake.DescribeTableStub != nil {
		return fake.DescribeTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTableCallCount() int {
	fake.describeTableMutex.RLock()
	defer fake.describeTableMutex.RUnlock()
	return len(fake.describeTableArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTableCalls(stub func(*dynamodba.DescribeTableInput) (*dynamodba.DescribeTableOutput, error)) {
	fake.describeTableMutex.Lock()
	defer fake.describeTableMutex.Unlock()
	fake.DescribeTableStub = stub
}

func (fake *FakeDynamoDB) DescribeTableArgsForCall(i int) *dynamodba.DescribeTableInput {
	fake.describeTableMutex.RLock()
	defer fake.describeTableMutex.RUnlock()
	argsForCall := fake.describeTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeTableReturns(result1 *dynamodba.DescribeTableOutput, result2 error) {
	fake.describeTableMutex.Lock()
	defer fake.describeTableMutex.Unlock()
	fake.DescribeTableStub = nil
	fake.describeTableReturns = struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReturnsOnCall(i int, result1 *dynamodba.DescribeTableOutput, result2 error) {
	fake.describeTableMutex.Lock()
	defer fake.describeTableMutex.Unlock()
	fake.DescribeTableStub = nil
	if fake.describeTableReturnsOnCall == nil {
		fake.describeTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeTableOutput
			result2 error
		})
	}
	fake.describeTableReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScaling(arg1 *dynamodba.DescribeTableReplicaAutoScalingInput) (*dynamodba.DescribeTableReplicaAutoScalingOutput, error) {
	fake.describeTableReplicaAutoScalingMutex.Lock()
	ret, specificReturn := fake.describeTableReplicaAutoScalingReturnsOnCall[len(fake.describeTableReplicaAutoScalingArgsForCall)]
	fake.describeTableReplicaAutoScalingArgsForCall = append(fake.describeTableReplicaAutoScalingArgsForCall, struct {
		arg1 *dynamodba.DescribeTableReplicaAutoScalingInput
	}{arg1})
	fake.recordInvocation("DescribeTableReplicaAutoScaling", []interface{}{arg1})
	fake.describeTableReplicaAutoScalingMutex.Unlock()
	if fake.DescribeTableReplicaAutoScalingStub != nil {
		return fake.DescribeTableReplicaAutoScalingStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTableReplicaAutoScalingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingCallCount() int {
	fake.describeTableReplicaAutoScalingMutex.RLock()
	defer fake.describeTableReplicaAutoScalingMutex.RUnlock()
	return len(fake.describeTableReplicaAutoScalingArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingCalls(stub func(*dynamodba.DescribeTableReplicaAutoScalingInput) (*dynamodba.DescribeTableReplicaAutoScalingOutput, error)) {
	fake.describeTableReplicaAutoScalingMutex.Lock()
	defer fake.describeTableReplicaAutoScalingMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingStub = stub
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingArgsForCall(i int) *dynamodba.DescribeTableReplicaAutoScalingInput {
	fake.describeTableReplicaAutoScalingMutex.RLock()
	defer fake.describeTableReplicaAutoScalingMutex.RUnlock()
	argsForCall := fake.describeTableReplicaAutoScalingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingReturns(result1 *dynamodba.DescribeTableReplicaAutoScalingOutput, result2 error) {
	fake.describeTableReplicaAutoScalingMutex.Lock()
	defer fake.describeTableReplicaAutoScalingMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingStub = nil
	fake.describeTableReplicaAutoScalingReturns = struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingReturnsOnCall(i int, result1 *dynamodba.DescribeTableReplicaAutoScalingOutput, result2 error) {
	fake.describeTableReplicaAutoScalingMutex.Lock()
	defer fake.describeTableReplicaAutoScalingMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingStub = nil
	if fake.describeTableReplicaAutoScalingReturnsOnCall == nil {
		fake.describeTableReplicaAutoScalingReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
			result2 error
		})
	}
	fake.describeTableReplicaAutoScalingReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingRequest(arg1 *dynamodba.DescribeTableReplicaAutoScalingInput) (*request.Request, *dynamodba.DescribeTableReplicaAutoScalingOutput) {
	fake.describeTableReplicaAutoScalingRequestMutex.Lock()
	ret, specificReturn := fake.describeTableReplicaAutoScalingRequestReturnsOnCall[len(fake.describeTableReplicaAutoScalingRequestArgsForCall)]
	fake.describeTableReplicaAutoScalingRequestArgsForCall = append(fake.describeTableReplicaAutoScalingRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeTableReplicaAutoScalingInput
	}{arg1})
	fake.recordInvocation("DescribeTableReplicaAutoScalingRequest", []interface{}{arg1})
	fake.describeTableReplicaAutoScalingRequestMutex.Unlock()
	if fake.DescribeTableReplicaAutoScalingRequestStub != nil {
		return fake.DescribeTableReplicaAutoScalingRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTableReplicaAutoScalingRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingRequestCallCount() int {
	fake.describeTableReplicaAutoScalingRequestMutex.RLock()
	defer fake.describeTableReplicaAutoScalingRequestMutex.RUnlock()
	return len(fake.describeTableReplicaAutoScalingRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingRequestCalls(stub func(*dynamodba.DescribeTableReplicaAutoScalingInput) (*request.Request, *dynamodba.DescribeTableReplicaAutoScalingOutput)) {
	fake.describeTableReplicaAutoScalingRequestMutex.Lock()
	defer fake.describeTableReplicaAutoScalingRequestMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingRequestArgsForCall(i int) *dynamodba.DescribeTableReplicaAutoScalingInput {
	fake.describeTableReplicaAutoScalingRequestMutex.RLock()
	defer fake.describeTableReplicaAutoScalingRequestMutex.RUnlock()
	argsForCall := fake.describeTableReplicaAutoScalingRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeTableReplicaAutoScalingOutput) {
	fake.describeTableReplicaAutoScalingRequestMutex.Lock()
	defer fake.describeTableReplicaAutoScalingRequestMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingRequestStub = nil
	fake.describeTableReplicaAutoScalingRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableReplicaAutoScalingOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeTableReplicaAutoScalingOutput) {
	fake.describeTableReplicaAutoScalingRequestMutex.Lock()
	defer fake.describeTableReplicaAutoScalingRequestMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingRequestStub = nil
	if fake.describeTableReplicaAutoScalingRequestReturnsOnCall == nil {
		fake.describeTableReplicaAutoScalingRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeTableReplicaAutoScalingOutput
		})
	}
	fake.describeTableReplicaAutoScalingRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableReplicaAutoScalingOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingWithContext(arg1 context.Context, arg2 *dynamodba.DescribeTableReplicaAutoScalingInput, arg3 ...request.Option) (*dynamodba.DescribeTableReplicaAutoScalingOutput, error) {
	fake.describeTableReplicaAutoScalingWithContextMutex.Lock()
	ret, specificReturn := fake.describeTableReplicaAutoScalingWithContextReturnsOnCall[len(fake.describeTableReplicaAutoScalingWithContextArgsForCall)]
	fake.describeTableReplicaAutoScalingWithContextArgsForCall = append(fake.describeTableReplicaAutoScalingWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableReplicaAutoScalingInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeTableReplicaAutoScalingWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeTableReplicaAutoScalingWithContextMutex.Unlock()
	if fake.DescribeTableReplicaAutoScalingWithContextStub != nil {
		return fake.DescribeTableReplicaAutoScalingWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTableReplicaAutoScalingWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingWithContextCallCount() int {
	fake.describeTableReplicaAutoScalingWithContextMutex.RLock()
	defer fake.describeTableReplicaAutoScalingWithContextMutex.RUnlock()
	return len(fake.describeTableReplicaAutoScalingWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingWithContextCalls(stub func(context.Context, *dynamodba.DescribeTableReplicaAutoScalingInput, ...request.Option) (*dynamodba.DescribeTableReplicaAutoScalingOutput, error)) {
	fake.describeTableReplicaAutoScalingWithContextMutex.Lock()
	defer fake.describeTableReplicaAutoScalingWithContextMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeTableReplicaAutoScalingInput, []request.Option) {
	fake.describeTableReplicaAutoScalingWithContextMutex.RLock()
	defer fake.describeTableReplicaAutoScalingWithContextMutex.RUnlock()
	argsForCall := fake.describeTableReplicaAutoScalingWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingWithContextReturns(result1 *dynamodba.DescribeTableReplicaAutoScalingOutput, result2 error) {
	fake.describeTableReplicaAutoScalingWithContextMutex.Lock()
	defer fake.describeTableReplicaAutoScalingWithContextMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingWithContextStub = nil
	fake.describeTableReplicaAutoScalingWithContextReturns = struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableReplicaAutoScalingWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeTableReplicaAutoScalingOutput, result2 error) {
	fake.describeTableReplicaAutoScalingWithContextMutex.Lock()
	defer fake.describeTableReplicaAutoScalingWithContextMutex.Unlock()
	fake.DescribeTableReplicaAutoScalingWithContextStub = nil
	if fake.describeTableReplicaAutoScalingWithContextReturnsOnCall == nil {
		fake.describeTableReplicaAutoScalingWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
			result2 error
		})
	}
	fake.describeTableReplicaAutoScalingWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableRequest(arg1 *dynamodba.DescribeTableInput) (*request.Request, *dynamodba.DescribeTableOutput) {
	fake.describeTableRequestMutex.Lock()
	ret, specificReturn := fake.describeTableRequestReturnsOnCall[len(fake.describeTableRequestArgsForCall)]
	fake.describeTableRequestArgsForCall = append(fake.describeTableRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeTableInput
	}{arg1})
	fake.recordInvocation("DescribeTableRequest", []interface{}{arg1})
	fake.describeTableRequestMutex.Unlock()
	if fake.DescribeTableRequestStub != nil {
		return fake.DescribeTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTableRequestCallCount() int {
	fake.describeTableRequestMutex.RLock()
	defer fake.describeTableRequestMutex.RUnlock()
	return len(fake.describeTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTableRequestCalls(stub func(*dynamodba.DescribeTableInput) (*request.Request, *dynamodba.DescribeTableOutput)) {
	fake.describeTableRequestMutex.Lock()
	defer fake.describeTableRequestMutex.Unlock()
	fake.DescribeTableRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeTableRequestArgsForCall(i int) *dynamodba.DescribeTableInput {
	fake.describeTableRequestMutex.RLock()
	defer fake.describeTableRequestMutex.RUnlock()
	argsForCall := fake.describeTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeTableRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeTableOutput) {
	fake.describeTableRequestMutex.Lock()
	defer fake.describeTableRequestMutex.Unlock()
	fake.DescribeTableRequestStub = nil
	fake.describeTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeTableOutput) {
	fake.describeTableRequestMutex.Lock()
	defer fake.describeTableRequestMutex.Unlock()
	fake.DescribeTableRequestStub = nil
	if fake.describeTableRequestReturnsOnCall == nil {
		fake.describeTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeTableOutput
		})
	}
	fake.describeTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableWithContext(arg1 context.Context, arg2 *dynamodba.DescribeTableInput, arg3 ...request.Option) (*dynamodba.DescribeTableOutput, error) {
	fake.describeTableWithContextMutex.Lock()
	ret, specificReturn := fake.describeTableWithContextReturnsOnCall[len(fake.describeTableWithContextArgsForCall)]
	fake.describeTableWithContextArgsForCall = append(fake.describeTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeTableWithContextMutex.Unlock()
	if fake.DescribeTableWithContextStub != nil {
		return fake.DescribeTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTableWithContextCallCount() int {
	fake.describeTableWithContextMutex.RLock()
	defer fake.describeTableWithContextMutex.RUnlock()
	return len(fake.describeTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTableWithContextCalls(stub func(context.Context, *dynamodba.DescribeTableInput, ...request.Option) (*dynamodba.DescribeTableOutput, error)) {
	fake.describeTableWithContextMutex.Lock()
	defer fake.describeTableWithContextMutex.Unlock()
	fake.DescribeTableWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeTableWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeTableInput, []request.Option) {
	fake.describeTableWithContextMutex.RLock()
	defer fake.describeTableWithContextMutex.RUnlock()
	argsForCall := fake.describeTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeTableWithContextReturns(result1 *dynamodba.DescribeTableOutput, result2 error) {
	fake.describeTableWithContextMutex.Lock()
	defer fake.describeTableWithContextMutex.Unlock()
	fake.DescribeTableWithContextStub = nil
	fake.describeTableWithContextReturns = struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTableWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeTableOutput, result2 error) {
	fake.describeTableWithContextMutex.Lock()
	defer fake.describeTableWithContextMutex.Unlock()
	fake.DescribeTableWithContextStub = nil
	if fake.describeTableWithContextReturnsOnCall == nil {
		fake.describeTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeTableOutput
			result2 error
		})
	}
	fake.describeTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTimeToLive(arg1 *dynamodba.DescribeTimeToLiveInput) (*dynamodba.DescribeTimeToLiveOutput, error) {
	fake.describeTimeToLiveMutex.Lock()
	ret, specificReturn := fake.describeTimeToLiveReturnsOnCall[len(fake.describeTimeToLiveArgsForCall)]
	fake.describeTimeToLiveArgsForCall = append(fake.describeTimeToLiveArgsForCall, struct {
		arg1 *dynamodba.DescribeTimeToLiveInput
	}{arg1})
	fake.recordInvocation("DescribeTimeToLive", []interface{}{arg1})
	fake.describeTimeToLiveMutex.Unlock()
	if fake.DescribeTimeToLiveStub != nil {
		return fake.DescribeTimeToLiveStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTimeToLiveReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTimeToLiveCallCount() int {
	fake.describeTimeToLiveMutex.RLock()
	defer fake.describeTimeToLiveMutex.RUnlock()
	return len(fake.describeTimeToLiveArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTimeToLiveCalls(stub func(*dynamodba.DescribeTimeToLiveInput) (*dynamodba.DescribeTimeToLiveOutput, error)) {
	fake.describeTimeToLiveMutex.Lock()
	defer fake.describeTimeToLiveMutex.Unlock()
	fake.DescribeTimeToLiveStub = stub
}

func (fake *FakeDynamoDB) DescribeTimeToLiveArgsForCall(i int) *dynamodba.DescribeTimeToLiveInput {
	fake.describeTimeToLiveMutex.RLock()
	defer fake.describeTimeToLiveMutex.RUnlock()
	argsForCall := fake.describeTimeToLiveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeTimeToLiveReturns(result1 *dynamodba.DescribeTimeToLiveOutput, result2 error) {
	fake.describeTimeToLiveMutex.Lock()
	defer fake.describeTimeToLiveMutex.Unlock()
	fake.DescribeTimeToLiveStub = nil
	fake.describeTimeToLiveReturns = struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTimeToLiveReturnsOnCall(i int, result1 *dynamodba.DescribeTimeToLiveOutput, result2 error) {
	fake.describeTimeToLiveMutex.Lock()
	defer fake.describeTimeToLiveMutex.Unlock()
	fake.DescribeTimeToLiveStub = nil
	if fake.describeTimeToLiveReturnsOnCall == nil {
		fake.describeTimeToLiveReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeTimeToLiveOutput
			result2 error
		})
	}
	fake.describeTimeToLiveReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTimeToLiveRequest(arg1 *dynamodba.DescribeTimeToLiveInput) (*request.Request, *dynamodba.DescribeTimeToLiveOutput) {
	fake.describeTimeToLiveRequestMutex.Lock()
	ret, specificReturn := fake.describeTimeToLiveRequestReturnsOnCall[len(fake.describeTimeToLiveRequestArgsForCall)]
	fake.describeTimeToLiveRequestArgsForCall = append(fake.describeTimeToLiveRequestArgsForCall, struct {
		arg1 *dynamodba.DescribeTimeToLiveInput
	}{arg1})
	fake.recordInvocation("DescribeTimeToLiveRequest", []interface{}{arg1})
	fake.describeTimeToLiveRequestMutex.Unlock()
	if fake.DescribeTimeToLiveRequestStub != nil {
		return fake.DescribeTimeToLiveRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTimeToLiveRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTimeToLiveRequestCallCount() int {
	fake.describeTimeToLiveRequestMutex.RLock()
	defer fake.describeTimeToLiveRequestMutex.RUnlock()
	return len(fake.describeTimeToLiveRequestArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTimeToLiveRequestCalls(stub func(*dynamodba.DescribeTimeToLiveInput) (*request.Request, *dynamodba.DescribeTimeToLiveOutput)) {
	fake.describeTimeToLiveRequestMutex.Lock()
	defer fake.describeTimeToLiveRequestMutex.Unlock()
	fake.DescribeTimeToLiveRequestStub = stub
}

func (fake *FakeDynamoDB) DescribeTimeToLiveRequestArgsForCall(i int) *dynamodba.DescribeTimeToLiveInput {
	fake.describeTimeToLiveRequestMutex.RLock()
	defer fake.describeTimeToLiveRequestMutex.RUnlock()
	argsForCall := fake.describeTimeToLiveRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DescribeTimeToLiveRequestReturns(result1 *request.Request, result2 *dynamodba.DescribeTimeToLiveOutput) {
	fake.describeTimeToLiveRequestMutex.Lock()
	defer fake.describeTimeToLiveRequestMutex.Unlock()
	fake.DescribeTimeToLiveRequestStub = nil
	fake.describeTimeToLiveRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTimeToLiveOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTimeToLiveRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DescribeTimeToLiveOutput) {
	fake.describeTimeToLiveRequestMutex.Lock()
	defer fake.describeTimeToLiveRequestMutex.Unlock()
	fake.DescribeTimeToLiveRequestStub = nil
	if fake.describeTimeToLiveRequestReturnsOnCall == nil {
		fake.describeTimeToLiveRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DescribeTimeToLiveOutput
		})
	}
	fake.describeTimeToLiveRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DescribeTimeToLiveOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTimeToLiveWithContext(arg1 context.Context, arg2 *dynamodba.DescribeTimeToLiveInput, arg3 ...request.Option) (*dynamodba.DescribeTimeToLiveOutput, error) {
	fake.describeTimeToLiveWithContextMutex.Lock()
	ret, specificReturn := fake.describeTimeToLiveWithContextReturnsOnCall[len(fake.describeTimeToLiveWithContextArgsForCall)]
	fake.describeTimeToLiveWithContextArgsForCall = append(fake.describeTimeToLiveWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTimeToLiveInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DescribeTimeToLiveWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeTimeToLiveWithContextMutex.Unlock()
	if fake.DescribeTimeToLiveWithContextStub != nil {
		return fake.DescribeTimeToLiveWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.describeTimeToLiveWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DescribeTimeToLiveWithContextCallCount() int {
	fake.describeTimeToLiveWithContextMutex.RLock()
	defer fake.describeTimeToLiveWithContextMutex.RUnlock()
	return len(fake.describeTimeToLiveWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DescribeTimeToLiveWithContextCalls(stub func(context.Context, *dynamodba.DescribeTimeToLiveInput, ...request.Option) (*dynamodba.DescribeTimeToLiveOutput, error)) {
	fake.describeTimeToLiveWithContextMutex.Lock()
	defer fake.describeTimeToLiveWithContextMutex.Unlock()
	fake.DescribeTimeToLiveWithContextStub = stub
}

func (fake *FakeDynamoDB) DescribeTimeToLiveWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeTimeToLiveInput, []request.Option) {
	fake.describeTimeToLiveWithContextMutex.RLock()
	defer fake.describeTimeToLiveWithContextMutex.RUnlock()
	argsForCall := fake.describeTimeToLiveWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DescribeTimeToLiveWithContextReturns(result1 *dynamodba.DescribeTimeToLiveOutput, result2 error) {
	fake.describeTimeToLiveWithContextMutex.Lock()
	defer fake.describeTimeToLiveWithContextMutex.Unlock()
	fake.DescribeTimeToLiveWithContextStub = nil
	fake.describeTimeToLiveWithContextReturns = struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DescribeTimeToLiveWithContextReturnsOnCall(i int, result1 *dynamodba.DescribeTimeToLiveOutput, result2 error) {
	fake.describeTimeToLiveWithContextMutex.Lock()
	defer fake.describeTimeToLiveWithContextMutex.Unlock()
	fake.DescribeTimeToLiveWithContextStub = nil
	if fake.describeTimeToLiveWithContextReturnsOnCall == nil {
		fake.describeTimeToLiveWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DescribeTimeToLiveOutput
			result2 error
		})
	}
	fake.describeTimeToLiveWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DescribeTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestination(arg1 *dynamodba.DisableKinesisStreamingDestinationInput) (*dynamodba.DisableKinesisStreamingDestinationOutput, error) {
	fake.disableKinesisStreamingDestinationMutex.Lock()
	ret, specificReturn := fake.disableKinesisStreamingDestinationReturnsOnCall[len(fake.disableKinesisStreamingDestinationArgsForCall)]
	fake.disableKinesisStreamingDestinationArgsForCall = append(fake.disableKinesisStreamingDestinationArgsForCall, struct {
		arg1 *dynamodba.DisableKinesisStreamingDestinationInput
	}{arg1})
	fake.recordInvocation("DisableKinesisStreamingDestination", []interface{}{arg1})
	fake.disableKinesisStreamingDestinationMutex.Unlock()
	if fake.DisableKinesisStreamingDestinationStub != nil {
		return fake.DisableKinesisStreamingDestinationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.disableKinesisStreamingDestinationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationCallCount() int {
	fake.disableKinesisStreamingDestinationMutex.RLock()
	defer fake.disableKinesisStreamingDestinationMutex.RUnlock()
	return len(fake.disableKinesisStreamingDestinationArgsForCall)
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationCalls(stub func(*dynamodba.DisableKinesisStreamingDestinationInput) (*dynamodba.DisableKinesisStreamingDestinationOutput, error)) {
	fake.disableKinesisStreamingDestinationMutex.Lock()
	defer fake.disableKinesisStreamingDestinationMutex.Unlock()
	fake.DisableKinesisStreamingDestinationStub = stub
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationArgsForCall(i int) *dynamodba.DisableKinesisStreamingDestinationInput {
	fake.disableKinesisStreamingDestinationMutex.RLock()
	defer fake.disableKinesisStreamingDestinationMutex.RUnlock()
	argsForCall := fake.disableKinesisStreamingDestinationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationReturns(result1 *dynamodba.DisableKinesisStreamingDestinationOutput, result2 error) {
	fake.disableKinesisStreamingDestinationMutex.Lock()
	defer fake.disableKinesisStreamingDestinationMutex.Unlock()
	fake.DisableKinesisStreamingDestinationStub = nil
	fake.disableKinesisStreamingDestinationReturns = struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationReturnsOnCall(i int, result1 *dynamodba.DisableKinesisStreamingDestinationOutput, result2 error) {
	fake.disableKinesisStreamingDestinationMutex.Lock()
	defer fake.disableKinesisStreamingDestinationMutex.Unlock()
	fake.DisableKinesisStreamingDestinationStub = nil
	if fake.disableKinesisStreamingDestinationReturnsOnCall == nil {
		fake.disableKinesisStreamingDestinationReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DisableKinesisStreamingDestinationOutput
			result2 error
		})
	}
	fake.disableKinesisStreamingDestinationReturnsOnCall[i] = struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationRequest(arg1 *dynamodba.DisableKinesisStreamingDestinationInput) (*request.Request, *dynamodba.DisableKinesisStreamingDestinationOutput) {
	fake.disableKinesisStreamingDestinationRequestMutex.Lock()
	ret, specificReturn := fake.disableKinesisStreamingDestinationRequestReturnsOnCall[len(fake.disableKinesisStreamingDestinationRequestArgsForCall)]
	fake.disableKinesisStreamingDestinationRequestArgsForCall = append(fake.disableKinesisStreamingDestinationRequestArgsForCall, struct {
		arg1 *dynamodba.DisableKinesisStreamingDestinationInput
	}{arg1})
	fake.recordInvocation("DisableKinesisStreamingDestinationRequest", []interface{}{arg1})
	fake.disableKinesisStreamingDestinationRequestMutex.Unlock()
	if fake.DisableKinesisStreamingDestinationRequestStub != nil {
		return fake.DisableKinesisStreamingDestinationRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.disableKinesisStreamingDestinationRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationRequestCallCount() int {
	fake.disableKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.disableKinesisStreamingDestinationRequestMutex.RUnlock()
	return len(fake.disableKinesisStreamingDestinationRequestArgsForCall)
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationRequestCalls(stub func(*dynamodba.DisableKinesisStreamingDestinationInput) (*request.Request, *dynamodba.DisableKinesisStreamingDestinationOutput)) {
	fake.disableKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.disableKinesisStreamingDestinationRequestMutex.Unlock()
	fake.DisableKinesisStreamingDestinationRequestStub = stub
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationRequestArgsForCall(i int) *dynamodba.DisableKinesisStreamingDestinationInput {
	fake.disableKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.disableKinesisStreamingDestinationRequestMutex.RUnlock()
	argsForCall := fake.disableKinesisStreamingDestinationRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationRequestReturns(result1 *request.Request, result2 *dynamodba.DisableKinesisStreamingDestinationOutput) {
	fake.disableKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.disableKinesisStreamingDestinationRequestMutex.Unlock()
	fake.DisableKinesisStreamingDestinationRequestStub = nil
	fake.disableKinesisStreamingDestinationRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.DisableKinesisStreamingDestinationOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.DisableKinesisStreamingDestinationOutput) {
	fake.disableKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.disableKinesisStreamingDestinationRequestMutex.Unlock()
	fake.DisableKinesisStreamingDestinationRequestStub = nil
	if fake.disableKinesisStreamingDestinationRequestReturnsOnCall == nil {
		fake.disableKinesisStreamingDestinationRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.DisableKinesisStreamingDestinationOutput
		})
	}
	fake.disableKinesisStreamingDestinationRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.DisableKinesisStreamingDestinationOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationWithContext(arg1 context.Context, arg2 *dynamodba.DisableKinesisStreamingDestinationInput, arg3 ...request.Option) (*dynamodba.DisableKinesisStreamingDestinationOutput, error) {
	fake.disableKinesisStreamingDestinationWithContextMutex.Lock()
	ret, specificReturn := fake.disableKinesisStreamingDestinationWithContextReturnsOnCall[len(fake.disableKinesisStreamingDestinationWithContextArgsForCall)]
	fake.disableKinesisStreamingDestinationWithContextArgsForCall = append(fake.disableKinesisStreamingDestinationWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DisableKinesisStreamingDestinationInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("DisableKinesisStreamingDestinationWithContext", []interface{}{arg1, arg2, arg3})
	fake.disableKinesisStreamingDestinationWithContextMutex.Unlock()
	if fake.DisableKinesisStreamingDestinationWithContextStub != nil {
		return fake.DisableKinesisStreamingDestinationWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.disableKinesisStreamingDestinationWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationWithContextCallCount() int {
	fake.disableKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.disableKinesisStreamingDestinationWithContextMutex.RUnlock()
	return len(fake.disableKinesisStreamingDestinationWithContextArgsForCall)
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationWithContextCalls(stub func(context.Context, *dynamodba.DisableKinesisStreamingDestinationInput, ...request.Option) (*dynamodba.DisableKinesisStreamingDestinationOutput, error)) {
	fake.disableKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.disableKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.DisableKinesisStreamingDestinationWithContextStub = stub
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationWithContextArgsForCall(i int) (context.Context, *dynamodba.DisableKinesisStreamingDestinationInput, []request.Option) {
	fake.disableKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.disableKinesisStreamingDestinationWithContextMutex.RUnlock()
	argsForCall := fake.disableKinesisStreamingDestinationWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationWithContextReturns(result1 *dynamodba.DisableKinesisStreamingDestinationOutput, result2 error) {
	fake.disableKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.disableKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.DisableKinesisStreamingDestinationWithContextStub = nil
	fake.disableKinesisStreamingDestinationWithContextReturns = struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) DisableKinesisStreamingDestinationWithContextReturnsOnCall(i int, result1 *dynamodba.DisableKinesisStreamingDestinationOutput, result2 error) {
	fake.disableKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.disableKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.DisableKinesisStreamingDestinationWithContextStub = nil
	if fake.disableKinesisStreamingDestinationWithContextReturnsOnCall == nil {
		fake.disableKinesisStreamingDestinationWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.DisableKinesisStreamingDestinationOutput
			result2 error
		})
	}
	fake.disableKinesisStreamingDestinationWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.DisableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestination(arg1 *dynamodba.EnableKinesisStreamingDestinationInput) (*dynamodba.EnableKinesisStreamingDestinationOutput, error) {
	fake.enableKinesisStreamingDestinationMutex.Lock()
	ret, specificReturn := fake.enableKinesisStreamingDestinationReturnsOnCall[len(fake.enableKinesisStreamingDestinationArgsForCall)]
	fake.enableKinesisStreamingDestinationArgsForCall = append(fake.enableKinesisStreamingDestinationArgsForCall, struct {
		arg1 *dynamodba.EnableKinesisStreamingDestinationInput
	}{arg1})
	fake.recordInvocation("EnableKinesisStreamingDestination", []interface{}{arg1})
	fake.enableKinesisStreamingDestinationMutex.Unlock()
	if fake.EnableKinesisStreamingDestinationStub != nil {
		return fake.EnableKinesisStreamingDestinationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.enableKinesisStreamingDestinationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationCallCount() int {
	fake.enableKinesisStreamingDestinationMutex.RLock()
	defer fake.enableKinesisStreamingDestinationMutex.RUnlock()
	return len(fake.enableKinesisStreamingDestinationArgsForCall)
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationCalls(stub func(*dynamodba.EnableKinesisStreamingDestinationInput) (*dynamodba.EnableKinesisStreamingDestinationOutput, error)) {
	fake.enableKinesisStreamingDestinationMutex.Lock()
	defer fake.enableKinesisStreamingDestinationMutex.Unlock()
	fake.EnableKinesisStreamingDestinationStub = stub
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationArgsForCall(i int) *dynamodba.EnableKinesisStreamingDestinationInput {
	fake.enableKinesisStreamingDestinationMutex.RLock()
	defer fake.enableKinesisStreamingDestinationMutex.RUnlock()
	argsForCall := fake.enableKinesisStreamingDestinationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationReturns(result1 *dynamodba.EnableKinesisStreamingDestinationOutput, result2 error) {
	fake.enableKinesisStreamingDestinationMutex.Lock()
	defer fake.enableKinesisStreamingDestinationMutex.Unlock()
	fake.EnableKinesisStreamingDestinationStub = nil
	fake.enableKinesisStreamingDestinationReturns = struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationReturnsOnCall(i int, result1 *dynamodba.EnableKinesisStreamingDestinationOutput, result2 error) {
	fake.enableKinesisStreamingDestinationMutex.Lock()
	defer fake.enableKinesisStreamingDestinationMutex.Unlock()
	fake.EnableKinesisStreamingDestinationStub = nil
	if fake.enableKinesisStreamingDestinationReturnsOnCall == nil {
		fake.enableKinesisStreamingDestinationReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.EnableKinesisStreamingDestinationOutput
			result2 error
		})
	}
	fake.enableKinesisStreamingDestinationReturnsOnCall[i] = struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationRequest(arg1 *dynamodba.EnableKinesisStreamingDestinationInput) (*request.Request, *dynamodba.EnableKinesisStreamingDestinationOutput) {
	fake.enableKinesisStreamingDestinationRequestMutex.Lock()
	ret, specificReturn := fake.enableKinesisStreamingDestinationRequestReturnsOnCall[len(fake.enableKinesisStreamingDestinationRequestArgsForCall)]
	fake.enableKinesisStreamingDestinationRequestArgsForCall = append(fake.enableKinesisStreamingDestinationRequestArgsForCall, struct {
		arg1 *dynamodba.EnableKinesisStreamingDestinationInput
	}{arg1})
	fake.recordInvocation("EnableKinesisStreamingDestinationRequest", []interface{}{arg1})
	fake.enableKinesisStreamingDestinationRequestMutex.Unlock()
	if fake.EnableKinesisStreamingDestinationRequestStub != nil {
		return fake.EnableKinesisStreamingDestinationRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.enableKinesisStreamingDestinationRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationRequestCallCount() int {
	fake.enableKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.enableKinesisStreamingDestinationRequestMutex.RUnlock()
	return len(fake.enableKinesisStreamingDestinationRequestArgsForCall)
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationRequestCalls(stub func(*dynamodba.EnableKinesisStreamingDestinationInput) (*request.Request, *dynamodba.EnableKinesisStreamingDestinationOutput)) {
	fake.enableKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.enableKinesisStreamingDestinationRequestMutex.Unlock()
	fake.EnableKinesisStreamingDestinationRequestStub = stub
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationRequestArgsForCall(i int) *dynamodba.EnableKinesisStreamingDestinationInput {
	fake.enableKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.enableKinesisStreamingDestinationRequestMutex.RUnlock()
	argsForCall := fake.enableKinesisStreamingDestinationRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationRequestReturns(result1 *request.Request, result2 *dynamodba.EnableKinesisStreamingDestinationOutput) {
	fake.enableKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.enableKinesisStreamingDestinationRequestMutex.Unlock()
	fake.EnableKinesisStreamingDestinationRequestStub = nil
	fake.enableKinesisStreamingDestinationRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.EnableKinesisStreamingDestinationOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.EnableKinesisStreamingDestinationOutput) {
	fake.enableKinesisStreamingDestinationRequestMutex.Lock()
	defer fake.enableKinesisStreamingDestinationRequestMutex.Unlock()
	fake.EnableKinesisStreamingDestinationRequestStub = nil
	if fake.enableKinesisStreamingDestinationRequestReturnsOnCall == nil {
		fake.enableKinesisStreamingDestinationRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.EnableKinesisStreamingDestinationOutput
		})
	}
	fake.enableKinesisStreamingDestinationRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.EnableKinesisStreamingDestinationOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationWithContext(arg1 context.Context, arg2 *dynamodba.EnableKinesisStreamingDestinationInput, arg3 ...request.Option) (*dynamodba.EnableKinesisStreamingDestinationOutput, error) {
	fake.enableKinesisStreamingDestinationWithContextMutex.Lock()
	ret, specificReturn := fake.enableKinesisStreamingDestinationWithContextReturnsOnCall[len(fake.enableKinesisStreamingDestinationWithContextArgsForCall)]
	fake.enableKinesisStreamingDestinationWithContextArgsForCall = append(fake.enableKinesisStreamingDestinationWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.EnableKinesisStreamingDestinationInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("EnableKinesisStreamingDestinationWithContext", []interface{}{arg1, arg2, arg3})
	fake.enableKinesisStreamingDestinationWithContextMutex.Unlock()
	if fake.EnableKinesisStreamingDestinationWithContextStub != nil {
		return fake.EnableKinesisStreamingDestinationWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.enableKinesisStreamingDestinationWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationWithContextCallCount() int {
	fake.enableKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.enableKinesisStreamingDestinationWithContextMutex.RUnlock()
	return len(fake.enableKinesisStreamingDestinationWithContextArgsForCall)
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationWithContextCalls(stub func(context.Context, *dynamodba.EnableKinesisStreamingDestinationInput, ...request.Option) (*dynamodba.EnableKinesisStreamingDestinationOutput, error)) {
	fake.enableKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.enableKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.EnableKinesisStreamingDestinationWithContextStub = stub
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationWithContextArgsForCall(i int) (context.Context, *dynamodba.EnableKinesisStreamingDestinationInput, []request.Option) {
	fake.enableKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.enableKinesisStreamingDestinationWithContextMutex.RUnlock()
	argsForCall := fake.enableKinesisStreamingDestinationWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationWithContextReturns(result1 *dynamodba.EnableKinesisStreamingDestinationOutput, result2 error) {
	fake.enableKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.enableKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.EnableKinesisStreamingDestinationWithContextStub = nil
	fake.enableKinesisStreamingDestinationWithContextReturns = struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) EnableKinesisStreamingDestinationWithContextReturnsOnCall(i int, result1 *dynamodba.EnableKinesisStreamingDestinationOutput, result2 error) {
	fake.enableKinesisStreamingDestinationWithContextMutex.Lock()
	defer fake.enableKinesisStreamingDestinationWithContextMutex.Unlock()
	fake.EnableKinesisStreamingDestinationWithContextStub = nil
	if fake.enableKinesisStreamingDestinationWithContextReturnsOnCall == nil {
		fake.enableKinesisStreamingDestinationWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.EnableKinesisStreamingDestinationOutput
			result2 error
		})
	}
	fake.enableKinesisStreamingDestinationWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.EnableKinesisStreamingDestinationOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteStatement(arg1 *dynamodba.ExecuteStatementInput) (*dynamodba.ExecuteStatementOutput, error) {
	fake.executeStatementMutex.Lock()
	ret, specificReturn := fake.executeStatementReturnsOnCall[len(fake.executeStatementArgsForCall)]
	fake.executeStatementArgsForCall = append(fake.executeStatementArgsForCall, struct {
		arg1 *dynamodba.ExecuteStatementInput
	}{arg1})
	fake.recordInvocation("ExecuteStatement", []interface{}{arg1})
	fake.executeStatementMutex.Unlock()
	if fake.ExecuteStatementStub != nil {
		return fake.ExecuteStatementStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeStatementReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExecuteStatementCallCount() int {
	fake.executeStatementMutex.RLock()
	defer fake.executeStatementMutex.RUnlock()
	return len(fake.executeStatementArgsForCall)
}

func (fake *FakeDynamoDB) ExecuteStatementCalls(stub func(*dynamodba.ExecuteStatementInput) (*dynamodba.ExecuteStatementOutput, error)) {
	fake.executeStatementMutex.Lock()
	defer fake.executeStatementMutex.Unlock()
	fake.ExecuteStatementStub = stub
}

func (fake *FakeDynamoDB) ExecuteStatementArgsForCall(i int) *dynamodba.ExecuteStatementInput {
	fake.executeStatementMutex.RLock()
	defer fake.executeStatementMutex.RUnlock()
	argsForCall := fake.executeStatementArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ExecuteStatementReturns(result1 *dynamodba.ExecuteStatementOutput, result2 error) {
	fake.executeStatementMutex.Lock()
	defer fake.executeStatementMutex.Unlock()
	fake.ExecuteStatementStub = nil
	fake.executeStatementReturns = struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteStatementReturnsOnCall(i int, result1 *dynamodba.ExecuteStatementOutput, result2 error) {
	fake.executeStatementMutex.Lock()
	defer fake.executeStatementMutex.Unlock()
	fake.ExecuteStatementStub = nil
	if fake.executeStatementReturnsOnCall == nil {
		fake.executeStatementReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ExecuteStatementOutput
			result2 error
		})
	}
	fake.executeStatementReturnsOnCall[i] = struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteStatementRequest(arg1 *dynamodba.ExecuteStatementInput) (*request.Request, *dynamodba.ExecuteStatementOutput) {
	fake.executeStatementRequestMutex.Lock()
	ret, specificReturn := fake.executeStatementRequestReturnsOnCall[len(fake.executeStatementRequestArgsForCall)]
	fake.executeStatementRequestArgsForCall = append(fake.executeStatementRequestArgsForCall, struct {
		arg1 *dynamodba.ExecuteStatementInput
	}{arg1})
	fake.recordInvocation("ExecuteStatementRequest", []interface{}{arg1})
	fake.executeStatementRequestMutex.Unlock()
	if fake.ExecuteStatementRequestStub != nil {
		return fake.ExecuteStatementRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeStatementRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExecuteStatementRequestCallCount() int {
	fake.executeStatementRequestMutex.RLock()
	defer fake.executeStatementRequestMutex.RUnlock()
	return len(fake.executeStatementRequestArgsForCall)
}

func (fake *FakeDynamoDB) ExecuteStatementRequestCalls(stub func(*dynamodba.ExecuteStatementInput) (*request.Request, *dynamodba.ExecuteStatementOutput)) {
	fake.executeStatementRequestMutex.Lock()
	defer fake.executeStatementRequestMutex.Unlock()
	fake.ExecuteStatementRequestStub = stub
}

func (fake *FakeDynamoDB) ExecuteStatementRequestArgsForCall(i int) *dynamodba.ExecuteStatementInput {
	fake.executeStatementRequestMutex.RLock()
	defer fake.executeStatementRequestMutex.RUnlock()
	argsForCall := fake.executeStatementRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ExecuteStatementRequestReturns(result1 *request.Request, result2 *dynamodba.ExecuteStatementOutput) {
	fake.executeStatementRequestMutex.Lock()
	defer fake.executeStatementRequestMutex.Unlock()
	fake.ExecuteStatementRequestStub = nil
	fake.executeStatementRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteStatementOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteStatementRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ExecuteStatementOutput) {
	fake.executeStatementRequestMutex.Lock()
	defer fake.executeStatementRequestMutex.Unlock()
	fake.ExecuteStatementRequestStub = nil
	if fake.executeStatementRequestReturnsOnCall == nil {
		fake.executeStatementRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ExecuteStatementOutput
		})
	}
	fake.executeStatementRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteStatementOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteStatementWithContext(arg1 context.Context, arg2 *dynamodba.ExecuteStatementInput, arg3 ...request.Option) (*dynamodba.ExecuteStatementOutput, error) {
	fake.executeStatementWithContextMutex.Lock()
	ret, specificReturn := fake.executeStatementWithContextReturnsOnCall[len(fake.executeStatementWithContextArgsForCall)]
	fake.executeStatementWithContextArgsForCall = append(fake.executeStatementWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ExecuteStatementInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ExecuteStatementWithContext", []interface{}{arg1, arg2, arg3})
	fake.executeStatementWithContextMutex.Unlock()
	if fake.ExecuteStatementWithContextStub != nil {
		return fake.ExecuteStatementWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeStatementWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExecuteStatementWithContextCallCount() int {
	fake.executeStatementWithContextMutex.RLock()
	defer fake.executeStatementWithContextMutex.RUnlock()
	return len(fake.executeStatementWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ExecuteStatementWithContextCalls(stub func(context.Context, *dynamodba.ExecuteStatementInput, ...request.Option) (*dynamodba.ExecuteStatementOutput, error)) {
	fake.executeStatementWithContextMutex.Lock()
	defer fake.executeStatementWithContextMutex.Unlock()
	fake.ExecuteStatementWithContextStub = stub
}

func (fake *FakeDynamoDB) ExecuteStatementWithContextArgsForCall(i int) (context.Context, *dynamodba.ExecuteStatementInput, []request.Option) {
	fake.executeStatementWithContextMutex.RLock()
	defer fake.executeStatementWithContextMutex.RUnlock()
	argsForCall := fake.executeStatementWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ExecuteStatementWithContextReturns(result1 *dynamodba.ExecuteStatementOutput, result2 error) {
	fake.executeStatementWithContextMutex.Lock()
	defer fake.executeStatementWithContextMutex.Unlock()
	fake.ExecuteStatementWithContextStub = nil
	fake.executeStatementWithContextReturns = struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteStatementWithContextReturnsOnCall(i int, result1 *dynamodba.ExecuteStatementOutput, result2 error) {
	fake.executeStatementWithContextMutex.Lock()
	defer fake.executeStatementWithContextMutex.Unlock()
	fake.ExecuteStatementWithContextStub = nil
	if fake.executeStatementWithContextReturnsOnCall == nil {
		fake.executeStatementWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ExecuteStatementOutput
			result2 error
		})
	}
	fake.executeStatementWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ExecuteStatementOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteTransaction(arg1 *dynamodba.ExecuteTransactionInput) (*dynamodba.ExecuteTransactionOutput, error) {
	fake.executeTransactionMutex.Lock()
	ret, specificReturn := fake.executeTransactionReturnsOnCall[len(fake.executeTransactionArgsForCall)]
	fake.executeTransactionArgsForCall = append(fake.executeTransactionArgsForCall, struct {
		arg1 *dynamodba.ExecuteTransactionInput
	}{arg1})
	fake.recordInvocation("ExecuteTransaction", []interface{}{arg1})
	fake.executeTransactionMutex.Unlock()
	if fake.ExecuteTransactionStub != nil {
		return fake.ExecuteTransactionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExecuteTransactionCallCount() int {
	fake.executeTransactionMutex.RLock()
	defer fake.executeTransactionMutex.RUnlock()
	return len(fake.executeTransactionArgsForCall)
}

func (fake *FakeDynamoDB) ExecuteTransactionCalls(stub func(*dynamodba.ExecuteTransactionInput) (*dynamodba.ExecuteTransactionOutput, error)) {
	fake.executeTransactionMutex.Lock()
	defer fake.executeTransactionMutex.Unlock()
	fake.ExecuteTransactionStub = stub
}

func (fake *FakeDynamoDB) ExecuteTransactionArgsForCall(i int) *dynamodba.ExecuteTransactionInput {
	fake.executeTransactionMutex.RLock()
	defer fake.executeTransactionMutex.RUnlock()
	argsForCall := fake.executeTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ExecuteTransactionReturns(result1 *dynamodba.ExecuteTransactionOutput, result2 error) {
	fake.executeTransactionMutex.Lock()
	defer fake.executeTransactionMutex.Unlock()
	fake.ExecuteTransactionStub = nil
	fake.executeTransactionReturns = struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteTransactionReturnsOnCall(i int, result1 *dynamodba.ExecuteTransactionOutput, result2 error) {
	fake.executeTransactionMutex.Lock()
	defer fake.executeTransactionMutex.Unlock()
	fake.ExecuteTransactionStub = nil
	if fake.executeTransactionReturnsOnCall == nil {
		fake.executeTransactionReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ExecuteTransactionOutput
			result2 error
		})
	}
	fake.executeTransactionReturnsOnCall[i] = struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteTransactionRequest(arg1 *dynamodba.ExecuteTransactionInput) (*request.Request, *dynamodba.ExecuteTransactionOutput) {
	fake.executeTransactionRequestMutex.Lock()
	ret, specificReturn := fake.executeTransactionRequestReturnsOnCall[len(fake.executeTransactionRequestArgsForCall)]
	fake.executeTransactionRequestArgsForCall = append(fake.executeTransactionRequestArgsForCall, struct {
		arg1 *dynamodba.ExecuteTransactionInput
	}{arg1})
	fake.recordInvocation("ExecuteTransactionRequest", []interface{}{arg1})
	fake.executeTransactionRequestMutex.Unlock()
	if fake.ExecuteTransactionRequestStub != nil {
		return fake.ExecuteTransactionRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeTransactionRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExecuteTransactionRequestCallCount() int {
	fake.executeTransactionRequestMutex.RLock()
	defer fake.executeTransactionRequestMutex.RUnlock()
	return len(fake.executeTransactionRequestArgsForCall)
}

func (fake *FakeDynamoDB) ExecuteTransactionRequestCalls(stub func(*dynamodba.ExecuteTransactionInput) (*request.Request, *dynamodba.ExecuteTransactionOutput)) {
	fake.executeTransactionRequestMutex.Lock()
	defer fake.executeTransactionRequestMutex.Unlock()
	fake.ExecuteTransactionRequestStub = stub
}

func (fake *FakeDynamoDB) ExecuteTransactionRequestArgsForCall(i int) *dynamodba.ExecuteTransactionInput {
	fake.executeTransactionRequestMutex.RLock()
	defer fake.executeTransactionRequestMutex.RUnlock()
	argsForCall := fake.executeTransactionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ExecuteTransactionRequestReturns(result1 *request.Request, result2 *dynamodba.ExecuteTransactionOutput) {
	fake.executeTransactionRequestMutex.Lock()
	defer fake.executeTransactionRequestMutex.Unlock()
	fake.ExecuteTransactionRequestStub = nil
	fake.executeTransactionRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteTransactionOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteTransactionRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ExecuteTransactionOutput) {
	fake.executeTransactionRequestMutex.Lock()
	defer fake.executeTransactionRequestMutex.Unlock()
	fake.ExecuteTransactionRequestStub = nil
	if fake.executeTransactionRequestReturnsOnCall == nil {
		fake.executeTransactionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ExecuteTransactionOutput
		})
	}
	fake.executeTransactionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ExecuteTransactionOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteTransactionWithContext(arg1 context.Context, arg2 *dynamodba.ExecuteTransactionInput, arg3 ...request.Option) (*dynamodba.ExecuteTransactionOutput, error) {
	fake.executeTransactionWithContextMutex.Lock()
	ret, specificReturn := fake.executeTransactionWithContextReturnsOnCall[len(fake.executeTransactionWithContextArgsForCall)]
	fake.executeTransactionWithContextArgsForCall = append(fake.executeTransactionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ExecuteTransactionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ExecuteTransactionWithContext", []interface{}{arg1, arg2, arg3})
	fake.executeTransactionWithContextMutex.Unlock()
	if fake.ExecuteTransactionWithContextStub != nil {
		return fake.ExecuteTransactionWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeTransactionWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExecuteTransactionWithContextCallCount() int {
	fake.executeTransactionWithContextMutex.RLock()
	defer fake.executeTransactionWithContextMutex.RUnlock()
	return len(fake.executeTransactionWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ExecuteTransactionWithContextCalls(stub func(context.Context, *dynamodba.ExecuteTransactionInput, ...request.Option) (*dynamodba.ExecuteTransactionOutput, error)) {
	fake.executeTransactionWithContextMutex.Lock()
	defer fake.executeTransactionWithContextMutex.Unlock()
	fake.ExecuteTransactionWithContextStub = stub
}

func (fake *FakeDynamoDB) ExecuteTransactionWithContextArgsForCall(i int) (context.Context, *dynamodba.ExecuteTransactionInput, []request.Option) {
	fake.executeTransactionWithContextMutex.RLock()
	defer fake.executeTransactionWithContextMutex.RUnlock()
	argsForCall := fake.executeTransactionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ExecuteTransactionWithContextReturns(result1 *dynamodba.ExecuteTransactionOutput, result2 error) {
	fake.executeTransactionWithContextMutex.Lock()
	defer fake.executeTransactionWithContextMutex.Unlock()
	fake.ExecuteTransactionWithContextStub = nil
	fake.executeTransactionWithContextReturns = struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExecuteTransactionWithContextReturnsOnCall(i int, result1 *dynamodba.ExecuteTransactionOutput, result2 error) {
	fake.executeTransactionWithContextMutex.Lock()
	defer fake.executeTransactionWithContextMutex.Unlock()
	fake.ExecuteTransactionWithContextStub = nil
	if fake.executeTransactionWithContextReturnsOnCall == nil {
		fake.executeTransactionWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ExecuteTransactionOutput
			result2 error
		})
	}
	fake.executeTransactionWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ExecuteTransactionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExportTableToPointInTime(arg1 *dynamodba.ExportTableToPointInTimeInput) (*dynamodba.ExportTableToPointInTimeOutput, error) {
	fake.exportTableToPointInTimeMutex.Lock()
	ret, specificReturn := fake.exportTableToPointInTimeReturnsOnCall[len(fake.exportTableToPointInTimeArgsForCall)]
	fake.exportTableToPointInTimeArgsForCall = append(fake.exportTableToPointInTimeArgsForCall, struct {
		arg1 *dynamodba.ExportTableToPointInTimeInput
	}{arg1})
	fake.recordInvocation("ExportTableToPointInTime", []interface{}{arg1})
	fake.exportTableToPointInTimeMutex.Unlock()
	if fake.ExportTableToPointInTimeStub != nil {
		return fake.ExportTableToPointInTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exportTableToPointInTimeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeCallCount() int {
	fake.exportTableToPointInTimeMutex.RLock()
	defer fake.exportTableToPointInTimeMutex.RUnlock()
	return len(fake.exportTableToPointInTimeArgsForCall)
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeCalls(stub func(*dynamodba.ExportTableToPointInTimeInput) (*dynamodba.ExportTableToPointInTimeOutput, error)) {
	fake.exportTableToPointInTimeMutex.Lock()
	defer fake.exportTableToPointInTimeMutex.Unlock()
	fake.ExportTableToPointInTimeStub = stub
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeArgsForCall(i int) *dynamodba.ExportTableToPointInTimeInput {
	fake.exportTableToPointInTimeMutex.RLock()
	defer fake.exportTableToPointInTimeMutex.RUnlock()
	argsForCall := fake.exportTableToPointInTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeReturns(result1 *dynamodba.ExportTableToPointInTimeOutput, result2 error) {
	fake.exportTableToPointInTimeMutex.Lock()
	defer fake.exportTableToPointInTimeMutex.Unlock()
	fake.ExportTableToPointInTimeStub = nil
	fake.exportTableToPointInTimeReturns = struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeReturnsOnCall(i int, result1 *dynamodba.ExportTableToPointInTimeOutput, result2 error) {
	fake.exportTableToPointInTimeMutex.Lock()
	defer fake.exportTableToPointInTimeMutex.Unlock()
	fake.ExportTableToPointInTimeStub = nil
	if fake.exportTableToPointInTimeReturnsOnCall == nil {
		fake.exportTableToPointInTimeReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ExportTableToPointInTimeOutput
			result2 error
		})
	}
	fake.exportTableToPointInTimeReturnsOnCall[i] = struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeRequest(arg1 *dynamodba.ExportTableToPointInTimeInput) (*request.Request, *dynamodba.ExportTableToPointInTimeOutput) {
	fake.exportTableToPointInTimeRequestMutex.Lock()
	ret, specificReturn := fake.exportTableToPointInTimeRequestReturnsOnCall[len(fake.exportTableToPointInTimeRequestArgsForCall)]
	fake.exportTableToPointInTimeRequestArgsForCall = append(fake.exportTableToPointInTimeRequestArgsForCall, struct {
		arg1 *dynamodba.ExportTableToPointInTimeInput
	}{arg1})
	fake.recordInvocation("ExportTableToPointInTimeRequest", []interface{}{arg1})
	fake.exportTableToPointInTimeRequestMutex.Unlock()
	if fake.ExportTableToPointInTimeRequestStub != nil {
		return fake.ExportTableToPointInTimeRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exportTableToPointInTimeRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeRequestCallCount() int {
	fake.exportTableToPointInTimeRequestMutex.RLock()
	defer fake.exportTableToPointInTimeRequestMutex.RUnlock()
	return len(fake.exportTableToPointInTimeRequestArgsForCall)
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeRequestCalls(stub func(*dynamodba.ExportTableToPointInTimeInput) (*request.Request, *dynamodba.ExportTableToPointInTimeOutput)) {
	fake.exportTableToPointInTimeRequestMutex.Lock()
	defer fake.exportTableToPointInTimeRequestMutex.Unlock()
	fake.ExportTableToPointInTimeRequestStub = stub
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeRequestArgsForCall(i int) *dynamodba.ExportTableToPointInTimeInput {
	fake.exportTableToPointInTimeRequestMutex.RLock()
	defer fake.exportTableToPointInTimeRequestMutex.RUnlock()
	argsForCall := fake.exportTableToPointInTimeRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeRequestReturns(result1 *request.Request, result2 *dynamodba.ExportTableToPointInTimeOutput) {
	fake.exportTableToPointInTimeRequestMutex.Lock()
	defer fake.exportTableToPointInTimeRequestMutex.Unlock()
	fake.ExportTableToPointInTimeRequestStub = nil
	fake.exportTableToPointInTimeRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ExportTableToPointInTimeOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ExportTableToPointInTimeOutput) {
	fake.exportTableToPointInTimeRequestMutex.Lock()
	defer fake.exportTableToPointInTimeRequestMutex.Unlock()
	fake.ExportTableToPointInTimeRequestStub = nil
	if fake.exportTableToPointInTimeRequestReturnsOnCall == nil {
		fake.exportTableToPointInTimeRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ExportTableToPointInTimeOutput
		})
	}
	fake.exportTableToPointInTimeRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ExportTableToPointInTimeOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeWithContext(arg1 context.Context, arg2 *dynamodba.ExportTableToPointInTimeInput, arg3 ...request.Option) (*dynamodba.ExportTableToPointInTimeOutput, error) {
	fake.exportTableToPointInTimeWithContextMutex.Lock()
	ret, specificReturn := fake.exportTableToPointInTimeWithContextReturnsOnCall[len(fake.exportTableToPointInTimeWithContextArgsForCall)]
	fake.exportTableToPointInTimeWithContextArgsForCall = append(fake.exportTableToPointInTimeWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ExportTableToPointInTimeInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ExportTableToPointInTimeWithContext", []interface{}{arg1, arg2, arg3})
	fake.exportTableToPointInTimeWithContextMutex.Unlock()
	if fake.ExportTableToPointInTimeWithContextStub != nil {
		return fake.ExportTableToPointInTimeWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exportTableToPointInTimeWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeWithContextCallCount() int {
	fake.exportTableToPointInTimeWithContextMutex.RLock()
	defer fake.exportTableToPointInTimeWithContextMutex.RUnlock()
	return len(fake.exportTableToPointInTimeWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeWithContextCalls(stub func(context.Context, *dynamodba.ExportTableToPointInTimeInput, ...request.Option) (*dynamodba.ExportTableToPointInTimeOutput, error)) {
	fake.exportTableToPointInTimeWithContextMutex.Lock()
	defer fake.exportTableToPointInTimeWithContextMutex.Unlock()
	fake.ExportTableToPointInTimeWithContextStub = stub
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeWithContextArgsForCall(i int) (context.Context, *dynamodba.ExportTableToPointInTimeInput, []request.Option) {
	fake.exportTableToPointInTimeWithContextMutex.RLock()
	defer fake.exportTableToPointInTimeWithContextMutex.RUnlock()
	argsForCall := fake.exportTableToPointInTimeWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeWithContextReturns(result1 *dynamodba.ExportTableToPointInTimeOutput, result2 error) {
	fake.exportTableToPointInTimeWithContextMutex.Lock()
	defer fake.exportTableToPointInTimeWithContextMutex.Unlock()
	fake.ExportTableToPointInTimeWithContextStub = nil
	fake.exportTableToPointInTimeWithContextReturns = struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ExportTableToPointInTimeWithContextReturnsOnCall(i int, result1 *dynamodba.ExportTableToPointInTimeOutput, result2 error) {
	fake.exportTableToPointInTimeWithContextMutex.Lock()
	defer fake.exportTableToPointInTimeWithContextMutex.Unlock()
	fake.ExportTableToPointInTimeWithContextStub = nil
	if fake.exportTableToPointInTimeWithContextReturnsOnCall == nil {
		fake.exportTableToPointInTimeWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ExportTableToPointInTimeOutput
			result2 error
		})
	}
	fake.exportTableToPointInTimeWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ExportTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) GetItem(arg1 *dynamodba.GetItemInput) (*dynamodba.GetItemOutput, error) {
	fake.getItemMutex.Lock()
	ret, specificReturn := fake.getItemReturnsOnCall[len(fake.getItemArgsForCall)]
	fake.getItemArgsForCall = append(fake.getItemArgsForCall, struct {
		arg1 *dynamodba.GetItemInput
	}{arg1})
	fake.recordInvocation("GetItem", []interface{}{arg1})
	fake.getItemMutex.Unlock()
	if fake.GetItemStub != nil {
		return fake.GetItemStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getItemReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) GetItemCallCount() int {
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	return len(fake.getItemArgsForCall)
}

func (fake *FakeDynamoDB) GetItemCalls(stub func(*dynamodba.GetItemInput) (*dynamodba.GetItemOutput, error)) {
	fake.getItemMutex.Lock()
	defer fake.getItemMutex.Unlock()
	fake.GetItemStub = stub
}

func (fake *FakeDynamoDB) GetItemArgsForCall(i int) *dynamodba.GetItemInput {
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	argsForCall := fake.getItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) GetItemReturns(result1 *dynamodba.GetItemOutput, result2 error) {
	fake.getItemMutex.Lock()
	defer fake.getItemMutex.Unlock()
	fake.GetItemStub = nil
	fake.getItemReturns = struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) GetItemReturnsOnCall(i int, result1 *dynamodba.GetItemOutput, result2 error) {
	fake.getItemMutex.Lock()
	defer fake.getItemMutex.Unlock()
	fake.GetItemStub = nil
	if fake.getItemReturnsOnCall == nil {
		fake.getItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.GetItemOutput
			result2 error
		})
	}
	fake.getItemReturnsOnCall[i] = struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) GetItemRequest(arg1 *dynamodba.GetItemInput) (*request.Request, *dynamodba.GetItemOutput) {
	fake.getItemRequestMutex.Lock()
	ret, specificReturn := fake.getItemRequestReturnsOnCall[len(fake.getItemRequestArgsForCall)]
	fake.getItemRequestArgsForCall = append(fake.getItemRequestArgsForCall, struct {
		arg1 *dynamodba.GetItemInput
	}{arg1})
	fake.recordInvocation("GetItemRequest", []interface{}{arg1})
	fake.getItemRequestMutex.Unlock()
	if fake.GetItemRequestStub != nil {
		return fake.GetItemRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getItemRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) GetItemRequestCallCount() int {
	fake.getItemRequestMutex.RLock()
	defer fake.getItemRequestMutex.RUnlock()
	return len(fake.getItemRequestArgsForCall)
}

func (fake *FakeDynamoDB) GetItemRequestCalls(stub func(*dynamodba.GetItemInput) (*request.Request, *dynamodba.GetItemOutput)) {
	fake.getItemRequestMutex.Lock()
	defer fake.getItemRequestMutex.Unlock()
	fake.GetItemRequestStub = stub
}

func (fake *FakeDynamoDB) GetItemRequestArgsForCall(i int) *dynamodba.GetItemInput {
	fake.getItemRequestMutex.RLock()
	defer fake.getItemRequestMutex.RUnlock()
	argsForCall := fake.getItemRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) GetItemRequestReturns(result1 *request.Request, result2 *dynamodba.GetItemOutput) {
	fake.getItemRequestMutex.Lock()
	defer fake.getItemRequestMutex.Unlock()
	fake.GetItemRequestStub = nil
	fake.getItemRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.GetItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) GetItemRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.GetItemOutput) {
	fake.getItemRequestMutex.Lock()
	defer fake.getItemRequestMutex.Unlock()
	fake.GetItemRequestStub = nil
	if fake.getItemRequestReturnsOnCall == nil {
		fake.getItemRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.GetItemOutput
		})
	}
	fake.getItemRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.GetItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) GetItemWithContext(arg1 context.Context, arg2 *dynamodba.GetItemInput, arg3 ...request.Option) (*dynamodba.GetItemOutput, error) {
	fake.getItemWithContextMutex.Lock()
	ret, specificReturn := fake.getItemWithContextReturnsOnCall[len(fake.getItemWithContextArgsForCall)]
	fake.getItemWithContextArgsForCall = append(fake.getItemWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.GetItemInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetItemWithContext", []interface{}{arg1, arg2, arg3})
	fake.getItemWithContextMutex.Unlock()
	if fake.GetItemWithContextStub != nil {
		return fake.GetItemWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getItemWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) GetItemWithContextCallCount() int {
	fake.getItemWithContextMutex.RLock()
	defer fake.getItemWithContextMutex.RUnlock()
	return len(fake.getItemWithContextArgsForCall)
}

func (fake *FakeDynamoDB) GetItemWithContextCalls(stub func(context.Context, *dynamodba.GetItemInput, ...request.Option) (*dynamodba.GetItemOutput, error)) {
	fake.getItemWithContextMutex.Lock()
	defer fake.getItemWithContextMutex.Unlock()
	fake.GetItemWithContextStub = stub
}

func (fake *FakeDynamoDB) GetItemWithContextArgsForCall(i int) (context.Context, *dynamodba.GetItemInput, []request.Option) {
	fake.getItemWithContextMutex.RLock()
	defer fake.getItemWithContextMutex.RUnlock()
	argsForCall := fake.getItemWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) GetItemWithContextReturns(result1 *dynamodba.GetItemOutput, result2 error) {
	fake.getItemWithContextMutex.Lock()
	defer fake.getItemWithContextMutex.Unlock()
	fake.GetItemWithContextStub = nil
	fake.getItemWithContextReturns = struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) GetItemWithContextReturnsOnCall(i int, result1 *dynamodba.GetItemOutput, result2 error) {
	fake.getItemWithContextMutex.Lock()
	defer fake.getItemWithContextMutex.Unlock()
	fake.GetItemWithContextStub = nil
	if fake.getItemWithContextReturnsOnCall == nil {
		fake.getItemWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.GetItemOutput
			result2 error
		})
	}
	fake.getItemWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.GetItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListBackups(arg1 *dynamodba.ListBackupsInput) (*dynamodba.ListBackupsOutput, error) {
	fake.listBackupsMutex.Lock()
	ret, specificReturn := fake.listBackupsReturnsOnCall[len(fake.listBackupsArgsForCall)]
	fake.listBackupsArgsForCall = append(fake.listBackupsArgsForCall, struct {
		arg1 *dynamodba.ListBackupsInput
	}{arg1})
	fake.recordInvocation("ListBackups", []interface{}{arg1})
	fake.listBackupsMutex.Unlock()
	if fake.ListBackupsStub != nil {
		return fake.ListBackupsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBackupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListBackupsCallCount() int {
	fake.listBackupsMutex.RLock()
	defer fake.listBackupsMutex.RUnlock()
	return len(fake.listBackupsArgsForCall)
}

func (fake *FakeDynamoDB) ListBackupsCalls(stub func(*dynamodba.ListBackupsInput) (*dynamodba.ListBackupsOutput, error)) {
	fake.listBackupsMutex.Lock()
	defer fake.listBackupsMutex.Unlock()
	fake.ListBackupsStub = stub
}

func (fake *FakeDynamoDB) ListBackupsArgsForCall(i int) *dynamodba.ListBackupsInput {
	fake.listBackupsMutex.RLock()
	defer fake.listBackupsMutex.RUnlock()
	argsForCall := fake.listBackupsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListBackupsReturns(result1 *dynamodba.ListBackupsOutput, result2 error) {
	fake.listBackupsMutex.Lock()
	defer fake.listBackupsMutex.Unlock()
	fake.ListBackupsStub = nil
	fake.listBackupsReturns = struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListBackupsReturnsOnCall(i int, result1 *dynamodba.ListBackupsOutput, result2 error) {
	fake.listBackupsMutex.Lock()
	defer fake.listBackupsMutex.Unlock()
	fake.ListBackupsStub = nil
	if fake.listBackupsReturnsOnCall == nil {
		fake.listBackupsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListBackupsOutput
			result2 error
		})
	}
	fake.listBackupsReturnsOnCall[i] = struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListBackupsRequest(arg1 *dynamodba.ListBackupsInput) (*request.Request, *dynamodba.ListBackupsOutput) {
	fake.listBackupsRequestMutex.Lock()
	ret, specificReturn := fake.listBackupsRequestReturnsOnCall[len(fake.listBackupsRequestArgsForCall)]
	fake.listBackupsRequestArgsForCall = append(fake.listBackupsRequestArgsForCall, struct {
		arg1 *dynamodba.ListBackupsInput
	}{arg1})
	fake.recordInvocation("ListBackupsRequest", []interface{}{arg1})
	fake.listBackupsRequestMutex.Unlock()
	if fake.ListBackupsRequestStub != nil {
		return fake.ListBackupsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBackupsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListBackupsRequestCallCount() int {
	fake.listBackupsRequestMutex.RLock()
	defer fake.listBackupsRequestMutex.RUnlock()
	return len(fake.listBackupsRequestArgsForCall)
}

func (fake *FakeDynamoDB) ListBackupsRequestCalls(stub func(*dynamodba.ListBackupsInput) (*request.Request, *dynamodba.ListBackupsOutput)) {
	fake.listBackupsRequestMutex.Lock()
	defer fake.listBackupsRequestMutex.Unlock()
	fake.ListBackupsRequestStub = stub
}

func (fake *FakeDynamoDB) ListBackupsRequestArgsForCall(i int) *dynamodba.ListBackupsInput {
	fake.listBackupsRequestMutex.RLock()
	defer fake.listBackupsRequestMutex.RUnlock()
	argsForCall := fake.listBackupsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListBackupsRequestReturns(result1 *request.Request, result2 *dynamodba.ListBackupsOutput) {
	fake.listBackupsRequestMutex.Lock()
	defer fake.listBackupsRequestMutex.Unlock()
	fake.ListBackupsRequestStub = nil
	fake.listBackupsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ListBackupsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListBackupsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ListBackupsOutput) {
	fake.listBackupsRequestMutex.Lock()
	defer fake.listBackupsRequestMutex.Unlock()
	fake.ListBackupsRequestStub = nil
	if fake.listBackupsRequestReturnsOnCall == nil {
		fake.listBackupsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ListBackupsOutput
		})
	}
	fake.listBackupsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ListBackupsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListBackupsWithContext(arg1 context.Context, arg2 *dynamodba.ListBackupsInput, arg3 ...request.Option) (*dynamodba.ListBackupsOutput, error) {
	fake.listBackupsWithContextMutex.Lock()
	ret, specificReturn := fake.listBackupsWithContextReturnsOnCall[len(fake.listBackupsWithContextArgsForCall)]
	fake.listBackupsWithContextArgsForCall = append(fake.listBackupsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListBackupsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListBackupsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listBackupsWithContextMutex.Unlock()
	if fake.ListBackupsWithContextStub != nil {
		return fake.ListBackupsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBackupsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListBackupsWithContextCallCount() int {
	fake.listBackupsWithContextMutex.RLock()
	defer fake.listBackupsWithContextMutex.RUnlock()
	return len(fake.listBackupsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListBackupsWithContextCalls(stub func(context.Context, *dynamodba.ListBackupsInput, ...request.Option) (*dynamodba.ListBackupsOutput, error)) {
	fake.listBackupsWithContextMutex.Lock()
	defer fake.listBackupsWithContextMutex.Unlock()
	fake.ListBackupsWithContextStub = stub
}

func (fake *FakeDynamoDB) ListBackupsWithContextArgsForCall(i int) (context.Context, *dynamodba.ListBackupsInput, []request.Option) {
	fake.listBackupsWithContextMutex.RLock()
	defer fake.listBackupsWithContextMutex.RUnlock()
	argsForCall := fake.listBackupsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ListBackupsWithContextReturns(result1 *dynamodba.ListBackupsOutput, result2 error) {
	fake.listBackupsWithContextMutex.Lock()
	defer fake.listBackupsWithContextMutex.Unlock()
	fake.ListBackupsWithContextStub = nil
	fake.listBackupsWithContextReturns = struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListBackupsWithContextReturnsOnCall(i int, result1 *dynamodba.ListBackupsOutput, result2 error) {
	fake.listBackupsWithContextMutex.Lock()
	defer fake.listBackupsWithContextMutex.Unlock()
	fake.ListBackupsWithContextStub = nil
	if fake.listBackupsWithContextReturnsOnCall == nil {
		fake.listBackupsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListBackupsOutput
			result2 error
		})
	}
	fake.listBackupsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ListBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListContributorInsights(arg1 *dynamodba.ListContributorInsightsInput) (*dynamodba.ListContributorInsightsOutput, error) {
	fake.listContributorInsightsMutex.Lock()
	ret, specificReturn := fake.listContributorInsightsReturnsOnCall[len(fake.listContributorInsightsArgsForCall)]
	fake.listContributorInsightsArgsForCall = append(fake.listContributorInsightsArgsForCall, struct {
		arg1 *dynamodba.ListContributorInsightsInput
	}{arg1})
	fake.recordInvocation("ListContributorInsights", []interface{}{arg1})
	fake.listContributorInsightsMutex.Unlock()
	if fake.ListContributorInsightsStub != nil {
		return fake.ListContributorInsightsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listContributorInsightsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListContributorInsightsCallCount() int {
	fake.listContributorInsightsMutex.RLock()
	defer fake.listContributorInsightsMutex.RUnlock()
	return len(fake.listContributorInsightsArgsForCall)
}

func (fake *FakeDynamoDB) ListContributorInsightsCalls(stub func(*dynamodba.ListContributorInsightsInput) (*dynamodba.ListContributorInsightsOutput, error)) {
	fake.listContributorInsightsMutex.Lock()
	defer fake.listContributorInsightsMutex.Unlock()
	fake.ListContributorInsightsStub = stub
}

func (fake *FakeDynamoDB) ListContributorInsightsArgsForCall(i int) *dynamodba.ListContributorInsightsInput {
	fake.listContributorInsightsMutex.RLock()
	defer fake.listContributorInsightsMutex.RUnlock()
	argsForCall := fake.listContributorInsightsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListContributorInsightsReturns(result1 *dynamodba.ListContributorInsightsOutput, result2 error) {
	fake.listContributorInsightsMutex.Lock()
	defer fake.listContributorInsightsMutex.Unlock()
	fake.ListContributorInsightsStub = nil
	fake.listContributorInsightsReturns = struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListContributorInsightsReturnsOnCall(i int, result1 *dynamodba.ListContributorInsightsOutput, result2 error) {
	fake.listContributorInsightsMutex.Lock()
	defer fake.listContributorInsightsMutex.Unlock()
	fake.ListContributorInsightsStub = nil
	if fake.listContributorInsightsReturnsOnCall == nil {
		fake.listContributorInsightsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListContributorInsightsOutput
			result2 error
		})
	}
	fake.listContributorInsightsReturnsOnCall[i] = struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListContributorInsightsPages(arg1 *dynamodba.ListContributorInsightsInput, arg2 func(*dynamodba.ListContributorInsightsOutput, bool) bool) error {
	fake.listContributorInsightsPagesMutex.Lock()
	ret, specificReturn := fake.listContributorInsightsPagesReturnsOnCall[len(fake.listContributorInsightsPagesArgsForCall)]
	fake.listContributorInsightsPagesArgsForCall = append(fake.listContributorInsightsPagesArgsForCall, struct {
		arg1 *dynamodba.ListContributorInsightsInput
		arg2 func(*dynamodba.ListContributorInsightsOutput, bool) bool
	}{arg1, arg2})
	fake.recordInvocation("ListContributorInsightsPages", []interface{}{arg1, arg2})
	fake.listContributorInsightsPagesMutex.Unlock()
	if fake.ListContributorInsightsPagesStub != nil {
		return fake.ListContributorInsightsPagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listContributorInsightsPagesReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesCallCount() int {
	fake.listContributorInsightsPagesMutex.RLock()
	defer fake.listContributorInsightsPagesMutex.RUnlock()
	return len(fake.listContributorInsightsPagesArgsForCall)
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesCalls(stub func(*dynamodba.ListContributorInsightsInput, func(*dynamodba.ListContributorInsightsOutput, bool) bool) error) {
	fake.listContributorInsightsPagesMutex.Lock()
	defer fake.listContributorInsightsPagesMutex.Unlock()
	fake.ListContributorInsightsPagesStub = stub
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesArgsForCall(i int) (*dynamodba.ListContributorInsightsInput, func(*dynamodba.ListContributorInsightsOutput, bool) bool) {
	fake.listContributorInsightsPagesMutex.RLock()
	defer fake.listContributorInsightsPagesMutex.RUnlock()
	argsForCall := fake.listContributorInsightsPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesReturns(result1 error) {
	fake.listContributorInsightsPagesMutex.Lock()
	defer fake.listContributorInsightsPagesMutex.Unlock()
	fake.ListContributorInsightsPagesStub = nil
	fake.listContributorInsightsPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesReturnsOnCall(i int, result1 error) {
	fake.listContributorInsightsPagesMutex.Lock()
	defer fake.listContributorInsightsPagesMutex.Unlock()
	fake.ListContributorInsightsPagesStub = nil
	if fake.listContributorInsightsPagesReturnsOnCall == nil {
		fake.listContributorInsightsPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listContributorInsightsPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesWithContext(arg1 context.Context, arg2 *dynamodba.ListContributorInsightsInput, arg3 func(*dynamodba.ListContributorInsightsOutput, bool) bool, arg4 ...request.Option) error {
	fake.listContributorInsightsPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listContributorInsightsPagesWithContextReturnsOnCall[len(fake.listContributorInsightsPagesWithContextArgsForCall)]
	fake.listContributorInsightsPagesWithContextArgsForCall = append(fake.listContributorInsightsPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListContributorInsightsInput
		arg3 func(*dynamodba.ListContributorInsightsOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ListContributorInsightsPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listContributorInsightsPagesWithContextMutex.Unlock()
	if fake.ListContributorInsightsPagesWithContextStub != nil {
		return fake.ListContributorInsightsPagesWithContextStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listContributorInsightsPagesWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesWithContextCallCount() int {
	fake.listContributorInsightsPagesWithContextMutex.RLock()
	defer fake.listContributorInsightsPagesWithContextMutex.RUnlock()
	return len(fake.listContributorInsightsPagesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesWithContextCalls(stub func(context.Context, *dynamodba.ListContributorInsightsInput, func(*dynamodba.ListContributorInsightsOutput, bool) bool, ...request.Option) error) {
	fake.listContributorInsightsPagesWithContextMutex.Lock()
	defer fake.listContributorInsightsPagesWithContextMutex.Unlock()
	fake.ListContributorInsightsPagesWithContextStub = stub
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesWithContextArgsForCall(i int) (context.Context, *dynamodba.ListContributorInsightsInput, func(*dynamodba.ListContributorInsightsOutput, bool) bool, []request.Option) {
	fake.listContributorInsightsPagesWithContextMutex.RLock()
	defer fake.listContributorInsightsPagesWithContextMutex.RUnlock()
	argsForCall := fake.listContributorInsightsPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesWithContextReturns(result1 error) {
	fake.listContributorInsightsPagesWithContextMutex.Lock()
	defer fake.listContributorInsightsPagesWithContextMutex.Unlock()
	fake.ListContributorInsightsPagesWithContextStub = nil
	fake.listContributorInsightsPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListContributorInsightsPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listContributorInsightsPagesWithContextMutex.Lock()
	defer fake.listContributorInsightsPagesWithContextMutex.Unlock()
	fake.ListContributorInsightsPagesWithContextStub = nil
	if fake.listContributorInsightsPagesWithContextReturnsOnCall == nil {
		fake.listContributorInsightsPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listContributorInsightsPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListContributorInsightsRequest(arg1 *dynamodba.ListContributorInsightsInput) (*request.Request, *dynamodba.ListContributorInsightsOutput) {
	fake.listContributorInsightsRequestMutex.Lock()
	ret, specificReturn := fake.listContributorInsightsRequestReturnsOnCall[len(fake.listContributorInsightsRequestArgsForCall)]
	fake.listContributorInsightsRequestArgsForCall = append(fake.listContributorInsightsRequestArgsForCall, struct {
		arg1 *dynamodba.ListContributorInsightsInput
	}{arg1})
	fake.recordInvocation("ListContributorInsightsRequest", []interface{}{arg1})
	fake.listContributorInsightsRequestMutex.Unlock()
	if fake.ListContributorInsightsRequestStub != nil {
		return fake.ListContributorInsightsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listContributorInsightsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListContributorInsightsRequestCallCount() int {
	fake.listContributorInsightsRequestMutex.RLock()
	defer fake.listContributorInsightsRequestMutex.RUnlock()
	return len(fake.listContributorInsightsRequestArgsForCall)
}

func (fake *FakeDynamoDB) ListContributorInsightsRequestCalls(stub func(*dynamodba.ListContributorInsightsInput) (*request.Request, *dynamodba.ListContributorInsightsOutput)) {
	fake.listContributorInsightsRequestMutex.Lock()
	defer fake.listContributorInsightsRequestMutex.Unlock()
	fake.ListContributorInsightsRequestStub = stub
}

func (fake *FakeDynamoDB) ListContributorInsightsRequestArgsForCall(i int) *dynamodba.ListContributorInsightsInput {
	fake.listContributorInsightsRequestMutex.RLock()
	defer fake.listContributorInsightsRequestMutex.RUnlock()
	argsForCall := fake.listContributorInsightsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListContributorInsightsRequestReturns(result1 *request.Request, result2 *dynamodba.ListContributorInsightsOutput) {
	fake.listContributorInsightsRequestMutex.Lock()
	defer fake.listContributorInsightsRequestMutex.Unlock()
	fake.ListContributorInsightsRequestStub = nil
	fake.listContributorInsightsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ListContributorInsightsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListContributorInsightsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ListContributorInsightsOutput) {
	fake.listContributorInsightsRequestMutex.Lock()
	defer fake.listContributorInsightsRequestMutex.Unlock()
	fake.ListContributorInsightsRequestStub = nil
	if fake.listContributorInsightsRequestReturnsOnCall == nil {
		fake.listContributorInsightsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ListContributorInsightsOutput
		})
	}
	fake.listContributorInsightsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ListContributorInsightsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListContributorInsightsWithContext(arg1 context.Context, arg2 *dynamodba.ListContributorInsightsInput, arg3 ...request.Option) (*dynamodba.ListContributorInsightsOutput, error) {
	fake.listContributorInsightsWithContextMutex.Lock()
	ret, specificReturn := fake.listContributorInsightsWithContextReturnsOnCall[len(fake.listContributorInsightsWithContextArgsForCall)]
	fake.listContributorInsightsWithContextArgsForCall = append(fake.listContributorInsightsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListContributorInsightsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListContributorInsightsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listContributorInsightsWithContextMutex.Unlock()
	if fake.ListContributorInsightsWithContextStub != nil {
		return fake.ListContributorInsightsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listContributorInsightsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListContributorInsightsWithContextCallCount() int {
	fake.listContributorInsightsWithContextMutex.RLock()
	defer fake.listContributorInsightsWithContextMutex.RUnlock()
	return len(fake.listContributorInsightsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListContributorInsightsWithContextCalls(stub func(context.Context, *dynamodba.ListContributorInsightsInput, ...request.Option) (*dynamodba.ListContributorInsightsOutput, error)) {
	fake.listContributorInsightsWithContextMutex.Lock()
	defer fake.listContributorInsightsWithContextMutex.Unlock()
	fake.ListContributorInsightsWithContextStub = stub
}

func (fake *FakeDynamoDB) ListContributorInsightsWithContextArgsForCall(i int) (context.Context, *dynamodba.ListContributorInsightsInput, []request.Option) {
	fake.listContributorInsightsWithContextMutex.RLock()
	defer fake.listContributorInsightsWithContextMutex.RUnlock()
	argsForCall := fake.listContributorInsightsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ListContributorInsightsWithContextReturns(result1 *dynamodba.ListContributorInsightsOutput, result2 error) {
	fake.listContributorInsightsWithContextMutex.Lock()
	defer fake.listContributorInsightsWithContextMutex.Unlock()
	fake.ListContributorInsightsWithContextStub = nil
	fake.listContributorInsightsWithContextReturns = struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListContributorInsightsWithContextReturnsOnCall(i int, result1 *dynamodba.ListContributorInsightsOutput, result2 error) {
	fake.listContributorInsightsWithContextMutex.Lock()
	defer fake.listContributorInsightsWithContextMutex.Unlock()
	fake.ListContributorInsightsWithContextStub = nil
	if fake.listContributorInsightsWithContextReturnsOnCall == nil {
		fake.listContributorInsightsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListContributorInsightsOutput
			result2 error
		})
	}
	fake.listContributorInsightsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ListContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListExports(arg1 *dynamodba.ListExportsInput) (*dynamodba.ListExportsOutput, error) {
	fake.listExportsMutex.Lock()
	ret, specificReturn := fake.listExportsReturnsOnCall[len(fake.listExportsArgsForCall)]
	fake.listExportsArgsForCall = append(fake.listExportsArgsForCall, struct {
		arg1 *dynamodba.ListExportsInput
	}{arg1})
	fake.recordInvocation("ListExports", []interface{}{arg1})
	fake.listExportsMutex.Unlock()
	if fake.ListExportsStub != nil {
		return fake.ListExportsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listExportsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListExportsCallCount() int {
	fake.listExportsMutex.RLock()
	defer fake.listExportsMutex.RUnlock()
	return len(fake.listExportsArgsForCall)
}

func (fake *FakeDynamoDB) ListExportsCalls(stub func(*dynamodba.ListExportsInput) (*dynamodba.ListExportsOutput, error)) {
	fake.listExportsMutex.Lock()
	defer fake.listExportsMutex.Unlock()
	fake.ListExportsStub = stub
}

func (fake *FakeDynamoDB) ListExportsArgsForCall(i int) *dynamodba.ListExportsInput {
	fake.listExportsMutex.RLock()
	defer fake.listExportsMutex.RUnlock()
	argsForCall := fake.listExportsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListExportsReturns(result1 *dynamodba.ListExportsOutput, result2 error) {
	fake.listExportsMutex.Lock()
	defer fake.listExportsMutex.Unlock()
	fake.ListExportsStub = nil
	fake.listExportsReturns = struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListExportsReturnsOnCall(i int, result1 *dynamodba.ListExportsOutput, result2 error) {
	fake.listExportsMutex.Lock()
	defer fake.listExportsMutex.Unlock()
	fake.ListExportsStub = nil
	if fake.listExportsReturnsOnCall == nil {
		fake.listExportsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListExportsOutput
			result2 error
		})
	}
	fake.listExportsReturnsOnCall[i] = struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListExportsPages(arg1 *dynamodba.ListExportsInput, arg2 func(*dynamodba.ListExportsOutput, bool) bool) error {
	fake.listExportsPagesMutex.Lock()
	ret, specificReturn := fake.listExportsPagesReturnsOnCall[len(fake.listExportsPagesArgsForCall)]
	fake.listExportsPagesArgsForCall = append(fake.listExportsPagesArgsForCall, struct {
		arg1 *dynamodba.ListExportsInput
		arg2 func(*dynamodba.ListExportsOutput, bool) bool
	}{arg1, arg2})
	fake.recordInvocation("ListExportsPages", []interface{}{arg1, arg2})
	fake.listExportsPagesMutex.Unlock()
	if fake.ListExportsPagesStub != nil {
		return fake.ListExportsPagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listExportsPagesReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ListExportsPagesCallCount() int {
	fake.listExportsPagesMutex.RLock()
	defer fake.listExportsPagesMutex.RUnlock()
	return len(fake.listExportsPagesArgsForCall)
}

func (fake *FakeDynamoDB) ListExportsPagesCalls(stub func(*dynamodba.ListExportsInput, func(*dynamodba.ListExportsOutput, bool) bool) error) {
	fake.listExportsPagesMutex.Lock()
	defer fake.listExportsPagesMutex.Unlock()
	fake.ListExportsPagesStub = stub
}

func (fake *FakeDynamoDB) ListExportsPagesArgsForCall(i int) (*dynamodba.ListExportsInput, func(*dynamodba.ListExportsOutput, bool) bool) {
	fake.listExportsPagesMutex.RLock()
	defer fake.listExportsPagesMutex.RUnlock()
	argsForCall := fake.listExportsPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDynamoDB) ListExportsPagesReturns(result1 error) {
	fake.listExportsPagesMutex.Lock()
	defer fake.listExportsPagesMutex.Unlock()
	fake.ListExportsPagesStub = nil
	fake.listExportsPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListExportsPagesReturnsOnCall(i int, result1 error) {
	fake.listExportsPagesMutex.Lock()
	defer fake.listExportsPagesMutex.Unlock()
	fake.ListExportsPagesStub = nil
	if fake.listExportsPagesReturnsOnCall == nil {
		fake.listExportsPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listExportsPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListExportsPagesWithContext(arg1 context.Context, arg2 *dynamodba.ListExportsInput, arg3 func(*dynamodba.ListExportsOutput, bool) bool, arg4 ...request.Option) error {
	fake.listExportsPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listExportsPagesWithContextReturnsOnCall[len(fake.listExportsPagesWithContextArgsForCall)]
	fake.listExportsPagesWithContextArgsForCall = append(fake.listExportsPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListExportsInput
		arg3 func(*dynamodba.ListExportsOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ListExportsPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listExportsPagesWithContextMutex.Unlock()
	if fake.ListExportsPagesWithContextStub != nil {
		return fake.ListExportsPagesWithContextStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listExportsPagesWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ListExportsPagesWithContextCallCount() int {
	fake.listExportsPagesWithContextMutex.RLock()
	defer fake.listExportsPagesWithContextMutex.RUnlock()
	return len(fake.listExportsPagesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListExportsPagesWithContextCalls(stub func(context.Context, *dynamodba.ListExportsInput, func(*dynamodba.ListExportsOutput, bool) bool, ...request.Option) error) {
	fake.listExportsPagesWithContextMutex.Lock()
	defer fake.listExportsPagesWithContextMutex.Unlock()
	fake.ListExportsPagesWithContextStub = stub
}

func (fake *FakeDynamoDB) ListExportsPagesWithContextArgsForCall(i int) (context.Context, *dynamodba.ListExportsInput, func(*dynamodba.ListExportsOutput, bool) bool, []request.Option) {
	fake.listExportsPagesWithContextMutex.RLock()
	defer fake.listExportsPagesWithContextMutex.RUnlock()
	argsForCall := fake.listExportsPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDynamoDB) ListExportsPagesWithContextReturns(result1 error) {
	fake.listExportsPagesWithContextMutex.Lock()
	defer fake.listExportsPagesWithContextMutex.Unlock()
	fake.ListExportsPagesWithContextStub = nil
	fake.listExportsPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListExportsPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listExportsPagesWithContextMutex.Lock()
	defer fake.listExportsPagesWithContextMutex.Unlock()
	fake.ListExportsPagesWithContextStub = nil
	if fake.listExportsPagesWithContextReturnsOnCall == nil {
		fake.listExportsPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listExportsPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListExportsRequest(arg1 *dynamodba.ListExportsInput) (*request.Request, *dynamodba.ListExportsOutput) {
	fake.listExportsRequestMutex.Lock()
	ret, specificReturn := fake.listExportsRequestReturnsOnCall[len(fake.listExportsRequestArgsForCall)]
	fake.listExportsRequestArgsForCall = append(fake.listExportsRequestArgsForCall, struct {
		arg1 *dynamodba.ListExportsInput
	}{arg1})
	fake.recordInvocation("ListExportsRequest", []interface{}{arg1})
	fake.listExportsRequestMutex.Unlock()
	if fake.ListExportsRequestStub != nil {
		return fake.ListExportsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listExportsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListExportsRequestCallCount() int {
	fake.listExportsRequestMutex.RLock()
	defer fake.listExportsRequestMutex.RUnlock()
	return len(fake.listExportsRequestArgsForCall)
}

func (fake *FakeDynamoDB) ListExportsRequestCalls(stub func(*dynamodba.ListExportsInput) (*request.Request, *dynamodba.ListExportsOutput)) {
	fake.listExportsRequestMutex.Lock()
	defer fake.listExportsRequestMutex.Unlock()
	fake.ListExportsRequestStub = stub
}

func (fake *FakeDynamoDB) ListExportsRequestArgsForCall(i int) *dynamodba.ListExportsInput {
	fake.listExportsRequestMutex.RLock()
	defer fake.listExportsRequestMutex.RUnlock()
	argsForCall := fake.listExportsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListExportsRequestReturns(result1 *request.Request, result2 *dynamodba.ListExportsOutput) {
	fake.listExportsRequestMutex.Lock()
	defer fake.listExportsRequestMutex.Unlock()
	fake.ListExportsRequestStub = nil
	fake.listExportsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ListExportsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListExportsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ListExportsOutput) {
	fake.listExportsRequestMutex.Lock()
	defer fake.listExportsRequestMutex.Unlock()
	fake.ListExportsRequestStub = nil
	if fake.listExportsRequestReturnsOnCall == nil {
		fake.listExportsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ListExportsOutput
		})
	}
	fake.listExportsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ListExportsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListExportsWithContext(arg1 context.Context, arg2 *dynamodba.ListExportsInput, arg3 ...request.Option) (*dynamodba.ListExportsOutput, error) {
	fake.listExportsWithContextMutex.Lock()
	ret, specificReturn := fake.listExportsWithContextReturnsOnCall[len(fake.listExportsWithContextArgsForCall)]
	fake.listExportsWithContextArgsForCall = append(fake.listExportsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListExportsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListExportsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listExportsWithContextMutex.Unlock()
	if fake.ListExportsWithContextStub != nil {
		return fake.ListExportsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listExportsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListExportsWithContextCallCount() int {
	fake.listExportsWithContextMutex.RLock()
	defer fake.listExportsWithContextMutex.RUnlock()
	return len(fake.listExportsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListExportsWithContextCalls(stub func(context.Context, *dynamodba.ListExportsInput, ...request.Option) (*dynamodba.ListExportsOutput, error)) {
	fake.listExportsWithContextMutex.Lock()
	defer fake.listExportsWithContextMutex.Unlock()
	fake.ListExportsWithContextStub = stub
}

func (fake *FakeDynamoDB) ListExportsWithContextArgsForCall(i int) (context.Context, *dynamodba.ListExportsInput, []request.Option) {
	fake.listExportsWithContextMutex.RLock()
	defer fake.listExportsWithContextMutex.RUnlock()
	argsForCall := fake.listExportsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ListExportsWithContextReturns(result1 *dynamodba.ListExportsOutput, result2 error) {
	fake.listExportsWithContextMutex.Lock()
	defer fake.listExportsWithContextMutex.Unlock()
	fake.ListExportsWithContextStub = nil
	fake.listExportsWithContextReturns = struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListExportsWithContextReturnsOnCall(i int, result1 *dynamodba.ListExportsOutput, result2 error) {
	fake.listExportsWithContextMutex.Lock()
	defer fake.listExportsWithContextMutex.Unlock()
	fake.ListExportsWithContextStub = nil
	if fake.listExportsWithContextReturnsOnCall == nil {
		fake.listExportsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListExportsOutput
			result2 error
		})
	}
	fake.listExportsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ListExportsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListGlobalTables(arg1 *dynamodba.ListGlobalTablesInput) (*dynamodba.ListGlobalTablesOutput, error) {
	fake.listGlobalTablesMutex.Lock()
	ret, specificReturn := fake.listGlobalTablesReturnsOnCall[len(fake.listGlobalTablesArgsForCall)]
	fake.listGlobalTablesArgsForCall = append(fake.listGlobalTablesArgsForCall, struct {
		arg1 *dynamodba.ListGlobalTablesInput
	}{arg1})
	fake.recordInvocation("ListGlobalTables", []interface{}{arg1})
	fake.listGlobalTablesMutex.Unlock()
	if fake.ListGlobalTablesStub != nil {
		return fake.ListGlobalTablesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listGlobalTablesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListGlobalTablesCallCount() int {
	fake.listGlobalTablesMutex.RLock()
	defer fake.listGlobalTablesMutex.RUnlock()
	return len(fake.listGlobalTablesArgsForCall)
}

func (fake *FakeDynamoDB) ListGlobalTablesCalls(stub func(*dynamodba.ListGlobalTablesInput) (*dynamodba.ListGlobalTablesOutput, error)) {
	fake.listGlobalTablesMutex.Lock()
	defer fake.listGlobalTablesMutex.Unlock()
	fake.ListGlobalTablesStub = stub
}

func (fake *FakeDynamoDB) ListGlobalTablesArgsForCall(i int) *dynamodba.ListGlobalTablesInput {
	fake.listGlobalTablesMutex.RLock()
	defer fake.listGlobalTablesMutex.RUnlock()
	argsForCall := fake.listGlobalTablesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListGlobalTablesReturns(result1 *dynamodba.ListGlobalTablesOutput, result2 error) {
	fake.listGlobalTablesMutex.Lock()
	defer fake.listGlobalTablesMutex.Unlock()
	fake.ListGlobalTablesStub = nil
	fake.listGlobalTablesReturns = struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListGlobalTablesReturnsOnCall(i int, result1 *dynamodba.ListGlobalTablesOutput, result2 error) {
	fake.listGlobalTablesMutex.Lock()
	defer fake.listGlobalTablesMutex.Unlock()
	fake.ListGlobalTablesStub = nil
	if fake.listGlobalTablesReturnsOnCall == nil {
		fake.listGlobalTablesReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListGlobalTablesOutput
			result2 error
		})
	}
	fake.listGlobalTablesReturnsOnCall[i] = struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListGlobalTablesRequest(arg1 *dynamodba.ListGlobalTablesInput) (*request.Request, *dynamodba.ListGlobalTablesOutput) {
	fake.listGlobalTablesRequestMutex.Lock()
	ret, specificReturn := fake.listGlobalTablesRequestReturnsOnCall[len(fake.listGlobalTablesRequestArgsForCall)]
	fake.listGlobalTablesRequestArgsForCall = append(fake.listGlobalTablesRequestArgsForCall, struct {
		arg1 *dynamodba.ListGlobalTablesInput
	}{arg1})
	fake.recordInvocation("ListGlobalTablesRequest", []interface{}{arg1})
	fake.listGlobalTablesRequestMutex.Unlock()
	if fake.ListGlobalTablesRequestStub != nil {
		return fake.ListGlobalTablesRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listGlobalTablesRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListGlobalTablesRequestCallCount() int {
	fake.listGlobalTablesRequestMutex.RLock()
	defer fake.listGlobalTablesRequestMutex.RUnlock()
	return len(fake.listGlobalTablesRequestArgsForCall)
}

func (fake *FakeDynamoDB) ListGlobalTablesRequestCalls(stub func(*dynamodba.ListGlobalTablesInput) (*request.Request, *dynamodba.ListGlobalTablesOutput)) {
	fake.listGlobalTablesRequestMutex.Lock()
	defer fake.listGlobalTablesRequestMutex.Unlock()
	fake.ListGlobalTablesRequestStub = stub
}

func (fake *FakeDynamoDB) ListGlobalTablesRequestArgsForCall(i int) *dynamodba.ListGlobalTablesInput {
	fake.listGlobalTablesRequestMutex.RLock()
	defer fake.listGlobalTablesRequestMutex.RUnlock()
	argsForCall := fake.listGlobalTablesRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListGlobalTablesRequestReturns(result1 *request.Request, result2 *dynamodba.ListGlobalTablesOutput) {
	fake.listGlobalTablesRequestMutex.Lock()
	defer fake.listGlobalTablesRequestMutex.Unlock()
	fake.ListGlobalTablesRequestStub = nil
	fake.listGlobalTablesRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ListGlobalTablesOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListGlobalTablesRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ListGlobalTablesOutput) {
	fake.listGlobalTablesRequestMutex.Lock()
	defer fake.listGlobalTablesRequestMutex.Unlock()
	fake.ListGlobalTablesRequestStub = nil
	if fake.listGlobalTablesRequestReturnsOnCall == nil {
		fake.listGlobalTablesRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ListGlobalTablesOutput
		})
	}
	fake.listGlobalTablesRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ListGlobalTablesOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListGlobalTablesWithContext(arg1 context.Context, arg2 *dynamodba.ListGlobalTablesInput, arg3 ...request.Option) (*dynamodba.ListGlobalTablesOutput, error) {
	fake.listGlobalTablesWithContextMutex.Lock()
	ret, specificReturn := fake.listGlobalTablesWithContextReturnsOnCall[len(fake.listGlobalTablesWithContextArgsForCall)]
	fake.listGlobalTablesWithContextArgsForCall = append(fake.listGlobalTablesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListGlobalTablesInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListGlobalTablesWithContext", []interface{}{arg1, arg2, arg3})
	fake.listGlobalTablesWithContextMutex.Unlock()
	if fake.ListGlobalTablesWithContextStub != nil {
		return fake.ListGlobalTablesWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listGlobalTablesWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListGlobalTablesWithContextCallCount() int {
	fake.listGlobalTablesWithContextMutex.RLock()
	defer fake.listGlobalTablesWithContextMutex.RUnlock()
	return len(fake.listGlobalTablesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListGlobalTablesWithContextCalls(stub func(context.Context, *dynamodba.ListGlobalTablesInput, ...request.Option) (*dynamodba.ListGlobalTablesOutput, error)) {
	fake.listGlobalTablesWithContextMutex.Lock()
	defer fake.listGlobalTablesWithContextMutex.Unlock()
	fake.ListGlobalTablesWithContextStub = stub
}

func (fake *FakeDynamoDB) ListGlobalTablesWithContextArgsForCall(i int) (context.Context, *dynamodba.ListGlobalTablesInput, []request.Option) {
	fake.listGlobalTablesWithContextMutex.RLock()
	defer fake.listGlobalTablesWithContextMutex.RUnlock()
	argsForCall := fake.listGlobalTablesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ListGlobalTablesWithContextReturns(result1 *dynamodba.ListGlobalTablesOutput, result2 error) {
	fake.listGlobalTablesWithContextMutex.Lock()
	defer fake.listGlobalTablesWithContextMutex.Unlock()
	fake.ListGlobalTablesWithContextStub = nil
	fake.listGlobalTablesWithContextReturns = struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListGlobalTablesWithContextReturnsOnCall(i int, result1 *dynamodba.ListGlobalTablesOutput, result2 error) {
	fake.listGlobalTablesWithContextMutex.Lock()
	defer fake.listGlobalTablesWithContextMutex.Unlock()
	fake.ListGlobalTablesWithContextStub = nil
	if fake.listGlobalTablesWithContextReturnsOnCall == nil {
		fake.listGlobalTablesWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListGlobalTablesOutput
			result2 error
		})
	}
	fake.listGlobalTablesWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ListGlobalTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTables(arg1 *dynamodba.ListTablesInput) (*dynamodba.ListTablesOutput, error) {
	fake.listTablesMutex.Lock()
	ret, specificReturn := fake.listTablesReturnsOnCall[len(fake.listTablesArgsForCall)]
	fake.listTablesArgsForCall = append(fake.listTablesArgsForCall, struct {
		arg1 *dynamodba.ListTablesInput
	}{arg1})
	fake.recordInvocation("ListTables", []interface{}{arg1})
	fake.listTablesMutex.Unlock()
	if fake.ListTablesStub != nil {
		return fake.ListTablesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTablesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListTablesCallCount() int {
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	return len(fake.listTablesArgsForCall)
}

func (fake *FakeDynamoDB) ListTablesCalls(stub func(*dynamodba.ListTablesInput) (*dynamodba.ListTablesOutput, error)) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = stub
}

func (fake *FakeDynamoDB) ListTablesArgsForCall(i int) *dynamodba.ListTablesInput {
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	argsForCall := fake.listTablesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListTablesReturns(result1 *dynamodba.ListTablesOutput, result2 error) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = nil
	fake.listTablesReturns = struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTablesReturnsOnCall(i int, result1 *dynamodba.ListTablesOutput, result2 error) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = nil
	if fake.listTablesReturnsOnCall == nil {
		fake.listTablesReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListTablesOutput
			result2 error
		})
	}
	fake.listTablesReturnsOnCall[i] = struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTablesPages(arg1 *dynamodba.ListTablesInput, arg2 func(*dynamodba.ListTablesOutput, bool) bool) error {
	fake.listTablesPagesMutex.Lock()
	ret, specificReturn := fake.listTablesPagesReturnsOnCall[len(fake.listTablesPagesArgsForCall)]
	fake.listTablesPagesArgsForCall = append(fake.listTablesPagesArgsForCall, struct {
		arg1 *dynamodba.ListTablesInput
		arg2 func(*dynamodba.ListTablesOutput, bool) bool
	}{arg1, arg2})
	fake.recordInvocation("ListTablesPages", []interface{}{arg1, arg2})
	fake.listTablesPagesMutex.Unlock()
	if fake.ListTablesPagesStub != nil {
		return fake.ListTablesPagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listTablesPagesReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ListTablesPagesCallCount() int {
	fake.listTablesPagesMutex.RLock()
	defer fake.listTablesPagesMutex.RUnlock()
	return len(fake.listTablesPagesArgsForCall)
}

func (fake *FakeDynamoDB) ListTablesPagesCalls(stub func(*dynamodba.ListTablesInput, func(*dynamodba.ListTablesOutput, bool) bool) error) {
	fake.listTablesPagesMutex.Lock()
	defer fake.listTablesPagesMutex.Unlock()
	fake.ListTablesPagesStub = stub
}

func (fake *FakeDynamoDB) ListTablesPagesArgsForCall(i int) (*dynamodba.ListTablesInput, func(*dynamodba.ListTablesOutput, bool) bool) {
	fake.listTablesPagesMutex.RLock()
	defer fake.listTablesPagesMutex.RUnlock()
	argsForCall := fake.listTablesPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDynamoDB) ListTablesPagesReturns(result1 error) {
	fake.listTablesPagesMutex.Lock()
	defer fake.listTablesPagesMutex.Unlock()
	fake.ListTablesPagesStub = nil
	fake.listTablesPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListTablesPagesReturnsOnCall(i int, result1 error) {
	fake.listTablesPagesMutex.Lock()
	defer fake.listTablesPagesMutex.Unlock()
	fake.ListTablesPagesStub = nil
	if fake.listTablesPagesReturnsOnCall == nil {
		fake.listTablesPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listTablesPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListTablesPagesWithContext(arg1 context.Context, arg2 *dynamodba.ListTablesInput, arg3 func(*dynamodba.ListTablesOutput, bool) bool, arg4 ...request.Option) error {
	fake.listTablesPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listTablesPagesWithContextReturnsOnCall[len(fake.listTablesPagesWithContextArgsForCall)]
	fake.listTablesPagesWithContextArgsForCall = append(fake.listTablesPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListTablesInput
		arg3 func(*dynamodba.ListTablesOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ListTablesPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listTablesPagesWithContextMutex.Unlock()
	if fake.ListTablesPagesWithContextStub != nil {
		return fake.ListTablesPagesWithContextStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listTablesPagesWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ListTablesPagesWithContextCallCount() int {
	fake.listTablesPagesWithContextMutex.RLock()
	defer fake.listTablesPagesWithContextMutex.RUnlock()
	return len(fake.listTablesPagesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListTablesPagesWithContextCalls(stub func(context.Context, *dynamodba.ListTablesInput, func(*dynamodba.ListTablesOutput, bool) bool, ...request.Option) error) {
	fake.listTablesPagesWithContextMutex.Lock()
	defer fake.listTablesPagesWithContextMutex.Unlock()
	fake.ListTablesPagesWithContextStub = stub
}

func (fake *FakeDynamoDB) ListTablesPagesWithContextArgsForCall(i int) (context.Context, *dynamodba.ListTablesInput, func(*dynamodba.ListTablesOutput, bool) bool, []request.Option) {
	fake.listTablesPagesWithContextMutex.RLock()
	defer fake.listTablesPagesWithContextMutex.RUnlock()
	argsForCall := fake.listTablesPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDynamoDB) ListTablesPagesWithContextReturns(result1 error) {
	fake.listTablesPagesWithContextMutex.Lock()
	defer fake.listTablesPagesWithContextMutex.Unlock()
	fake.ListTablesPagesWithContextStub = nil
	fake.listTablesPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListTablesPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listTablesPagesWithContextMutex.Lock()
	defer fake.listTablesPagesWithContextMutex.Unlock()
	fake.ListTablesPagesWithContextStub = nil
	if fake.listTablesPagesWithContextReturnsOnCall == nil {
		fake.listTablesPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listTablesPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ListTablesRequest(arg1 *dynamodba.ListTablesInput) (*request.Request, *dynamodba.ListTablesOutput) {
	fake.listTablesRequestMutex.Lock()
	ret, specificReturn := fake.listTablesRequestReturnsOnCall[len(fake.listTablesRequestArgsForCall)]
	fake.listTablesRequestArgsForCall = append(fake.listTablesRequestArgsForCall, struct {
		arg1 *dynamodba.ListTablesInput
	}{arg1})
	fake.recordInvocation("ListTablesRequest", []interface{}{arg1})
	fake.listTablesRequestMutex.Unlock()
	if fake.ListTablesRequestStub != nil {
		return fake.ListTablesRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTablesRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListTablesRequestCallCount() int {
	fake.listTablesRequestMutex.RLock()
	defer fake.listTablesRequestMutex.RUnlock()
	return len(fake.listTablesRequestArgsForCall)
}

func (fake *FakeDynamoDB) ListTablesRequestCalls(stub func(*dynamodba.ListTablesInput) (*request.Request, *dynamodba.ListTablesOutput)) {
	fake.listTablesRequestMutex.Lock()
	defer fake.listTablesRequestMutex.Unlock()
	fake.ListTablesRequestStub = stub
}

func (fake *FakeDynamoDB) ListTablesRequestArgsForCall(i int) *dynamodba.ListTablesInput {
	fake.listTablesRequestMutex.RLock()
	defer fake.listTablesRequestMutex.RUnlock()
	argsForCall := fake.listTablesRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListTablesRequestReturns(result1 *request.Request, result2 *dynamodba.ListTablesOutput) {
	fake.listTablesRequestMutex.Lock()
	defer fake.listTablesRequestMutex.Unlock()
	fake.ListTablesRequestStub = nil
	fake.listTablesRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ListTablesOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTablesRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ListTablesOutput) {
	fake.listTablesRequestMutex.Lock()
	defer fake.listTablesRequestMutex.Unlock()
	fake.ListTablesRequestStub = nil
	if fake.listTablesRequestReturnsOnCall == nil {
		fake.listTablesRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ListTablesOutput
		})
	}
	fake.listTablesRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ListTablesOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTablesWithContext(arg1 context.Context, arg2 *dynamodba.ListTablesInput, arg3 ...request.Option) (*dynamodba.ListTablesOutput, error) {
	fake.listTablesWithContextMutex.Lock()
	ret, specificReturn := fake.listTablesWithContextReturnsOnCall[len(fake.listTablesWithContextArgsForCall)]
	fake.listTablesWithContextArgsForCall = append(fake.listTablesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListTablesInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListTablesWithContext", []interface{}{arg1, arg2, arg3})
	fake.listTablesWithContextMutex.Unlock()
	if fake.ListTablesWithContextStub != nil {
		return fake.ListTablesWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTablesWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListTablesWithContextCallCount() int {
	fake.listTablesWithContextMutex.RLock()
	defer fake.listTablesWithContextMutex.RUnlock()
	return len(fake.listTablesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListTablesWithContextCalls(stub func(context.Context, *dynamodba.ListTablesInput, ...request.Option) (*dynamodba.ListTablesOutput, error)) {
	fake.listTablesWithContextMutex.Lock()
	defer fake.listTablesWithContextMutex.Unlock()
	fake.ListTablesWithContextStub = stub
}

func (fake *FakeDynamoDB) ListTablesWithContextArgsForCall(i int) (context.Context, *dynamodba.ListTablesInput, []request.Option) {
	fake.listTablesWithContextMutex.RLock()
	defer fake.listTablesWithContextMutex.RUnlock()
	argsForCall := fake.listTablesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ListTablesWithContextReturns(result1 *dynamodba.ListTablesOutput, result2 error) {
	fake.listTablesWithContextMutex.Lock()
	defer fake.listTablesWithContextMutex.Unlock()
	fake.ListTablesWithContextStub = nil
	fake.listTablesWithContextReturns = struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTablesWithContextReturnsOnCall(i int, result1 *dynamodba.ListTablesOutput, result2 error) {
	fake.listTablesWithContextMutex.Lock()
	defer fake.listTablesWithContextMutex.Unlock()
	fake.ListTablesWithContextStub = nil
	if fake.listTablesWithContextReturnsOnCall == nil {
		fake.listTablesWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListTablesOutput
			result2 error
		})
	}
	fake.listTablesWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ListTablesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTagsOfResource(arg1 *dynamodba.ListTagsOfResourceInput) (*dynamodba.ListTagsOfResourceOutput, error) {
	fake.listTagsOfResourceMutex.Lock()
	ret, specificReturn := fake.listTagsOfResourceReturnsOnCall[len(fake.listTagsOfResourceArgsForCall)]
	fake.listTagsOfResourceArgsForCall = append(fake.listTagsOfResourceArgsForCall, struct {
		arg1 *dynamodba.ListTagsOfResourceInput
	}{arg1})
	fake.recordInvocation("ListTagsOfResource", []interface{}{arg1})
	fake.listTagsOfResourceMutex.Unlock()
	if fake.ListTagsOfResourceStub != nil {
		return fake.ListTagsOfResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTagsOfResourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListTagsOfResourceCallCount() int {
	fake.listTagsOfResourceMutex.RLock()
	defer fake.listTagsOfResourceMutex.RUnlock()
	return len(fake.listTagsOfResourceArgsForCall)
}

func (fake *FakeDynamoDB) ListTagsOfResourceCalls(stub func(*dynamodba.ListTagsOfResourceInput) (*dynamodba.ListTagsOfResourceOutput, error)) {
	fake.listTagsOfResourceMutex.Lock()
	defer fake.listTagsOfResourceMutex.Unlock()
	fake.ListTagsOfResourceStub = stub
}

func (fake *FakeDynamoDB) ListTagsOfResourceArgsForCall(i int) *dynamodba.ListTagsOfResourceInput {
	fake.listTagsOfResourceMutex.RLock()
	defer fake.listTagsOfResourceMutex.RUnlock()
	argsForCall := fake.listTagsOfResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListTagsOfResourceReturns(result1 *dynamodba.ListTagsOfResourceOutput, result2 error) {
	fake.listTagsOfResourceMutex.Lock()
	defer fake.listTagsOfResourceMutex.Unlock()
	fake.ListTagsOfResourceStub = nil
	fake.listTagsOfResourceReturns = struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTagsOfResourceReturnsOnCall(i int, result1 *dynamodba.ListTagsOfResourceOutput, result2 error) {
	fake.listTagsOfResourceMutex.Lock()
	defer fake.listTagsOfResourceMutex.Unlock()
	fake.ListTagsOfResourceStub = nil
	if fake.listTagsOfResourceReturnsOnCall == nil {
		fake.listTagsOfResourceReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListTagsOfResourceOutput
			result2 error
		})
	}
	fake.listTagsOfResourceReturnsOnCall[i] = struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTagsOfResourceRequest(arg1 *dynamodba.ListTagsOfResourceInput) (*request.Request, *dynamodba.ListTagsOfResourceOutput) {
	fake.listTagsOfResourceRequestMutex.Lock()
	ret, specificReturn := fake.listTagsOfResourceRequestReturnsOnCall[len(fake.listTagsOfResourceRequestArgsForCall)]
	fake.listTagsOfResourceRequestArgsForCall = append(fake.listTagsOfResourceRequestArgsForCall, struct {
		arg1 *dynamodba.ListTagsOfResourceInput
	}{arg1})
	fake.recordInvocation("ListTagsOfResourceRequest", []interface{}{arg1})
	fake.listTagsOfResourceRequestMutex.Unlock()
	if fake.ListTagsOfResourceRequestStub != nil {
		return fake.ListTagsOfResourceRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTagsOfResourceRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListTagsOfResourceRequestCallCount() int {
	fake.listTagsOfResourceRequestMutex.RLock()
	defer fake.listTagsOfResourceRequestMutex.RUnlock()
	return len(fake.listTagsOfResourceRequestArgsForCall)
}

func (fake *FakeDynamoDB) ListTagsOfResourceRequestCalls(stub func(*dynamodba.ListTagsOfResourceInput) (*request.Request, *dynamodba.ListTagsOfResourceOutput)) {
	fake.listTagsOfResourceRequestMutex.Lock()
	defer fake.listTagsOfResourceRequestMutex.Unlock()
	fake.ListTagsOfResourceRequestStub = stub
}

func (fake *FakeDynamoDB) ListTagsOfResourceRequestArgsForCall(i int) *dynamodba.ListTagsOfResourceInput {
	fake.listTagsOfResourceRequestMutex.RLock()
	defer fake.listTagsOfResourceRequestMutex.RUnlock()
	argsForCall := fake.listTagsOfResourceRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ListTagsOfResourceRequestReturns(result1 *request.Request, result2 *dynamodba.ListTagsOfResourceOutput) {
	fake.listTagsOfResourceRequestMutex.Lock()
	defer fake.listTagsOfResourceRequestMutex.Unlock()
	fake.ListTagsOfResourceRequestStub = nil
	fake.listTagsOfResourceRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ListTagsOfResourceOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTagsOfResourceRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ListTagsOfResourceOutput) {
	fake.listTagsOfResourceRequestMutex.Lock()
	defer fake.listTagsOfResourceRequestMutex.Unlock()
	fake.ListTagsOfResourceRequestStub = nil
	if fake.listTagsOfResourceRequestReturnsOnCall == nil {
		fake.listTagsOfResourceRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ListTagsOfResourceOutput
		})
	}
	fake.listTagsOfResourceRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ListTagsOfResourceOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTagsOfResourceWithContext(arg1 context.Context, arg2 *dynamodba.ListTagsOfResourceInput, arg3 ...request.Option) (*dynamodba.ListTagsOfResourceOutput, error) {
	fake.listTagsOfResourceWithContextMutex.Lock()
	ret, specificReturn := fake.listTagsOfResourceWithContextReturnsOnCall[len(fake.listTagsOfResourceWithContextArgsForCall)]
	fake.listTagsOfResourceWithContextArgsForCall = append(fake.listTagsOfResourceWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ListTagsOfResourceInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListTagsOfResourceWithContext", []interface{}{arg1, arg2, arg3})
	fake.listTagsOfResourceWithContextMutex.Unlock()
	if fake.ListTagsOfResourceWithContextStub != nil {
		return fake.ListTagsOfResourceWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTagsOfResourceWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ListTagsOfResourceWithContextCallCount() int {
	fake.listTagsOfResourceWithContextMutex.RLock()
	defer fake.listTagsOfResourceWithContextMutex.RUnlock()
	return len(fake.listTagsOfResourceWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ListTagsOfResourceWithContextCalls(stub func(context.Context, *dynamodba.ListTagsOfResourceInput, ...request.Option) (*dynamodba.ListTagsOfResourceOutput, error)) {
	fake.listTagsOfResourceWithContextMutex.Lock()
	defer fake.listTagsOfResourceWithContextMutex.Unlock()
	fake.ListTagsOfResourceWithContextStub = stub
}

func (fake *FakeDynamoDB) ListTagsOfResourceWithContextArgsForCall(i int) (context.Context, *dynamodba.ListTagsOfResourceInput, []request.Option) {
	fake.listTagsOfResourceWithContextMutex.RLock()
	defer fake.listTagsOfResourceWithContextMutex.RUnlock()
	argsForCall := fake.listTagsOfResourceWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ListTagsOfResourceWithContextReturns(result1 *dynamodba.ListTagsOfResourceOutput, result2 error) {
	fake.listTagsOfResourceWithContextMutex.Lock()
	defer fake.listTagsOfResourceWithContextMutex.Unlock()
	fake.ListTagsOfResourceWithContextStub = nil
	fake.listTagsOfResourceWithContextReturns = struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ListTagsOfResourceWithContextReturnsOnCall(i int, result1 *dynamodba.ListTagsOfResourceOutput, result2 error) {
	fake.listTagsOfResourceWithContextMutex.Lock()
	defer fake.listTagsOfResourceWithContextMutex.Unlock()
	fake.ListTagsOfResourceWithContextStub = nil
	if fake.listTagsOfResourceWithContextReturnsOnCall == nil {
		fake.listTagsOfResourceWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ListTagsOfResourceOutput
			result2 error
		})
	}
	fake.listTagsOfResourceWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ListTagsOfResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) PutItem(arg1 *dynamodba.PutItemInput) (*dynamodba.PutItemOutput, error) {
	fake.putItemMutex.Lock()
	ret, specificReturn := fake.putItemReturnsOnCall[len(fake.putItemArgsForCall)]
	fake.putItemArgsForCall = append(fake.putItemArgsForCall, struct {
		arg1 *dynamodba.PutItemInput
	}{arg1})
	fake.recordInvocation("PutItem", []interface{}{arg1})
	fake.putItemMutex.Unlock()
	if fake.PutItemStub != nil {
		return fake.PutItemStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.putItemReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) PutItemCallCount() int {
	fake.putItemMutex.RLock()
	defer fake.putItemMutex.RUnlock()
	return len(fake.putItemArgsForCall)
}

func (fake *FakeDynamoDB) PutItemCalls(stub func(*dynamodba.PutItemInput) (*dynamodba.PutItemOutput, error)) {
	fake.putItemMutex.Lock()
	defer fake.putItemMutex.Unlock()
	fake.PutItemStub = stub
}

func (fake *FakeDynamoDB) PutItemArgsForCall(i int) *dynamodba.PutItemInput {
	fake.putItemMutex.RLock()
	defer fake.putItemMutex.RUnlock()
	argsForCall := fake.putItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) PutItemReturns(result1 *dynamodba.PutItemOutput, result2 error) {
	fake.putItemMutex.Lock()
	defer fake.putItemMutex.Unlock()
	fake.PutItemStub = nil
	fake.putItemReturns = struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) PutItemReturnsOnCall(i int, result1 *dynamodba.PutItemOutput, result2 error) {
	fake.putItemMutex.Lock()
	defer fake.putItemMutex.Unlock()
	fake.PutItemStub = nil
	if fake.putItemReturnsOnCall == nil {
		fake.putItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.PutItemOutput
			result2 error
		})
	}
	fake.putItemReturnsOnCall[i] = struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) PutItemRequest(arg1 *dynamodba.PutItemInput) (*request.Request, *dynamodba.PutItemOutput) {
	fake.putItemRequestMutex.Lock()
	ret, specificReturn := fake.putItemRequestReturnsOnCall[len(fake.putItemRequestArgsForCall)]
	fake.putItemRequestArgsForCall = append(fake.putItemRequestArgsForCall, struct {
		arg1 *dynamodba.PutItemInput
	}{arg1})
	fake.recordInvocation("PutItemRequest", []interface{}{arg1})
	fake.putItemRequestMutex.Unlock()
	if fake.PutItemRequestStub != nil {
		return fake.PutItemRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.putItemRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) PutItemRequestCallCount() int {
	fake.putItemRequestMutex.RLock()
	defer fake.putItemRequestMutex.RUnlock()
	return len(fake.putItemRequestArgsForCall)
}

func (fake *FakeDynamoDB) PutItemRequestCalls(stub func(*dynamodba.PutItemInput) (*request.Request, *dynamodba.PutItemOutput)) {
	fake.putItemRequestMutex.Lock()
	defer fake.putItemRequestMutex.Unlock()
	fake.PutItemRequestStub = stub
}

func (fake *FakeDynamoDB) PutItemRequestArgsForCall(i int) *dynamodba.PutItemInput {
	fake.putItemRequestMutex.RLock()
	defer fake.putItemRequestMutex.RUnlock()
	argsForCall := fake.putItemRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) PutItemRequestReturns(result1 *request.Request, result2 *dynamodba.PutItemOutput) {
	fake.putItemRequestMutex.Lock()
	defer fake.putItemRequestMutex.Unlock()
	fake.PutItemRequestStub = nil
	fake.putItemRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.PutItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) PutItemRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.PutItemOutput) {
	fake.putItemRequestMutex.Lock()
	defer fake.putItemRequestMutex.Unlock()
	fake.PutItemRequestStub = nil
	if fake.putItemRequestReturnsOnCall == nil {
		fake.putItemRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.PutItemOutput
		})
	}
	fake.putItemRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.PutItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) PutItemWithContext(arg1 context.Context, arg2 *dynamodba.PutItemInput, arg3 ...request.Option) (*dynamodba.PutItemOutput, error) {
	fake.putItemWithContextMutex.Lock()
	ret, specificReturn := fake.putItemWithContextReturnsOnCall[len(fake.putItemWithContextArgsForCall)]
	fake.putItemWithContextArgsForCall = append(fake.putItemWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.PutItemInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("PutItemWithContext", []interface{}{arg1, arg2, arg3})
	fake.putItemWithContextMutex.Unlock()
	if fake.PutItemWithContextStub != nil {
		return fake.PutItemWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.putItemWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) PutItemWithContextCallCount() int {
	fake.putItemWithContextMutex.RLock()
	defer fake.putItemWithContextMutex.RUnlock()
	return len(fake.putItemWithContextArgsForCall)
}

func (fake *FakeDynamoDB) PutItemWithContextCalls(stub func(context.Context, *dynamodba.PutItemInput, ...request.Option) (*dynamodba.PutItemOutput, error)) {
	fake.putItemWithContextMutex.Lock()
	defer fake.putItemWithContextMutex.Unlock()
	fake.PutItemWithContextStub = stub
}

func (fake *FakeDynamoDB) PutItemWithContextArgsForCall(i int) (context.Context, *dynamodba.PutItemInput, []request.Option) {
	fake.putItemWithContextMutex.RLock()
	defer fake.putItemWithContextMutex.RUnlock()
	argsForCall := fake.putItemWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) PutItemWithContextReturns(result1 *dynamodba.PutItemOutput, result2 error) {
	fake.putItemWithContextMutex.Lock()
	defer fake.putItemWithContextMutex.Unlock()
	fake.PutItemWithContextStub = nil
	fake.putItemWithContextReturns = struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) PutItemWithContextReturnsOnCall(i int, result1 *dynamodba.PutItemOutput, result2 error) {
	fake.putItemWithContextMutex.Lock()
	defer fake.putItemWithContextMutex.Unlock()
	fake.PutItemWithContextStub = nil
	if fake.putItemWithContextReturnsOnCall == nil {
		fake.putItemWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.PutItemOutput
			result2 error
		})
	}
	fake.putItemWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.PutItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) Query(arg1 *dynamodba.QueryInput) (*dynamodba.QueryOutput, error) {
	fake.queryMutex.Lock()
	ret, specificReturn := fake.queryReturnsOnCall[len(fake.queryArgsForCall)]
	fake.queryArgsForCall = append(fake.queryArgsForCall, struct {
		arg1 *dynamodba.QueryInput
	}{arg1})
	fake.recordInvocation("Query", []interface{}{arg1})
	fake.queryMutex.Unlock()
	if fake.QueryStub != nil {
		return fake.QueryStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.queryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) QueryCallCount() int {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	return len(fake.queryArgsForCall)
}

func (fake *FakeDynamoDB) QueryCalls(stub func(*dynamodba.QueryInput) (*dynamodba.QueryOutput, error)) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = stub
}

func (fake *FakeDynamoDB) QueryArgsForCall(i int) *dynamodba.QueryInput {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	argsForCall := fake.queryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) QueryReturns(result1 *dynamodba.QueryOutput, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	fake.queryReturns = struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) QueryReturnsOnCall(i int, result1 *dynamodba.QueryOutput, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	if fake.queryReturnsOnCall == nil {
		fake.queryReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.QueryOutput
			result2 error
		})
	}
	fake.queryReturnsOnCall[i] = struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) QueryPages(arg1 *dynamodba.QueryInput, arg2 func(*dynamodba.QueryOutput, bool) bool) error {
	fake.queryPagesMutex.Lock()
	ret, specificReturn := fake.queryPagesReturnsOnCall[len(fake.queryPagesArgsForCall)]
	fake.queryPagesArgsForCall = append(fake.queryPagesArgsForCall, struct {
		arg1 *dynamodba.QueryInput
		arg2 func(*dynamodba.QueryOutput, bool) bool
	}{arg1, arg2})
	fake.recordInvocation("QueryPages", []interface{}{arg1, arg2})
	fake.queryPagesMutex.Unlock()
	if fake.QueryPagesStub != nil {
		return fake.QueryPagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.queryPagesReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) QueryPagesCallCount() int {
	fake.queryPagesMutex.RLock()
	defer fake.queryPagesMutex.RUnlock()
	return len(fake.queryPagesArgsForCall)
}

func (fake *FakeDynamoDB) QueryPagesCalls(stub func(*dynamodba.QueryInput, func(*dynamodba.QueryOutput, bool) bool) error) {
	fake.queryPagesMutex.Lock()
	defer fake.queryPagesMutex.Unlock()
	fake.QueryPagesStub = stub
}

func (fake *FakeDynamoDB) QueryPagesArgsForCall(i int) (*dynamodba.QueryInput, func(*dynamodba.QueryOutput, bool) bool) {
	fake.queryPagesMutex.RLock()
	defer fake.queryPagesMutex.RUnlock()
	argsForCall := fake.queryPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDynamoDB) QueryPagesReturns(result1 error) {
	fake.queryPagesMutex.Lock()
	defer fake.queryPagesMutex.Unlock()
	fake.QueryPagesStub = nil
	fake.queryPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) QueryPagesReturnsOnCall(i int, result1 error) {
	fake.queryPagesMutex.Lock()
	defer fake.queryPagesMutex.Unlock()
	fake.QueryPagesStub = nil
	if fake.queryPagesReturnsOnCall == nil {
		fake.queryPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.queryPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) QueryPagesWithContext(arg1 context.Context, arg2 *dynamodba.QueryInput, arg3 func(*dynamodba.QueryOutput, bool) bool, arg4 ...request.Option) error {
	fake.queryPagesWithContextMutex.Lock()
	ret, specificReturn := fake.queryPagesWithContextReturnsOnCall[len(fake.queryPagesWithContextArgsForCall)]
	fake.queryPagesWithContextArgsForCall = append(fake.queryPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.QueryInput
		arg3 func(*dynamodba.QueryOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("QueryPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.queryPagesWithContextMutex.Unlock()
	if fake.QueryPagesWithContextStub != nil {
		return fake.QueryPagesWithContextStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.queryPagesWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) QueryPagesWithContextCallCount() int {
	fake.queryPagesWithContextMutex.RLock()
	defer fake.queryPagesWithContextMutex.RUnlock()
	return len(fake.queryPagesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) QueryPagesWithContextCalls(stub func(context.Context, *dynamodba.QueryInput, func(*dynamodba.QueryOutput, bool) bool, ...request.Option) error) {
	fake.queryPagesWithContextMutex.Lock()
	defer fake.queryPagesWithContextMutex.Unlock()
	fake.QueryPagesWithContextStub = stub
}

func (fake *FakeDynamoDB) QueryPagesWithContextArgsForCall(i int) (context.Context, *dynamodba.QueryInput, func(*dynamodba.QueryOutput, bool) bool, []request.Option) {
	fake.queryPagesWithContextMutex.RLock()
	defer fake.queryPagesWithContextMutex.RUnlock()
	argsForCall := fake.queryPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDynamoDB) QueryPagesWithContextReturns(result1 error) {
	fake.queryPagesWithContextMutex.Lock()
	defer fake.queryPagesWithContextMutex.Unlock()
	fake.QueryPagesWithContextStub = nil
	fake.queryPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) QueryPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.queryPagesWithContextMutex.Lock()
	defer fake.queryPagesWithContextMutex.Unlock()
	fake.QueryPagesWithContextStub = nil
	if fake.queryPagesWithContextReturnsOnCall == nil {
		fake.queryPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.queryPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) QueryRequest(arg1 *dynamodba.QueryInput) (*request.Request, *dynamodba.QueryOutput) {
	fake.queryRequestMutex.Lock()
	ret, specificReturn := fake.queryRequestReturnsOnCall[len(fake.queryRequestArgsForCall)]
	fake.queryRequestArgsForCall = append(fake.queryRequestArgsForCall, struct {
		arg1 *dynamodba.QueryInput
	}{arg1})
	fake.recordInvocation("QueryRequest", []interface{}{arg1})
	fake.queryRequestMutex.Unlock()
	if fake.QueryRequestStub != nil {
		return fake.QueryRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.queryRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) QueryRequestCallCount() int {
	fake.queryRequestMutex.RLock()
	defer fake.queryRequestMutex.RUnlock()
	return len(fake.queryRequestArgsForCall)
}

func (fake *FakeDynamoDB) QueryRequestCalls(stub func(*dynamodba.QueryInput) (*request.Request, *dynamodba.QueryOutput)) {
	fake.queryRequestMutex.Lock()
	defer fake.queryRequestMutex.Unlock()
	fake.QueryRequestStub = stub
}

func (fake *FakeDynamoDB) QueryRequestArgsForCall(i int) *dynamodba.QueryInput {
	fake.queryRequestMutex.RLock()
	defer fake.queryRequestMutex.RUnlock()
	argsForCall := fake.queryRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) QueryRequestReturns(result1 *request.Request, result2 *dynamodba.QueryOutput) {
	fake.queryRequestMutex.Lock()
	defer fake.queryRequestMutex.Unlock()
	fake.QueryRequestStub = nil
	fake.queryRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.QueryOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) QueryRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.QueryOutput) {
	fake.queryRequestMutex.Lock()
	defer fake.queryRequestMutex.Unlock()
	fake.QueryRequestStub = nil
	if fake.queryRequestReturnsOnCall == nil {
		fake.queryRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.QueryOutput
		})
	}
	fake.queryRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.QueryOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) QueryWithContext(arg1 context.Context, arg2 *dynamodba.QueryInput, arg3 ...request.Option) (*dynamodba.QueryOutput, error) {
	fake.queryWithContextMutex.Lock()
	ret, specificReturn := fake.queryWithContextReturnsOnCall[len(fake.queryWithContextArgsForCall)]
	fake.queryWithContextArgsForCall = append(fake.queryWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.QueryInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("QueryWithContext", []interface{}{arg1, arg2, arg3})
	fake.queryWithContextMutex.Unlock()
	if fake.QueryWithContextStub != nil {
		return fake.QueryWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.queryWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) QueryWithContextCallCount() int {
	fake.queryWithContextMutex.RLock()
	defer fake.queryWithContextMutex.RUnlock()
	return len(fake.queryWithContextArgsForCall)
}

func (fake *FakeDynamoDB) QueryWithContextCalls(stub func(context.Context, *dynamodba.QueryInput, ...request.Option) (*dynamodba.QueryOutput, error)) {
	fake.queryWithContextMutex.Lock()
	defer fake.queryWithContextMutex.Unlock()
	fake.QueryWithContextStub = stub
}

func (fake *FakeDynamoDB) QueryWithContextArgsForCall(i int) (context.Context, *dynamodba.QueryInput, []request.Option) {
	fake.queryWithContextMutex.RLock()
	defer fake.queryWithContextMutex.RUnlock()
	argsForCall := fake.queryWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) QueryWithContextReturns(result1 *dynamodba.QueryOutput, result2 error) {
	fake.queryWithContextMutex.Lock()
	defer fake.queryWithContextMutex.Unlock()
	fake.QueryWithContextStub = nil
	fake.queryWithContextReturns = struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) QueryWithContextReturnsOnCall(i int, result1 *dynamodba.QueryOutput, result2 error) {
	fake.queryWithContextMutex.Lock()
	defer fake.queryWithContextMutex.Unlock()
	fake.QueryWithContextStub = nil
	if fake.queryWithContextReturnsOnCall == nil {
		fake.queryWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.QueryOutput
			result2 error
		})
	}
	fake.queryWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.QueryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableFromBackup(arg1 *dynamodba.RestoreTableFromBackupInput) (*dynamodba.RestoreTableFromBackupOutput, error) {
	fake.restoreTableFromBackupMutex.Lock()
	ret, specificReturn := fake.restoreTableFromBackupReturnsOnCall[len(fake.restoreTableFromBackupArgsForCall)]
	fake.restoreTableFromBackupArgsForCall = append(fake.restoreTableFromBackupArgsForCall, struct {
		arg1 *dynamodba.RestoreTableFromBackupInput
	}{arg1})
	fake.recordInvocation("RestoreTableFromBackup", []interface{}{arg1})
	fake.restoreTableFromBackupMutex.Unlock()
	if fake.RestoreTableFromBackupStub != nil {
		return fake.RestoreTableFromBackupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.restoreTableFromBackupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) RestoreTableFromBackupCallCount() int {
	fake.restoreTableFromBackupMutex.RLock()
	defer fake.restoreTableFromBackupMutex.RUnlock()
	return len(fake.restoreTableFromBackupArgsForCall)
}

func (fake *FakeDynamoDB) RestoreTableFromBackupCalls(stub func(*dynamodba.RestoreTableFromBackupInput) (*dynamodba.RestoreTableFromBackupOutput, error)) {
	fake.restoreTableFromBackupMutex.Lock()
	defer fake.restoreTableFromBackupMutex.Unlock()
	fake.RestoreTableFromBackupStub = stub
}

func (fake *FakeDynamoDB) RestoreTableFromBackupArgsForCall(i int) *dynamodba.RestoreTableFromBackupInput {
	fake.restoreTableFromBackupMutex.RLock()
	defer fake.restoreTableFromBackupMutex.RUnlock()
	argsForCall := fake.restoreTableFromBackupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) RestoreTableFromBackupReturns(result1 *dynamodba.RestoreTableFromBackupOutput, result2 error) {
	fake.restoreTableFromBackupMutex.Lock()
	defer fake.restoreTableFromBackupMutex.Unlock()
	fake.RestoreTableFromBackupStub = nil
	fake.restoreTableFromBackupReturns = struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableFromBackupReturnsOnCall(i int, result1 *dynamodba.RestoreTableFromBackupOutput, result2 error) {
	fake.restoreTableFromBackupMutex.Lock()
	defer fake.restoreTableFromBackupMutex.Unlock()
	fake.RestoreTableFromBackupStub = nil
	if fake.restoreTableFromBackupReturnsOnCall == nil {
		fake.restoreTableFromBackupReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.RestoreTableFromBackupOutput
			result2 error
		})
	}
	fake.restoreTableFromBackupReturnsOnCall[i] = struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableFromBackupRequest(arg1 *dynamodba.RestoreTableFromBackupInput) (*request.Request, *dynamodba.RestoreTableFromBackupOutput) {
	fake.restoreTableFromBackupRequestMutex.Lock()
	ret, specificReturn := fake.restoreTableFromBackupRequestReturnsOnCall[len(fake.restoreTableFromBackupRequestArgsForCall)]
	fake.restoreTableFromBackupRequestArgsForCall = append(fake.restoreTableFromBackupRequestArgsForCall, struct {
		arg1 *dynamodba.RestoreTableFromBackupInput
	}{arg1})
	fake.recordInvocation("RestoreTableFromBackupRequest", []interface{}{arg1})
	fake.restoreTableFromBackupRequestMutex.Unlock()
	if fake.RestoreTableFromBackupRequestStub != nil {
		return fake.RestoreTableFromBackupRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.restoreTableFromBackupRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) RestoreTableFromBackupRequestCallCount() int {
	fake.restoreTableFromBackupRequestMutex.RLock()
	defer fake.restoreTableFromBackupRequestMutex.RUnlock()
	return len(fake.restoreTableFromBackupRequestArgsForCall)
}

func (fake *FakeDynamoDB) RestoreTableFromBackupRequestCalls(stub func(*dynamodba.RestoreTableFromBackupInput) (*request.Request, *dynamodba.RestoreTableFromBackupOutput)) {
	fake.restoreTableFromBackupRequestMutex.Lock()
	defer fake.restoreTableFromBackupRequestMutex.Unlock()
	fake.RestoreTableFromBackupRequestStub = stub
}

func (fake *FakeDynamoDB) RestoreTableFromBackupRequestArgsForCall(i int) *dynamodba.RestoreTableFromBackupInput {
	fake.restoreTableFromBackupRequestMutex.RLock()
	defer fake.restoreTableFromBackupRequestMutex.RUnlock()
	argsForCall := fake.restoreTableFromBackupRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) RestoreTableFromBackupRequestReturns(result1 *request.Request, result2 *dynamodba.RestoreTableFromBackupOutput) {
	fake.restoreTableFromBackupRequestMutex.Lock()
	defer fake.restoreTableFromBackupRequestMutex.Unlock()
	fake.RestoreTableFromBackupRequestStub = nil
	fake.restoreTableFromBackupRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableFromBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableFromBackupRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.RestoreTableFromBackupOutput) {
	fake.restoreTableFromBackupRequestMutex.Lock()
	defer fake.restoreTableFromBackupRequestMutex.Unlock()
	fake.RestoreTableFromBackupRequestStub = nil
	if fake.restoreTableFromBackupRequestReturnsOnCall == nil {
		fake.restoreTableFromBackupRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.RestoreTableFromBackupOutput
		})
	}
	fake.restoreTableFromBackupRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableFromBackupOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableFromBackupWithContext(arg1 context.Context, arg2 *dynamodba.RestoreTableFromBackupInput, arg3 ...request.Option) (*dynamodba.RestoreTableFromBackupOutput, error) {
	fake.restoreTableFromBackupWithContextMutex.Lock()
	ret, specificReturn := fake.restoreTableFromBackupWithContextReturnsOnCall[len(fake.restoreTableFromBackupWithContextArgsForCall)]
	fake.restoreTableFromBackupWithContextArgsForCall = append(fake.restoreTableFromBackupWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.RestoreTableFromBackupInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("RestoreTableFromBackupWithContext", []interface{}{arg1, arg2, arg3})
	fake.restoreTableFromBackupWithContextMutex.Unlock()
	if fake.RestoreTableFromBackupWithContextStub != nil {
		return fake.RestoreTableFromBackupWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.restoreTableFromBackupWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) RestoreTableFromBackupWithContextCallCount() int {
	fake.restoreTableFromBackupWithContextMutex.RLock()
	defer fake.restoreTableFromBackupWithContextMutex.RUnlock()
	return len(fake.restoreTableFromBackupWithContextArgsForCall)
}

func (fake *FakeDynamoDB) RestoreTableFromBackupWithContextCalls(stub func(context.Context, *dynamodba.RestoreTableFromBackupInput, ...request.Option) (*dynamodba.RestoreTableFromBackupOutput, error)) {
	fake.restoreTableFromBackupWithContextMutex.Lock()
	defer fake.restoreTableFromBackupWithContextMutex.Unlock()
	fake.RestoreTableFromBackupWithContextStub = stub
}

func (fake *FakeDynamoDB) RestoreTableFromBackupWithContextArgsForCall(i int) (context.Context, *dynamodba.RestoreTableFromBackupInput, []request.Option) {
	fake.restoreTableFromBackupWithContextMutex.RLock()
	defer fake.restoreTableFromBackupWithContextMutex.RUnlock()
	argsForCall := fake.restoreTableFromBackupWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) RestoreTableFromBackupWithContextReturns(result1 *dynamodba.RestoreTableFromBackupOutput, result2 error) {
	fake.restoreTableFromBackupWithContextMutex.Lock()
	defer fake.restoreTableFromBackupWithContextMutex.Unlock()
	fake.RestoreTableFromBackupWithContextStub = nil
	fake.restoreTableFromBackupWithContextReturns = struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableFromBackupWithContextReturnsOnCall(i int, result1 *dynamodba.RestoreTableFromBackupOutput, result2 error) {
	fake.restoreTableFromBackupWithContextMutex.Lock()
	defer fake.restoreTableFromBackupWithContextMutex.Unlock()
	fake.RestoreTableFromBackupWithContextStub = nil
	if fake.restoreTableFromBackupWithContextReturnsOnCall == nil {
		fake.restoreTableFromBackupWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.RestoreTableFromBackupOutput
			result2 error
		})
	}
	fake.restoreTableFromBackupWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.RestoreTableFromBackupOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableToPointInTime(arg1 *dynamodba.RestoreTableToPointInTimeInput) (*dynamodba.RestoreTableToPointInTimeOutput, error) {
	fake.restoreTableToPointInTimeMutex.Lock()
	ret, specificReturn := fake.restoreTableToPointInTimeReturnsOnCall[len(fake.restoreTableToPointInTimeArgsForCall)]
	fake.restoreTableToPointInTimeArgsForCall = append(fake.restoreTableToPointInTimeArgsForCall, struct {
		arg1 *dynamodba.RestoreTableToPointInTimeInput
	}{arg1})
	fake.recordInvocation("RestoreTableToPointInTime", []interface{}{arg1})
	fake.restoreTableToPointInTimeMutex.Unlock()
	if fake.RestoreTableToPointInTimeStub != nil {
		return fake.RestoreTableToPointInTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.restoreTableToPointInTimeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeCallCount() int {
	fake.restoreTableToPointInTimeMutex.RLock()
	defer fake.restoreTableToPointInTimeMutex.RUnlock()
	return len(fake.restoreTableToPointInTimeArgsForCall)
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeCalls(stub func(*dynamodba.RestoreTableToPointInTimeInput) (*dynamodba.RestoreTableToPointInTimeOutput, error)) {
	fake.restoreTableToPointInTimeMutex.Lock()
	defer fake.restoreTableToPointInTimeMutex.Unlock()
	fake.RestoreTableToPointInTimeStub = stub
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeArgsForCall(i int) *dynamodba.RestoreTableToPointInTimeInput {
	fake.restoreTableToPointInTimeMutex.RLock()
	defer fake.restoreTableToPointInTimeMutex.RUnlock()
	argsForCall := fake.restoreTableToPointInTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeReturns(result1 *dynamodba.RestoreTableToPointInTimeOutput, result2 error) {
	fake.restoreTableToPointInTimeMutex.Lock()
	defer fake.restoreTableToPointInTimeMutex.Unlock()
	fake.RestoreTableToPointInTimeStub = nil
	fake.restoreTableToPointInTimeReturns = struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeReturnsOnCall(i int, result1 *dynamodba.RestoreTableToPointInTimeOutput, result2 error) {
	fake.restoreTableToPointInTimeMutex.Lock()
	defer fake.restoreTableToPointInTimeMutex.Unlock()
	fake.RestoreTableToPointInTimeStub = nil
	if fake.restoreTableToPointInTimeReturnsOnCall == nil {
		fake.restoreTableToPointInTimeReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.RestoreTableToPointInTimeOutput
			result2 error
		})
	}
	fake.restoreTableToPointInTimeReturnsOnCall[i] = struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeRequest(arg1 *dynamodba.RestoreTableToPointInTimeInput) (*request.Request, *dynamodba.RestoreTableToPointInTimeOutput) {
	fake.restoreTableToPointInTimeRequestMutex.Lock()
	ret, specificReturn := fake.restoreTableToPointInTimeRequestReturnsOnCall[len(fake.restoreTableToPointInTimeRequestArgsForCall)]
	fake.restoreTableToPointInTimeRequestArgsForCall = append(fake.restoreTableToPointInTimeRequestArgsForCall, struct {
		arg1 *dynamodba.RestoreTableToPointInTimeInput
	}{arg1})
	fake.recordInvocation("RestoreTableToPointInTimeRequest", []interface{}{arg1})
	fake.restoreTableToPointInTimeRequestMutex.Unlock()
	if fake.RestoreTableToPointInTimeRequestStub != nil {
		return fake.RestoreTableToPointInTimeRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.restoreTableToPointInTimeRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeRequestCallCount() int {
	fake.restoreTableToPointInTimeRequestMutex.RLock()
	defer fake.restoreTableToPointInTimeRequestMutex.RUnlock()
	return len(fake.restoreTableToPointInTimeRequestArgsForCall)
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeRequestCalls(stub func(*dynamodba.RestoreTableToPointInTimeInput) (*request.Request, *dynamodba.RestoreTableToPointInTimeOutput)) {
	fake.restoreTableToPointInTimeRequestMutex.Lock()
	defer fake.restoreTableToPointInTimeRequestMutex.Unlock()
	fake.RestoreTableToPointInTimeRequestStub = stub
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeRequestArgsForCall(i int) *dynamodba.RestoreTableToPointInTimeInput {
	fake.restoreTableToPointInTimeRequestMutex.RLock()
	defer fake.restoreTableToPointInTimeRequestMutex.RUnlock()
	argsForCall := fake.restoreTableToPointInTimeRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeRequestReturns(result1 *request.Request, result2 *dynamodba.RestoreTableToPointInTimeOutput) {
	fake.restoreTableToPointInTimeRequestMutex.Lock()
	defer fake.restoreTableToPointInTimeRequestMutex.Unlock()
	fake.RestoreTableToPointInTimeRequestStub = nil
	fake.restoreTableToPointInTimeRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableToPointInTimeOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.RestoreTableToPointInTimeOutput) {
	fake.restoreTableToPointInTimeRequestMutex.Lock()
	defer fake.restoreTableToPointInTimeRequestMutex.Unlock()
	fake.RestoreTableToPointInTimeRequestStub = nil
	if fake.restoreTableToPointInTimeRequestReturnsOnCall == nil {
		fake.restoreTableToPointInTimeRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.RestoreTableToPointInTimeOutput
		})
	}
	fake.restoreTableToPointInTimeRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.RestoreTableToPointInTimeOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeWithContext(arg1 context.Context, arg2 *dynamodba.RestoreTableToPointInTimeInput, arg3 ...request.Option) (*dynamodba.RestoreTableToPointInTimeOutput, error) {
	fake.restoreTableToPointInTimeWithContextMutex.Lock()
	ret, specificReturn := fake.restoreTableToPointInTimeWithContextReturnsOnCall[len(fake.restoreTableToPointInTimeWithContextArgsForCall)]
	fake.restoreTableToPointInTimeWithContextArgsForCall = append(fake.restoreTableToPointInTimeWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.RestoreTableToPointInTimeInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("RestoreTableToPointInTimeWithContext", []interface{}{arg1, arg2, arg3})
	fake.restoreTableToPointInTimeWithContextMutex.Unlock()
	if fake.RestoreTableToPointInTimeWithContextStub != nil {
		return fake.RestoreTableToPointInTimeWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.restoreTableToPointInTimeWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeWithContextCallCount() int {
	fake.restoreTableToPointInTimeWithContextMutex.RLock()
	defer fake.restoreTableToPointInTimeWithContextMutex.RUnlock()
	return len(fake.restoreTableToPointInTimeWithContextArgsForCall)
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeWithContextCalls(stub func(context.Context, *dynamodba.RestoreTableToPointInTimeInput, ...request.Option) (*dynamodba.RestoreTableToPointInTimeOutput, error)) {
	fake.restoreTableToPointInTimeWithContextMutex.Lock()
	defer fake.restoreTableToPointInTimeWithContextMutex.Unlock()
	fake.RestoreTableToPointInTimeWithContextStub = stub
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeWithContextArgsForCall(i int) (context.Context, *dynamodba.RestoreTableToPointInTimeInput, []request.Option) {
	fake.restoreTableToPointInTimeWithContextMutex.RLock()
	defer fake.restoreTableToPointInTimeWithContextMutex.RUnlock()
	argsForCall := fake.restoreTableToPointInTimeWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeWithContextReturns(result1 *dynamodba.RestoreTableToPointInTimeOutput, result2 error) {
	fake.restoreTableToPointInTimeWithContextMutex.Lock()
	defer fake.restoreTableToPointInTimeWithContextMutex.Unlock()
	fake.RestoreTableToPointInTimeWithContextStub = nil
	fake.restoreTableToPointInTimeWithContextReturns = struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) RestoreTableToPointInTimeWithContextReturnsOnCall(i int, result1 *dynamodba.RestoreTableToPointInTimeOutput, result2 error) {
	fake.restoreTableToPointInTimeWithContextMutex.Lock()
	defer fake.restoreTableToPointInTimeWithContextMutex.Unlock()
	fake.RestoreTableToPointInTimeWithContextStub = nil
	if fake.restoreTableToPointInTimeWithContextReturnsOnCall == nil {
		fake.restoreTableToPointInTimeWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.RestoreTableToPointInTimeOutput
			result2 error
		})
	}
	fake.restoreTableToPointInTimeWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.RestoreTableToPointInTimeOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) Scan(arg1 *dynamodba.ScanInput) (*dynamodba.ScanOutput, error) {
	fake.scanMutex.Lock()
	ret, specificReturn := fake.scanReturnsOnCall[len(fake.scanArgsForCall)]
	fake.scanArgsForCall = append(fake.scanArgsForCall, struct {
		arg1 *dynamodba.ScanInput
	}{arg1})
	fake.recordInvocation("Scan", []interface{}{arg1})
	fake.scanMutex.Unlock()
	if fake.ScanStub != nil {
		return fake.ScanStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.scanReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ScanCallCount() int {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	return len(fake.scanArgsForCall)
}

func (fake *FakeDynamoDB) ScanCalls(stub func(*dynamodba.ScanInput) (*dynamodba.ScanOutput, error)) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = stub
}

func (fake *FakeDynamoDB) ScanArgsForCall(i int) *dynamodba.ScanInput {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	argsForCall := fake.scanArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ScanReturns(result1 *dynamodba.ScanOutput, result2 error) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = nil
	fake.scanReturns = struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ScanReturnsOnCall(i int, result1 *dynamodba.ScanOutput, result2 error) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = nil
	if fake.scanReturnsOnCall == nil {
		fake.scanReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ScanOutput
			result2 error
		})
	}
	fake.scanReturnsOnCall[i] = struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ScanPages(arg1 *dynamodba.ScanInput, arg2 func(*dynamodba.ScanOutput, bool) bool) error {
	fake.scanPagesMutex.Lock()
	ret, specificReturn := fake.scanPagesReturnsOnCall[len(fake.scanPagesArgsForCall)]
	fake.scanPagesArgsForCall = append(fake.scanPagesArgsForCall, struct {
		arg1 *dynamodba.ScanInput
		arg2 func(*dynamodba.ScanOutput, bool) bool
	}{arg1, arg2})
	fake.recordInvocation("ScanPages", []interface{}{arg1, arg2})
	fake.scanPagesMutex.Unlock()
	if fake.ScanPagesStub != nil {
		return fake.ScanPagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.scanPagesReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ScanPagesCallCount() int {
	fake.scanPagesMutex.RLock()
	defer fake.scanPagesMutex.RUnlock()
	return len(fake.scanPagesArgsForCall)
}

func (fake *FakeDynamoDB) ScanPagesCalls(stub func(*dynamodba.ScanInput, func(*dynamodba.ScanOutput, bool) bool) error) {
	fake.scanPagesMutex.Lock()
	defer fake.scanPagesMutex.Unlock()
	fake.ScanPagesStub = stub
}

func (fake *FakeDynamoDB) ScanPagesArgsForCall(i int) (*dynamodba.ScanInput, func(*dynamodba.ScanOutput, bool) bool) {
	fake.scanPagesMutex.RLock()
	defer fake.scanPagesMutex.RUnlock()
	argsForCall := fake.scanPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDynamoDB) ScanPagesReturns(result1 error) {
	fake.scanPagesMutex.Lock()
	defer fake.scanPagesMutex.Unlock()
	fake.ScanPagesStub = nil
	fake.scanPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ScanPagesReturnsOnCall(i int, result1 error) {
	fake.scanPagesMutex.Lock()
	defer fake.scanPagesMutex.Unlock()
	fake.ScanPagesStub = nil
	if fake.scanPagesReturnsOnCall == nil {
		fake.scanPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ScanPagesWithContext(arg1 context.Context, arg2 *dynamodba.ScanInput, arg3 func(*dynamodba.ScanOutput, bool) bool, arg4 ...request.Option) error {
	fake.scanPagesWithContextMutex.Lock()
	ret, specificReturn := fake.scanPagesWithContextReturnsOnCall[len(fake.scanPagesWithContextArgsForCall)]
	fake.scanPagesWithContextArgsForCall = append(fake.scanPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ScanInput
		arg3 func(*dynamodba.ScanOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ScanPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.scanPagesWithContextMutex.Unlock()
	if fake.ScanPagesWithContextStub != nil {
		return fake.ScanPagesWithContextStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.scanPagesWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) ScanPagesWithContextCallCount() int {
	fake.scanPagesWithContextMutex.RLock()
	defer fake.scanPagesWithContextMutex.RUnlock()
	return len(fake.scanPagesWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ScanPagesWithContextCalls(stub func(context.Context, *dynamodba.ScanInput, func(*dynamodba.ScanOutput, bool) bool, ...request.Option) error) {
	fake.scanPagesWithContextMutex.Lock()
	defer fake.scanPagesWithContextMutex.Unlock()
	fake.ScanPagesWithContextStub = stub
}

func (fake *FakeDynamoDB) ScanPagesWithContextArgsForCall(i int) (context.Context, *dynamodba.ScanInput, func(*dynamodba.ScanOutput, bool) bool, []request.Option) {
	fake.scanPagesWithContextMutex.RLock()
	defer fake.scanPagesWithContextMutex.RUnlock()
	argsForCall := fake.scanPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDynamoDB) ScanPagesWithContextReturns(result1 error) {
	fake.scanPagesWithContextMutex.Lock()
	defer fake.scanPagesWithContextMutex.Unlock()
	fake.ScanPagesWithContextStub = nil
	fake.scanPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ScanPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.scanPagesWithContextMutex.Lock()
	defer fake.scanPagesWithContextMutex.Unlock()
	fake.ScanPagesWithContextStub = nil
	if fake.scanPagesWithContextReturnsOnCall == nil {
		fake.scanPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) ScanRequest(arg1 *dynamodba.ScanInput) (*request.Request, *dynamodba.ScanOutput) {
	fake.scanRequestMutex.Lock()
	ret, specificReturn := fake.scanRequestReturnsOnCall[len(fake.scanRequestArgsForCall)]
	fake.scanRequestArgsForCall = append(fake.scanRequestArgsForCall, struct {
		arg1 *dynamodba.ScanInput
	}{arg1})
	fake.recordInvocation("ScanRequest", []interface{}{arg1})
	fake.scanRequestMutex.Unlock()
	if fake.ScanRequestStub != nil {
		return fake.ScanRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.scanRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ScanRequestCallCount() int {
	fake.scanRequestMutex.RLock()
	defer fake.scanRequestMutex.RUnlock()
	return len(fake.scanRequestArgsForCall)
}

func (fake *FakeDynamoDB) ScanRequestCalls(stub func(*dynamodba.ScanInput) (*request.Request, *dynamodba.ScanOutput)) {
	fake.scanRequestMutex.Lock()
	defer fake.scanRequestMutex.Unlock()
	fake.ScanRequestStub = stub
}

func (fake *FakeDynamoDB) ScanRequestArgsForCall(i int) *dynamodba.ScanInput {
	fake.scanRequestMutex.RLock()
	defer fake.scanRequestMutex.RUnlock()
	argsForCall := fake.scanRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) ScanRequestReturns(result1 *request.Request, result2 *dynamodba.ScanOutput) {
	fake.scanRequestMutex.Lock()
	defer fake.scanRequestMutex.Unlock()
	fake.ScanRequestStub = nil
	fake.scanRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.ScanOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ScanRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.ScanOutput) {
	fake.scanRequestMutex.Lock()
	defer fake.scanRequestMutex.Unlock()
	fake.ScanRequestStub = nil
	if fake.scanRequestReturnsOnCall == nil {
		fake.scanRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.ScanOutput
		})
	}
	fake.scanRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.ScanOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) ScanWithContext(arg1 context.Context, arg2 *dynamodba.ScanInput, arg3 ...request.Option) (*dynamodba.ScanOutput, error) {
	fake.scanWithContextMutex.Lock()
	ret, specificReturn := fake.scanWithContextReturnsOnCall[len(fake.scanWithContextArgsForCall)]
	fake.scanWithContextArgsForCall = append(fake.scanWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.ScanInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("ScanWithContext", []interface{}{arg1, arg2, arg3})
	fake.scanWithContextMutex.Unlock()
	if fake.ScanWithContextStub != nil {
		return fake.ScanWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.scanWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) ScanWithContextCallCount() int {
	fake.scanWithContextMutex.RLock()
	defer fake.scanWithContextMutex.RUnlock()
	return len(fake.scanWithContextArgsForCall)
}

func (fake *FakeDynamoDB) ScanWithContextCalls(stub func(context.Context, *dynamodba.ScanInput, ...request.Option) (*dynamodba.ScanOutput, error)) {
	fake.scanWithContextMutex.Lock()
	defer fake.scanWithContextMutex.Unlock()
	fake.ScanWithContextStub = stub
}

func (fake *FakeDynamoDB) ScanWithContextArgsForCall(i int) (context.Context, *dynamodba.ScanInput, []request.Option) {
	fake.scanWithContextMutex.RLock()
	defer fake.scanWithContextMutex.RUnlock()
	argsForCall := fake.scanWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) ScanWithContextReturns(result1 *dynamodba.ScanOutput, result2 error) {
	fake.scanWithContextMutex.Lock()
	defer fake.scanWithContextMutex.Unlock()
	fake.ScanWithContextStub = nil
	fake.scanWithContextReturns = struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) ScanWithContextReturnsOnCall(i int, result1 *dynamodba.ScanOutput, result2 error) {
	fake.scanWithContextMutex.Lock()
	defer fake.scanWithContextMutex.Unlock()
	fake.ScanWithContextStub = nil
	if fake.scanWithContextReturnsOnCall == nil {
		fake.scanWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.ScanOutput
			result2 error
		})
	}
	fake.scanWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.ScanOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TagResource(arg1 *dynamodba.TagResourceInput) (*dynamodba.TagResourceOutput, error) {
	fake.tagResourceMutex.Lock()
	ret, specificReturn := fake.tagResourceReturnsOnCall[len(fake.tagResourceArgsForCall)]
	fake.tagResourceArgsForCall = append(fake.tagResourceArgsForCall, struct {
		arg1 *dynamodba.TagResourceInput
	}{arg1})
	fake.recordInvocation("TagResource", []interface{}{arg1})
	fake.tagResourceMutex.Unlock()
	if fake.TagResourceStub != nil {
		return fake.TagResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tagResourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TagResourceCallCount() int {
	fake.tagResourceMutex.RLock()
	defer fake.tagResourceMutex.RUnlock()
	return len(fake.tagResourceArgsForCall)
}

func (fake *FakeDynamoDB) TagResourceCalls(stub func(*dynamodba.TagResourceInput) (*dynamodba.TagResourceOutput, error)) {
	fake.tagResourceMutex.Lock()
	defer fake.tagResourceMutex.Unlock()
	fake.TagResourceStub = stub
}

func (fake *FakeDynamoDB) TagResourceArgsForCall(i int) *dynamodba.TagResourceInput {
	fake.tagResourceMutex.RLock()
	defer fake.tagResourceMutex.RUnlock()
	argsForCall := fake.tagResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) TagResourceReturns(result1 *dynamodba.TagResourceOutput, result2 error) {
	fake.tagResourceMutex.Lock()
	defer fake.tagResourceMutex.Unlock()
	fake.TagResourceStub = nil
	fake.tagResourceReturns = struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TagResourceReturnsOnCall(i int, result1 *dynamodba.TagResourceOutput, result2 error) {
	fake.tagResourceMutex.Lock()
	defer fake.tagResourceMutex.Unlock()
	fake.TagResourceStub = nil
	if fake.tagResourceReturnsOnCall == nil {
		fake.tagResourceReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.TagResourceOutput
			result2 error
		})
	}
	fake.tagResourceReturnsOnCall[i] = struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TagResourceRequest(arg1 *dynamodba.TagResourceInput) (*request.Request, *dynamodba.TagResourceOutput) {
	fake.tagResourceRequestMutex.Lock()
	ret, specificReturn := fake.tagResourceRequestReturnsOnCall[len(fake.tagResourceRequestArgsForCall)]
	fake.tagResourceRequestArgsForCall = append(fake.tagResourceRequestArgsForCall, struct {
		arg1 *dynamodba.TagResourceInput
	}{arg1})
	fake.recordInvocation("TagResourceRequest", []interface{}{arg1})
	fake.tagResourceRequestMutex.Unlock()
	if fake.TagResourceRequestStub != nil {
		return fake.TagResourceRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tagResourceRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TagResourceRequestCallCount() int {
	fake.tagResourceRequestMutex.RLock()
	defer fake.tagResourceRequestMutex.RUnlock()
	return len(fake.tagResourceRequestArgsForCall)
}

func (fake *FakeDynamoDB) TagResourceRequestCalls(stub func(*dynamodba.TagResourceInput) (*request.Request, *dynamodba.TagResourceOutput)) {
	fake.tagResourceRequestMutex.Lock()
	defer fake.tagResourceRequestMutex.Unlock()
	fake.TagResourceRequestStub = stub
}

func (fake *FakeDynamoDB) TagResourceRequestArgsForCall(i int) *dynamodba.TagResourceInput {
	fake.tagResourceRequestMutex.RLock()
	defer fake.tagResourceRequestMutex.RUnlock()
	argsForCall := fake.tagResourceRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) TagResourceRequestReturns(result1 *request.Request, result2 *dynamodba.TagResourceOutput) {
	fake.tagResourceRequestMutex.Lock()
	defer fake.tagResourceRequestMutex.Unlock()
	fake.TagResourceRequestStub = nil
	fake.tagResourceRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.TagResourceOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) TagResourceRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.TagResourceOutput) {
	fake.tagResourceRequestMutex.Lock()
	defer fake.tagResourceRequestMutex.Unlock()
	fake.TagResourceRequestStub = nil
	if fake.tagResourceRequestReturnsOnCall == nil {
		fake.tagResourceRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.TagResourceOutput
		})
	}
	fake.tagResourceRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.TagResourceOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) TagResourceWithContext(arg1 context.Context, arg2 *dynamodba.TagResourceInput, arg3 ...request.Option) (*dynamodba.TagResourceOutput, error) {
	fake.tagResourceWithContextMutex.Lock()
	ret, specificReturn := fake.tagResourceWithContextReturnsOnCall[len(fake.tagResourceWithContextArgsForCall)]
	fake.tagResourceWithContextArgsForCall = append(fake.tagResourceWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.TagResourceInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("TagResourceWithContext", []interface{}{arg1, arg2, arg3})
	fake.tagResourceWithContextMutex.Unlock()
	if fake.TagResourceWithContextStub != nil {
		return fake.TagResourceWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tagResourceWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TagResourceWithContextCallCount() int {
	fake.tagResourceWithContextMutex.RLock()
	defer fake.tagResourceWithContextMutex.RUnlock()
	return len(fake.tagResourceWithContextArgsForCall)
}

func (fake *FakeDynamoDB) TagResourceWithContextCalls(stub func(context.Context, *dynamodba.TagResourceInput, ...request.Option) (*dynamodba.TagResourceOutput, error)) {
	fake.tagResourceWithContextMutex.Lock()
	defer fake.tagResourceWithContextMutex.Unlock()
	fake.TagResourceWithContextStub = stub
}

func (fake *FakeDynamoDB) TagResourceWithContextArgsForCall(i int) (context.Context, *dynamodba.TagResourceInput, []request.Option) {
	fake.tagResourceWithContextMutex.RLock()
	defer fake.tagResourceWithContextMutex.RUnlock()
	argsForCall := fake.tagResourceWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) TagResourceWithContextReturns(result1 *dynamodba.TagResourceOutput, result2 error) {
	fake.tagResourceWithContextMutex.Lock()
	defer fake.tagResourceWithContextMutex.Unlock()
	fake.TagResourceWithContextStub = nil
	fake.tagResourceWithContextReturns = struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TagResourceWithContextReturnsOnCall(i int, result1 *dynamodba.TagResourceOutput, result2 error) {
	fake.tagResourceWithContextMutex.Lock()
	defer fake.tagResourceWithContextMutex.Unlock()
	fake.TagResourceWithContextStub = nil
	if fake.tagResourceWithContextReturnsOnCall == nil {
		fake.tagResourceWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.TagResourceOutput
			result2 error
		})
	}
	fake.tagResourceWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.TagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactGetItems(arg1 *dynamodba.TransactGetItemsInput) (*dynamodba.TransactGetItemsOutput, error) {
	fake.transactGetItemsMutex.Lock()
	ret, specificReturn := fake.transactGetItemsReturnsOnCall[len(fake.transactGetItemsArgsForCall)]
	fake.transactGetItemsArgsForCall = append(fake.transactGetItemsArgsForCall, struct {
		arg1 *dynamodba.TransactGetItemsInput
	}{arg1})
	fake.recordInvocation("TransactGetItems", []interface{}{arg1})
	fake.transactGetItemsMutex.Unlock()
	if fake.TransactGetItemsStub != nil {
		return fake.TransactGetItemsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactGetItemsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TransactGetItemsCallCount() int {
	fake.transactGetItemsMutex.RLock()
	defer fake.transactGetItemsMutex.RUnlock()
	return len(fake.transactGetItemsArgsForCall)
}

func (fake *FakeDynamoDB) TransactGetItemsCalls(stub func(*dynamodba.TransactGetItemsInput) (*dynamodba.TransactGetItemsOutput, error)) {
	fake.transactGetItemsMutex.Lock()
	defer fake.transactGetItemsMutex.Unlock()
	fake.TransactGetItemsStub = stub
}

func (fake *FakeDynamoDB) TransactGetItemsArgsForCall(i int) *dynamodba.TransactGetItemsInput {
	fake.transactGetItemsMutex.RLock()
	defer fake.transactGetItemsMutex.RUnlock()
	argsForCall := fake.transactGetItemsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) TransactGetItemsReturns(result1 *dynamodba.TransactGetItemsOutput, result2 error) {
	fake.transactGetItemsMutex.Lock()
	defer fake.transactGetItemsMutex.Unlock()
	fake.TransactGetItemsStub = nil
	fake.transactGetItemsReturns = struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactGetItemsReturnsOnCall(i int, result1 *dynamodba.TransactGetItemsOutput, result2 error) {
	fake.transactGetItemsMutex.Lock()
	defer fake.transactGetItemsMutex.Unlock()
	fake.TransactGetItemsStub = nil
	if fake.transactGetItemsReturnsOnCall == nil {
		fake.transactGetItemsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.TransactGetItemsOutput
			result2 error
		})
	}
	fake.transactGetItemsReturnsOnCall[i] = struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactGetItemsRequest(arg1 *dynamodba.TransactGetItemsInput) (*request.Request, *dynamodba.TransactGetItemsOutput) {
	fake.transactGetItemsRequestMutex.Lock()
	ret, specificReturn := fake.transactGetItemsRequestReturnsOnCall[len(fake.transactGetItemsRequestArgsForCall)]
	fake.transactGetItemsRequestArgsForCall = append(fake.transactGetItemsRequestArgsForCall, struct {
		arg1 *dynamodba.TransactGetItemsInput
	}{arg1})
	fake.recordInvocation("TransactGetItemsRequest", []interface{}{arg1})
	fake.transactGetItemsRequestMutex.Unlock()
	if fake.TransactGetItemsRequestStub != nil {
		return fake.TransactGetItemsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactGetItemsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TransactGetItemsRequestCallCount() int {
	fake.transactGetItemsRequestMutex.RLock()
	defer fake.transactGetItemsRequestMutex.RUnlock()
	return len(fake.transactGetItemsRequestArgsForCall)
}

func (fake *FakeDynamoDB) TransactGetItemsRequestCalls(stub func(*dynamodba.TransactGetItemsInput) (*request.Request, *dynamodba.TransactGetItemsOutput)) {
	fake.transactGetItemsRequestMutex.Lock()
	defer fake.transactGetItemsRequestMutex.Unlock()
	fake.TransactGetItemsRequestStub = stub
}

func (fake *FakeDynamoDB) TransactGetItemsRequestArgsForCall(i int) *dynamodba.TransactGetItemsInput {
	fake.transactGetItemsRequestMutex.RLock()
	defer fake.transactGetItemsRequestMutex.RUnlock()
	argsForCall := fake.transactGetItemsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) TransactGetItemsRequestReturns(result1 *request.Request, result2 *dynamodba.TransactGetItemsOutput) {
	fake.transactGetItemsRequestMutex.Lock()
	defer fake.transactGetItemsRequestMutex.Unlock()
	fake.TransactGetItemsRequestStub = nil
	fake.transactGetItemsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.TransactGetItemsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactGetItemsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.TransactGetItemsOutput) {
	fake.transactGetItemsRequestMutex.Lock()
	defer fake.transactGetItemsRequestMutex.Unlock()
	fake.TransactGetItemsRequestStub = nil
	if fake.transactGetItemsRequestReturnsOnCall == nil {
		fake.transactGetItemsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.TransactGetItemsOutput
		})
	}
	fake.transactGetItemsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.TransactGetItemsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactGetItemsWithContext(arg1 context.Context, arg2 *dynamodba.TransactGetItemsInput, arg3 ...request.Option) (*dynamodba.TransactGetItemsOutput, error) {
	fake.transactGetItemsWithContextMutex.Lock()
	ret, specificReturn := fake.transactGetItemsWithContextReturnsOnCall[len(fake.transactGetItemsWithContextArgsForCall)]
	fake.transactGetItemsWithContextArgsForCall = append(fake.transactGetItemsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.TransactGetItemsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("TransactGetItemsWithContext", []interface{}{arg1, arg2, arg3})
	fake.transactGetItemsWithContextMutex.Unlock()
	if fake.TransactGetItemsWithContextStub != nil {
		return fake.TransactGetItemsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactGetItemsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TransactGetItemsWithContextCallCount() int {
	fake.transactGetItemsWithContextMutex.RLock()
	defer fake.transactGetItemsWithContextMutex.RUnlock()
	return len(fake.transactGetItemsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) TransactGetItemsWithContextCalls(stub func(context.Context, *dynamodba.TransactGetItemsInput, ...request.Option) (*dynamodba.TransactGetItemsOutput, error)) {
	fake.transactGetItemsWithContextMutex.Lock()
	defer fake.transactGetItemsWithContextMutex.Unlock()
	fake.TransactGetItemsWithContextStub = stub
}

func (fake *FakeDynamoDB) TransactGetItemsWithContextArgsForCall(i int) (context.Context, *dynamodba.TransactGetItemsInput, []request.Option) {
	fake.transactGetItemsWithContextMutex.RLock()
	defer fake.transactGetItemsWithContextMutex.RUnlock()
	argsForCall := fake.transactGetItemsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) TransactGetItemsWithContextReturns(result1 *dynamodba.TransactGetItemsOutput, result2 error) {
	fake.transactGetItemsWithContextMutex.Lock()
	defer fake.transactGetItemsWithContextMutex.Unlock()
	fake.TransactGetItemsWithContextStub = nil
	fake.transactGetItemsWithContextReturns = struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactGetItemsWithContextReturnsOnCall(i int, result1 *dynamodba.TransactGetItemsOutput, result2 error) {
	fake.transactGetItemsWithContextMutex.Lock()
	defer fake.transactGetItemsWithContextMutex.Unlock()
	fake.TransactGetItemsWithContextStub = nil
	if fake.transactGetItemsWithContextReturnsOnCall == nil {
		fake.transactGetItemsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.TransactGetItemsOutput
			result2 error
		})
	}
	fake.transactGetItemsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.TransactGetItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactWriteItems(arg1 *dynamodba.TransactWriteItemsInput) (*dynamodba.TransactWriteItemsOutput, error) {
	fake.transactWriteItemsMutex.Lock()
	ret, specificReturn := fake.transactWriteItemsReturnsOnCall[len(fake.transactWriteItemsArgsForCall)]
	fake.transactWriteItemsArgsForCall = append(fake.transactWriteItemsArgsForCall, struct {
		arg1 *dynamodba.TransactWriteItemsInput
	}{arg1})
	fake.recordInvocation("TransactWriteItems", []interface{}{arg1})
	fake.transactWriteItemsMutex.Unlock()
	if fake.TransactWriteItemsStub != nil {
		return fake.TransactWriteItemsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactWriteItemsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TransactWriteItemsCallCount() int {
	fake.transactWriteItemsMutex.RLock()
	defer fake.transactWriteItemsMutex.RUnlock()
	return len(fake.transactWriteItemsArgsForCall)
}

func (fake *FakeDynamoDB) TransactWriteItemsCalls(stub func(*dynamodba.TransactWriteItemsInput) (*dynamodba.TransactWriteItemsOutput, error)) {
	fake.transactWriteItemsMutex.Lock()
	defer fake.transactWriteItemsMutex.Unlock()
	fake.TransactWriteItemsStub = stub
}

func (fake *FakeDynamoDB) TransactWriteItemsArgsForCall(i int) *dynamodba.TransactWriteItemsInput {
	fake.transactWriteItemsMutex.RLock()
	defer fake.transactWriteItemsMutex.RUnlock()
	argsForCall := fake.transactWriteItemsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) TransactWriteItemsReturns(result1 *dynamodba.TransactWriteItemsOutput, result2 error) {
	fake.transactWriteItemsMutex.Lock()
	defer fake.transactWriteItemsMutex.Unlock()
	fake.TransactWriteItemsStub = nil
	fake.transactWriteItemsReturns = struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactWriteItemsReturnsOnCall(i int, result1 *dynamodba.TransactWriteItemsOutput, result2 error) {
	fake.transactWriteItemsMutex.Lock()
	defer fake.transactWriteItemsMutex.Unlock()
	fake.TransactWriteItemsStub = nil
	if fake.transactWriteItemsReturnsOnCall == nil {
		fake.transactWriteItemsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.TransactWriteItemsOutput
			result2 error
		})
	}
	fake.transactWriteItemsReturnsOnCall[i] = struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactWriteItemsRequest(arg1 *dynamodba.TransactWriteItemsInput) (*request.Request, *dynamodba.TransactWriteItemsOutput) {
	fake.transactWriteItemsRequestMutex.Lock()
	ret, specificReturn := fake.transactWriteItemsRequestReturnsOnCall[len(fake.transactWriteItemsRequestArgsForCall)]
	fake.transactWriteItemsRequestArgsForCall = append(fake.transactWriteItemsRequestArgsForCall, struct {
		arg1 *dynamodba.TransactWriteItemsInput
	}{arg1})
	fake.recordInvocation("TransactWriteItemsRequest", []interface{}{arg1})
	fake.transactWriteItemsRequestMutex.Unlock()
	if fake.TransactWriteItemsRequestStub != nil {
		return fake.TransactWriteItemsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactWriteItemsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TransactWriteItemsRequestCallCount() int {
	fake.transactWriteItemsRequestMutex.RLock()
	defer fake.transactWriteItemsRequestMutex.RUnlock()
	return len(fake.transactWriteItemsRequestArgsForCall)
}

func (fake *FakeDynamoDB) TransactWriteItemsRequestCalls(stub func(*dynamodba.TransactWriteItemsInput) (*request.Request, *dynamodba.TransactWriteItemsOutput)) {
	fake.transactWriteItemsRequestMutex.Lock()
	defer fake.transactWriteItemsRequestMutex.Unlock()
	fake.TransactWriteItemsRequestStub = stub
}

func (fake *FakeDynamoDB) TransactWriteItemsRequestArgsForCall(i int) *dynamodba.TransactWriteItemsInput {
	fake.transactWriteItemsRequestMutex.RLock()
	defer fake.transactWriteItemsRequestMutex.RUnlock()
	argsForCall := fake.transactWriteItemsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) TransactWriteItemsRequestReturns(result1 *request.Request, result2 *dynamodba.TransactWriteItemsOutput) {
	fake.transactWriteItemsRequestMutex.Lock()
	defer fake.transactWriteItemsRequestMutex.Unlock()
	fake.TransactWriteItemsRequestStub = nil
	fake.transactWriteItemsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.TransactWriteItemsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactWriteItemsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.TransactWriteItemsOutput) {
	fake.transactWriteItemsRequestMutex.Lock()
	defer fake.transactWriteItemsRequestMutex.Unlock()
	fake.TransactWriteItemsRequestStub = nil
	if fake.transactWriteItemsRequestReturnsOnCall == nil {
		fake.transactWriteItemsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.TransactWriteItemsOutput
		})
	}
	fake.transactWriteItemsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.TransactWriteItemsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactWriteItemsWithContext(arg1 context.Context, arg2 *dynamodba.TransactWriteItemsInput, arg3 ...request.Option) (*dynamodba.TransactWriteItemsOutput, error) {
	fake.transactWriteItemsWithContextMutex.Lock()
	ret, specificReturn := fake.transactWriteItemsWithContextReturnsOnCall[len(fake.transactWriteItemsWithContextArgsForCall)]
	fake.transactWriteItemsWithContextArgsForCall = append(fake.transactWriteItemsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.TransactWriteItemsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("TransactWriteItemsWithContext", []interface{}{arg1, arg2, arg3})
	fake.transactWriteItemsWithContextMutex.Unlock()
	if fake.TransactWriteItemsWithContextStub != nil {
		return fake.TransactWriteItemsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactWriteItemsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) TransactWriteItemsWithContextCallCount() int {
	fake.transactWriteItemsWithContextMutex.RLock()
	defer fake.transactWriteItemsWithContextMutex.RUnlock()
	return len(fake.transactWriteItemsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) TransactWriteItemsWithContextCalls(stub func(context.Context, *dynamodba.TransactWriteItemsInput, ...request.Option) (*dynamodba.TransactWriteItemsOutput, error)) {
	fake.transactWriteItemsWithContextMutex.Lock()
	defer fake.transactWriteItemsWithContextMutex.Unlock()
	fake.TransactWriteItemsWithContextStub = stub
}

func (fake *FakeDynamoDB) TransactWriteItemsWithContextArgsForCall(i int) (context.Context, *dynamodba.TransactWriteItemsInput, []request.Option) {
	fake.transactWriteItemsWithContextMutex.RLock()
	defer fake.transactWriteItemsWithContextMutex.RUnlock()
	argsForCall := fake.transactWriteItemsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) TransactWriteItemsWithContextReturns(result1 *dynamodba.TransactWriteItemsOutput, result2 error) {
	fake.transactWriteItemsWithContextMutex.Lock()
	defer fake.transactWriteItemsWithContextMutex.Unlock()
	fake.TransactWriteItemsWithContextStub = nil
	fake.transactWriteItemsWithContextReturns = struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) TransactWriteItemsWithContextReturnsOnCall(i int, result1 *dynamodba.TransactWriteItemsOutput, result2 error) {
	fake.transactWriteItemsWithContextMutex.Lock()
	defer fake.transactWriteItemsWithContextMutex.Unlock()
	fake.TransactWriteItemsWithContextStub = nil
	if fake.transactWriteItemsWithContextReturnsOnCall == nil {
		fake.transactWriteItemsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.TransactWriteItemsOutput
			result2 error
		})
	}
	fake.transactWriteItemsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.TransactWriteItemsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UntagResource(arg1 *dynamodba.UntagResourceInput) (*dynamodba.UntagResourceOutput, error) {
	fake.untagResourceMutex.Lock()
	ret, specificReturn := fake.untagResourceReturnsOnCall[len(fake.untagResourceArgsForCall)]
	fake.untagResourceArgsForCall = append(fake.untagResourceArgsForCall, struct {
		arg1 *dynamodba.UntagResourceInput
	}{arg1})
	fake.recordInvocation("UntagResource", []interface{}{arg1})
	fake.untagResourceMutex.Unlock()
	if fake.UntagResourceStub != nil {
		return fake.UntagResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.untagResourceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UntagResourceCallCount() int {
	fake.untagResourceMutex.RLock()
	defer fake.untagResourceMutex.RUnlock()
	return len(fake.untagResourceArgsForCall)
}

func (fake *FakeDynamoDB) UntagResourceCalls(stub func(*dynamodba.UntagResourceInput) (*dynamodba.UntagResourceOutput, error)) {
	fake.untagResourceMutex.Lock()
	defer fake.untagResourceMutex.Unlock()
	fake.UntagResourceStub = stub
}

func (fake *FakeDynamoDB) UntagResourceArgsForCall(i int) *dynamodba.UntagResourceInput {
	fake.untagResourceMutex.RLock()
	defer fake.untagResourceMutex.RUnlock()
	argsForCall := fake.untagResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UntagResourceReturns(result1 *dynamodba.UntagResourceOutput, result2 error) {
	fake.untagResourceMutex.Lock()
	defer fake.untagResourceMutex.Unlock()
	fake.UntagResourceStub = nil
	fake.untagResourceReturns = struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UntagResourceReturnsOnCall(i int, result1 *dynamodba.UntagResourceOutput, result2 error) {
	fake.untagResourceMutex.Lock()
	defer fake.untagResourceMutex.Unlock()
	fake.UntagResourceStub = nil
	if fake.untagResourceReturnsOnCall == nil {
		fake.untagResourceReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UntagResourceOutput
			result2 error
		})
	}
	fake.untagResourceReturnsOnCall[i] = struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UntagResourceRequest(arg1 *dynamodba.UntagResourceInput) (*request.Request, *dynamodba.UntagResourceOutput) {
	fake.untagResourceRequestMutex.Lock()
	ret, specificReturn := fake.untagResourceRequestReturnsOnCall[len(fake.untagResourceRequestArgsForCall)]
	fake.untagResourceRequestArgsForCall = append(fake.untagResourceRequestArgsForCall, struct {
		arg1 *dynamodba.UntagResourceInput
	}{arg1})
	fake.recordInvocation("UntagResourceRequest", []interface{}{arg1})
	fake.untagResourceRequestMutex.Unlock()
	if fake.UntagResourceRequestStub != nil {
		return fake.UntagResourceRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.untagResourceRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UntagResourceRequestCallCount() int {
	fake.untagResourceRequestMutex.RLock()
	defer fake.untagResourceRequestMutex.RUnlock()
	return len(fake.untagResourceRequestArgsForCall)
}

func (fake *FakeDynamoDB) UntagResourceRequestCalls(stub func(*dynamodba.UntagResourceInput) (*request.Request, *dynamodba.UntagResourceOutput)) {
	fake.untagResourceRequestMutex.Lock()
	defer fake.untagResourceRequestMutex.Unlock()
	fake.UntagResourceRequestStub = stub
}

func (fake *FakeDynamoDB) UntagResourceRequestArgsForCall(i int) *dynamodba.UntagResourceInput {
	fake.untagResourceRequestMutex.RLock()
	defer fake.untagResourceRequestMutex.RUnlock()
	argsForCall := fake.untagResourceRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UntagResourceRequestReturns(result1 *request.Request, result2 *dynamodba.UntagResourceOutput) {
	fake.untagResourceRequestMutex.Lock()
	defer fake.untagResourceRequestMutex.Unlock()
	fake.UntagResourceRequestStub = nil
	fake.untagResourceRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UntagResourceOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UntagResourceRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UntagResourceOutput) {
	fake.untagResourceRequestMutex.Lock()
	defer fake.untagResourceRequestMutex.Unlock()
	fake.UntagResourceRequestStub = nil
	if fake.untagResourceRequestReturnsOnCall == nil {
		fake.untagResourceRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UntagResourceOutput
		})
	}
	fake.untagResourceRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UntagResourceOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UntagResourceWithContext(arg1 context.Context, arg2 *dynamodba.UntagResourceInput, arg3 ...request.Option) (*dynamodba.UntagResourceOutput, error) {
	fake.untagResourceWithContextMutex.Lock()
	ret, specificReturn := fake.untagResourceWithContextReturnsOnCall[len(fake.untagResourceWithContextArgsForCall)]
	fake.untagResourceWithContextArgsForCall = append(fake.untagResourceWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UntagResourceInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UntagResourceWithContext", []interface{}{arg1, arg2, arg3})
	fake.untagResourceWithContextMutex.Unlock()
	if fake.UntagResourceWithContextStub != nil {
		return fake.UntagResourceWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.untagResourceWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UntagResourceWithContextCallCount() int {
	fake.untagResourceWithContextMutex.RLock()
	defer fake.untagResourceWithContextMutex.RUnlock()
	return len(fake.untagResourceWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UntagResourceWithContextCalls(stub func(context.Context, *dynamodba.UntagResourceInput, ...request.Option) (*dynamodba.UntagResourceOutput, error)) {
	fake.untagResourceWithContextMutex.Lock()
	defer fake.untagResourceWithContextMutex.Unlock()
	fake.UntagResourceWithContextStub = stub
}

func (fake *FakeDynamoDB) UntagResourceWithContextArgsForCall(i int) (context.Context, *dynamodba.UntagResourceInput, []request.Option) {
	fake.untagResourceWithContextMutex.RLock()
	defer fake.untagResourceWithContextMutex.RUnlock()
	argsForCall := fake.untagResourceWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UntagResourceWithContextReturns(result1 *dynamodba.UntagResourceOutput, result2 error) {
	fake.untagResourceWithContextMutex.Lock()
	defer fake.untagResourceWithContextMutex.Unlock()
	fake.UntagResourceWithContextStub = nil
	fake.untagResourceWithContextReturns = struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UntagResourceWithContextReturnsOnCall(i int, result1 *dynamodba.UntagResourceOutput, result2 error) {
	fake.untagResourceWithContextMutex.Lock()
	defer fake.untagResourceWithContextMutex.Unlock()
	fake.UntagResourceWithContextStub = nil
	if fake.untagResourceWithContextReturnsOnCall == nil {
		fake.untagResourceWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UntagResourceOutput
			result2 error
		})
	}
	fake.untagResourceWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UntagResourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContinuousBackups(arg1 *dynamodba.UpdateContinuousBackupsInput) (*dynamodba.UpdateContinuousBackupsOutput, error) {
	fake.updateContinuousBackupsMutex.Lock()
	ret, specificReturn := fake.updateContinuousBackupsReturnsOnCall[len(fake.updateContinuousBackupsArgsForCall)]
	fake.updateContinuousBackupsArgsForCall = append(fake.updateContinuousBackupsArgsForCall, struct {
		arg1 *dynamodba.UpdateContinuousBackupsInput
	}{arg1})
	fake.recordInvocation("UpdateContinuousBackups", []interface{}{arg1})
	fake.updateContinuousBackupsMutex.Unlock()
	if fake.UpdateContinuousBackupsStub != nil {
		return fake.UpdateContinuousBackupsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContinuousBackupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsCallCount() int {
	fake.updateContinuousBackupsMutex.RLock()
	defer fake.updateContinuousBackupsMutex.RUnlock()
	return len(fake.updateContinuousBackupsArgsForCall)
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsCalls(stub func(*dynamodba.UpdateContinuousBackupsInput) (*dynamodba.UpdateContinuousBackupsOutput, error)) {
	fake.updateContinuousBackupsMutex.Lock()
	defer fake.updateContinuousBackupsMutex.Unlock()
	fake.UpdateContinuousBackupsStub = stub
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsArgsForCall(i int) *dynamodba.UpdateContinuousBackupsInput {
	fake.updateContinuousBackupsMutex.RLock()
	defer fake.updateContinuousBackupsMutex.RUnlock()
	argsForCall := fake.updateContinuousBackupsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsReturns(result1 *dynamodba.UpdateContinuousBackupsOutput, result2 error) {
	fake.updateContinuousBackupsMutex.Lock()
	defer fake.updateContinuousBackupsMutex.Unlock()
	fake.UpdateContinuousBackupsStub = nil
	fake.updateContinuousBackupsReturns = struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsReturnsOnCall(i int, result1 *dynamodba.UpdateContinuousBackupsOutput, result2 error) {
	fake.updateContinuousBackupsMutex.Lock()
	defer fake.updateContinuousBackupsMutex.Unlock()
	fake.UpdateContinuousBackupsStub = nil
	if fake.updateContinuousBackupsReturnsOnCall == nil {
		fake.updateContinuousBackupsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateContinuousBackupsOutput
			result2 error
		})
	}
	fake.updateContinuousBackupsReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsRequest(arg1 *dynamodba.UpdateContinuousBackupsInput) (*request.Request, *dynamodba.UpdateContinuousBackupsOutput) {
	fake.updateContinuousBackupsRequestMutex.Lock()
	ret, specificReturn := fake.updateContinuousBackupsRequestReturnsOnCall[len(fake.updateContinuousBackupsRequestArgsForCall)]
	fake.updateContinuousBackupsRequestArgsForCall = append(fake.updateContinuousBackupsRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateContinuousBackupsInput
	}{arg1})
	fake.recordInvocation("UpdateContinuousBackupsRequest", []interface{}{arg1})
	fake.updateContinuousBackupsRequestMutex.Unlock()
	if fake.UpdateContinuousBackupsRequestStub != nil {
		return fake.UpdateContinuousBackupsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContinuousBackupsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsRequestCallCount() int {
	fake.updateContinuousBackupsRequestMutex.RLock()
	defer fake.updateContinuousBackupsRequestMutex.RUnlock()
	return len(fake.updateContinuousBackupsRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsRequestCalls(stub func(*dynamodba.UpdateContinuousBackupsInput) (*request.Request, *dynamodba.UpdateContinuousBackupsOutput)) {
	fake.updateContinuousBackupsRequestMutex.Lock()
	defer fake.updateContinuousBackupsRequestMutex.Unlock()
	fake.UpdateContinuousBackupsRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsRequestArgsForCall(i int) *dynamodba.UpdateContinuousBackupsInput {
	fake.updateContinuousBackupsRequestMutex.RLock()
	defer fake.updateContinuousBackupsRequestMutex.RUnlock()
	argsForCall := fake.updateContinuousBackupsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateContinuousBackupsOutput) {
	fake.updateContinuousBackupsRequestMutex.Lock()
	defer fake.updateContinuousBackupsRequestMutex.Unlock()
	fake.UpdateContinuousBackupsRequestStub = nil
	fake.updateContinuousBackupsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContinuousBackupsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateContinuousBackupsOutput) {
	fake.updateContinuousBackupsRequestMutex.Lock()
	defer fake.updateContinuousBackupsRequestMutex.Unlock()
	fake.UpdateContinuousBackupsRequestStub = nil
	if fake.updateContinuousBackupsRequestReturnsOnCall == nil {
		fake.updateContinuousBackupsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateContinuousBackupsOutput
		})
	}
	fake.updateContinuousBackupsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContinuousBackupsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsWithContext(arg1 context.Context, arg2 *dynamodba.UpdateContinuousBackupsInput, arg3 ...request.Option) (*dynamodba.UpdateContinuousBackupsOutput, error) {
	fake.updateContinuousBackupsWithContextMutex.Lock()
	ret, specificReturn := fake.updateContinuousBackupsWithContextReturnsOnCall[len(fake.updateContinuousBackupsWithContextArgsForCall)]
	fake.updateContinuousBackupsWithContextArgsForCall = append(fake.updateContinuousBackupsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateContinuousBackupsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateContinuousBackupsWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateContinuousBackupsWithContextMutex.Unlock()
	if fake.UpdateContinuousBackupsWithContextStub != nil {
		return fake.UpdateContinuousBackupsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContinuousBackupsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsWithContextCallCount() int {
	fake.updateContinuousBackupsWithContextMutex.RLock()
	defer fake.updateContinuousBackupsWithContextMutex.RUnlock()
	return len(fake.updateContinuousBackupsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsWithContextCalls(stub func(context.Context, *dynamodba.UpdateContinuousBackupsInput, ...request.Option) (*dynamodba.UpdateContinuousBackupsOutput, error)) {
	fake.updateContinuousBackupsWithContextMutex.Lock()
	defer fake.updateContinuousBackupsWithContextMutex.Unlock()
	fake.UpdateContinuousBackupsWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateContinuousBackupsInput, []request.Option) {
	fake.updateContinuousBackupsWithContextMutex.RLock()
	defer fake.updateContinuousBackupsWithContextMutex.RUnlock()
	argsForCall := fake.updateContinuousBackupsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsWithContextReturns(result1 *dynamodba.UpdateContinuousBackupsOutput, result2 error) {
	fake.updateContinuousBackupsWithContextMutex.Lock()
	defer fake.updateContinuousBackupsWithContextMutex.Unlock()
	fake.UpdateContinuousBackupsWithContextStub = nil
	fake.updateContinuousBackupsWithContextReturns = struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContinuousBackupsWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateContinuousBackupsOutput, result2 error) {
	fake.updateContinuousBackupsWithContextMutex.Lock()
	defer fake.updateContinuousBackupsWithContextMutex.Unlock()
	fake.UpdateContinuousBackupsWithContextStub = nil
	if fake.updateContinuousBackupsWithContextReturnsOnCall == nil {
		fake.updateContinuousBackupsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateContinuousBackupsOutput
			result2 error
		})
	}
	fake.updateContinuousBackupsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateContinuousBackupsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContributorInsights(arg1 *dynamodba.UpdateContributorInsightsInput) (*dynamodba.UpdateContributorInsightsOutput, error) {
	fake.updateContributorInsightsMutex.Lock()
	ret, specificReturn := fake.updateContributorInsightsReturnsOnCall[len(fake.updateContributorInsightsArgsForCall)]
	fake.updateContributorInsightsArgsForCall = append(fake.updateContributorInsightsArgsForCall, struct {
		arg1 *dynamodba.UpdateContributorInsightsInput
	}{arg1})
	fake.recordInvocation("UpdateContributorInsights", []interface{}{arg1})
	fake.updateContributorInsightsMutex.Unlock()
	if fake.UpdateContributorInsightsStub != nil {
		return fake.UpdateContributorInsightsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContributorInsightsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateContributorInsightsCallCount() int {
	fake.updateContributorInsightsMutex.RLock()
	defer fake.updateContributorInsightsMutex.RUnlock()
	return len(fake.updateContributorInsightsArgsForCall)
}

func (fake *FakeDynamoDB) UpdateContributorInsightsCalls(stub func(*dynamodba.UpdateContributorInsightsInput) (*dynamodba.UpdateContributorInsightsOutput, error)) {
	fake.updateContributorInsightsMutex.Lock()
	defer fake.updateContributorInsightsMutex.Unlock()
	fake.UpdateContributorInsightsStub = stub
}

func (fake *FakeDynamoDB) UpdateContributorInsightsArgsForCall(i int) *dynamodba.UpdateContributorInsightsInput {
	fake.updateContributorInsightsMutex.RLock()
	defer fake.updateContributorInsightsMutex.RUnlock()
	argsForCall := fake.updateContributorInsightsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateContributorInsightsReturns(result1 *dynamodba.UpdateContributorInsightsOutput, result2 error) {
	fake.updateContributorInsightsMutex.Lock()
	defer fake.updateContributorInsightsMutex.Unlock()
	fake.UpdateContributorInsightsStub = nil
	fake.updateContributorInsightsReturns = struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContributorInsightsReturnsOnCall(i int, result1 *dynamodba.UpdateContributorInsightsOutput, result2 error) {
	fake.updateContributorInsightsMutex.Lock()
	defer fake.updateContributorInsightsMutex.Unlock()
	fake.UpdateContributorInsightsStub = nil
	if fake.updateContributorInsightsReturnsOnCall == nil {
		fake.updateContributorInsightsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateContributorInsightsOutput
			result2 error
		})
	}
	fake.updateContributorInsightsReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContributorInsightsRequest(arg1 *dynamodba.UpdateContributorInsightsInput) (*request.Request, *dynamodba.UpdateContributorInsightsOutput) {
	fake.updateContributorInsightsRequestMutex.Lock()
	ret, specificReturn := fake.updateContributorInsightsRequestReturnsOnCall[len(fake.updateContributorInsightsRequestArgsForCall)]
	fake.updateContributorInsightsRequestArgsForCall = append(fake.updateContributorInsightsRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateContributorInsightsInput
	}{arg1})
	fake.recordInvocation("UpdateContributorInsightsRequest", []interface{}{arg1})
	fake.updateContributorInsightsRequestMutex.Unlock()
	if fake.UpdateContributorInsightsRequestStub != nil {
		return fake.UpdateContributorInsightsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContributorInsightsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateContributorInsightsRequestCallCount() int {
	fake.updateContributorInsightsRequestMutex.RLock()
	defer fake.updateContributorInsightsRequestMutex.RUnlock()
	return len(fake.updateContributorInsightsRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateContributorInsightsRequestCalls(stub func(*dynamodba.UpdateContributorInsightsInput) (*request.Request, *dynamodba.UpdateContributorInsightsOutput)) {
	fake.updateContributorInsightsRequestMutex.Lock()
	defer fake.updateContributorInsightsRequestMutex.Unlock()
	fake.UpdateContributorInsightsRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateContributorInsightsRequestArgsForCall(i int) *dynamodba.UpdateContributorInsightsInput {
	fake.updateContributorInsightsRequestMutex.RLock()
	defer fake.updateContributorInsightsRequestMutex.RUnlock()
	argsForCall := fake.updateContributorInsightsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateContributorInsightsRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateContributorInsightsOutput) {
	fake.updateContributorInsightsRequestMutex.Lock()
	defer fake.updateContributorInsightsRequestMutex.Unlock()
	fake.UpdateContributorInsightsRequestStub = nil
	fake.updateContributorInsightsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContributorInsightsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContributorInsightsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateContributorInsightsOutput) {
	fake.updateContributorInsightsRequestMutex.Lock()
	defer fake.updateContributorInsightsRequestMutex.Unlock()
	fake.UpdateContributorInsightsRequestStub = nil
	if fake.updateContributorInsightsRequestReturnsOnCall == nil {
		fake.updateContributorInsightsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateContributorInsightsOutput
		})
	}
	fake.updateContributorInsightsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateContributorInsightsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContributorInsightsWithContext(arg1 context.Context, arg2 *dynamodba.UpdateContributorInsightsInput, arg3 ...request.Option) (*dynamodba.UpdateContributorInsightsOutput, error) {
	fake.updateContributorInsightsWithContextMutex.Lock()
	ret, specificReturn := fake.updateContributorInsightsWithContextReturnsOnCall[len(fake.updateContributorInsightsWithContextArgsForCall)]
	fake.updateContributorInsightsWithContextArgsForCall = append(fake.updateContributorInsightsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateContributorInsightsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateContributorInsightsWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateContributorInsightsWithContextMutex.Unlock()
	if fake.UpdateContributorInsightsWithContextStub != nil {
		return fake.UpdateContributorInsightsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateContributorInsightsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateContributorInsightsWithContextCallCount() int {
	fake.updateContributorInsightsWithContextMutex.RLock()
	defer fake.updateContributorInsightsWithContextMutex.RUnlock()
	return len(fake.updateContributorInsightsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateContributorInsightsWithContextCalls(stub func(context.Context, *dynamodba.UpdateContributorInsightsInput, ...request.Option) (*dynamodba.UpdateContributorInsightsOutput, error)) {
	fake.updateContributorInsightsWithContextMutex.Lock()
	defer fake.updateContributorInsightsWithContextMutex.Unlock()
	fake.UpdateContributorInsightsWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateContributorInsightsWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateContributorInsightsInput, []request.Option) {
	fake.updateContributorInsightsWithContextMutex.RLock()
	defer fake.updateContributorInsightsWithContextMutex.RUnlock()
	argsForCall := fake.updateContributorInsightsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateContributorInsightsWithContextReturns(result1 *dynamodba.UpdateContributorInsightsOutput, result2 error) {
	fake.updateContributorInsightsWithContextMutex.Lock()
	defer fake.updateContributorInsightsWithContextMutex.Unlock()
	fake.UpdateContributorInsightsWithContextStub = nil
	fake.updateContributorInsightsWithContextReturns = struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateContributorInsightsWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateContributorInsightsOutput, result2 error) {
	fake.updateContributorInsightsWithContextMutex.Lock()
	defer fake.updateContributorInsightsWithContextMutex.Unlock()
	fake.UpdateContributorInsightsWithContextStub = nil
	if fake.updateContributorInsightsWithContextReturnsOnCall == nil {
		fake.updateContributorInsightsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateContributorInsightsOutput
			result2 error
		})
	}
	fake.updateContributorInsightsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateContributorInsightsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTable(arg1 *dynamodba.UpdateGlobalTableInput) (*dynamodba.UpdateGlobalTableOutput, error) {
	fake.updateGlobalTableMutex.Lock()
	ret, specificReturn := fake.updateGlobalTableReturnsOnCall[len(fake.updateGlobalTableArgsForCall)]
	fake.updateGlobalTableArgsForCall = append(fake.updateGlobalTableArgsForCall, struct {
		arg1 *dynamodba.UpdateGlobalTableInput
	}{arg1})
	fake.recordInvocation("UpdateGlobalTable", []interface{}{arg1})
	fake.updateGlobalTableMutex.Unlock()
	if fake.UpdateGlobalTableStub != nil {
		return fake.UpdateGlobalTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateGlobalTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateGlobalTableCallCount() int {
	fake.updateGlobalTableMutex.RLock()
	defer fake.updateGlobalTableMutex.RUnlock()
	return len(fake.updateGlobalTableArgsForCall)
}

func (fake *FakeDynamoDB) UpdateGlobalTableCalls(stub func(*dynamodba.UpdateGlobalTableInput) (*dynamodba.UpdateGlobalTableOutput, error)) {
	fake.updateGlobalTableMutex.Lock()
	defer fake.updateGlobalTableMutex.Unlock()
	fake.UpdateGlobalTableStub = stub
}

func (fake *FakeDynamoDB) UpdateGlobalTableArgsForCall(i int) *dynamodba.UpdateGlobalTableInput {
	fake.updateGlobalTableMutex.RLock()
	defer fake.updateGlobalTableMutex.RUnlock()
	argsForCall := fake.updateGlobalTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateGlobalTableReturns(result1 *dynamodba.UpdateGlobalTableOutput, result2 error) {
	fake.updateGlobalTableMutex.Lock()
	defer fake.updateGlobalTableMutex.Unlock()
	fake.UpdateGlobalTableStub = nil
	fake.updateGlobalTableReturns = struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableReturnsOnCall(i int, result1 *dynamodba.UpdateGlobalTableOutput, result2 error) {
	fake.updateGlobalTableMutex.Lock()
	defer fake.updateGlobalTableMutex.Unlock()
	fake.UpdateGlobalTableStub = nil
	if fake.updateGlobalTableReturnsOnCall == nil {
		fake.updateGlobalTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateGlobalTableOutput
			result2 error
		})
	}
	fake.updateGlobalTableReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableRequest(arg1 *dynamodba.UpdateGlobalTableInput) (*request.Request, *dynamodba.UpdateGlobalTableOutput) {
	fake.updateGlobalTableRequestMutex.Lock()
	ret, specificReturn := fake.updateGlobalTableRequestReturnsOnCall[len(fake.updateGlobalTableRequestArgsForCall)]
	fake.updateGlobalTableRequestArgsForCall = append(fake.updateGlobalTableRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateGlobalTableInput
	}{arg1})
	fake.recordInvocation("UpdateGlobalTableRequest", []interface{}{arg1})
	fake.updateGlobalTableRequestMutex.Unlock()
	if fake.UpdateGlobalTableRequestStub != nil {
		return fake.UpdateGlobalTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateGlobalTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateGlobalTableRequestCallCount() int {
	fake.updateGlobalTableRequestMutex.RLock()
	defer fake.updateGlobalTableRequestMutex.RUnlock()
	return len(fake.updateGlobalTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateGlobalTableRequestCalls(stub func(*dynamodba.UpdateGlobalTableInput) (*request.Request, *dynamodba.UpdateGlobalTableOutput)) {
	fake.updateGlobalTableRequestMutex.Lock()
	defer fake.updateGlobalTableRequestMutex.Unlock()
	fake.UpdateGlobalTableRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateGlobalTableRequestArgsForCall(i int) *dynamodba.UpdateGlobalTableInput {
	fake.updateGlobalTableRequestMutex.RLock()
	defer fake.updateGlobalTableRequestMutex.RUnlock()
	argsForCall := fake.updateGlobalTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateGlobalTableRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateGlobalTableOutput) {
	fake.updateGlobalTableRequestMutex.Lock()
	defer fake.updateGlobalTableRequestMutex.Unlock()
	fake.UpdateGlobalTableRequestStub = nil
	fake.updateGlobalTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateGlobalTableOutput) {
	fake.updateGlobalTableRequestMutex.Lock()
	defer fake.updateGlobalTableRequestMutex.Unlock()
	fake.UpdateGlobalTableRequestStub = nil
	if fake.updateGlobalTableRequestReturnsOnCall == nil {
		fake.updateGlobalTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateGlobalTableOutput
		})
	}
	fake.updateGlobalTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettings(arg1 *dynamodba.UpdateGlobalTableSettingsInput) (*dynamodba.UpdateGlobalTableSettingsOutput, error) {
	fake.updateGlobalTableSettingsMutex.Lock()
	ret, specificReturn := fake.updateGlobalTableSettingsReturnsOnCall[len(fake.updateGlobalTableSettingsArgsForCall)]
	fake.updateGlobalTableSettingsArgsForCall = append(fake.updateGlobalTableSettingsArgsForCall, struct {
		arg1 *dynamodba.UpdateGlobalTableSettingsInput
	}{arg1})
	fake.recordInvocation("UpdateGlobalTableSettings", []interface{}{arg1})
	fake.updateGlobalTableSettingsMutex.Unlock()
	if fake.UpdateGlobalTableSettingsStub != nil {
		return fake.UpdateGlobalTableSettingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateGlobalTableSettingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsCallCount() int {
	fake.updateGlobalTableSettingsMutex.RLock()
	defer fake.updateGlobalTableSettingsMutex.RUnlock()
	return len(fake.updateGlobalTableSettingsArgsForCall)
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsCalls(stub func(*dynamodba.UpdateGlobalTableSettingsInput) (*dynamodba.UpdateGlobalTableSettingsOutput, error)) {
	fake.updateGlobalTableSettingsMutex.Lock()
	defer fake.updateGlobalTableSettingsMutex.Unlock()
	fake.UpdateGlobalTableSettingsStub = stub
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsArgsForCall(i int) *dynamodba.UpdateGlobalTableSettingsInput {
	fake.updateGlobalTableSettingsMutex.RLock()
	defer fake.updateGlobalTableSettingsMutex.RUnlock()
	argsForCall := fake.updateGlobalTableSettingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsReturns(result1 *dynamodba.UpdateGlobalTableSettingsOutput, result2 error) {
	fake.updateGlobalTableSettingsMutex.Lock()
	defer fake.updateGlobalTableSettingsMutex.Unlock()
	fake.UpdateGlobalTableSettingsStub = nil
	fake.updateGlobalTableSettingsReturns = struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsReturnsOnCall(i int, result1 *dynamodba.UpdateGlobalTableSettingsOutput, result2 error) {
	fake.updateGlobalTableSettingsMutex.Lock()
	defer fake.updateGlobalTableSettingsMutex.Unlock()
	fake.UpdateGlobalTableSettingsStub = nil
	if fake.updateGlobalTableSettingsReturnsOnCall == nil {
		fake.updateGlobalTableSettingsReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateGlobalTableSettingsOutput
			result2 error
		})
	}
	fake.updateGlobalTableSettingsReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsRequest(arg1 *dynamodba.UpdateGlobalTableSettingsInput) (*request.Request, *dynamodba.UpdateGlobalTableSettingsOutput) {
	fake.updateGlobalTableSettingsRequestMutex.Lock()
	ret, specificReturn := fake.updateGlobalTableSettingsRequestReturnsOnCall[len(fake.updateGlobalTableSettingsRequestArgsForCall)]
	fake.updateGlobalTableSettingsRequestArgsForCall = append(fake.updateGlobalTableSettingsRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateGlobalTableSettingsInput
	}{arg1})
	fake.recordInvocation("UpdateGlobalTableSettingsRequest", []interface{}{arg1})
	fake.updateGlobalTableSettingsRequestMutex.Unlock()
	if fake.UpdateGlobalTableSettingsRequestStub != nil {
		return fake.UpdateGlobalTableSettingsRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateGlobalTableSettingsRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsRequestCallCount() int {
	fake.updateGlobalTableSettingsRequestMutex.RLock()
	defer fake.updateGlobalTableSettingsRequestMutex.RUnlock()
	return len(fake.updateGlobalTableSettingsRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsRequestCalls(stub func(*dynamodba.UpdateGlobalTableSettingsInput) (*request.Request, *dynamodba.UpdateGlobalTableSettingsOutput)) {
	fake.updateGlobalTableSettingsRequestMutex.Lock()
	defer fake.updateGlobalTableSettingsRequestMutex.Unlock()
	fake.UpdateGlobalTableSettingsRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsRequestArgsForCall(i int) *dynamodba.UpdateGlobalTableSettingsInput {
	fake.updateGlobalTableSettingsRequestMutex.RLock()
	defer fake.updateGlobalTableSettingsRequestMutex.RUnlock()
	argsForCall := fake.updateGlobalTableSettingsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateGlobalTableSettingsOutput) {
	fake.updateGlobalTableSettingsRequestMutex.Lock()
	defer fake.updateGlobalTableSettingsRequestMutex.Unlock()
	fake.UpdateGlobalTableSettingsRequestStub = nil
	fake.updateGlobalTableSettingsRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableSettingsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateGlobalTableSettingsOutput) {
	fake.updateGlobalTableSettingsRequestMutex.Lock()
	defer fake.updateGlobalTableSettingsRequestMutex.Unlock()
	fake.UpdateGlobalTableSettingsRequestStub = nil
	if fake.updateGlobalTableSettingsRequestReturnsOnCall == nil {
		fake.updateGlobalTableSettingsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateGlobalTableSettingsOutput
		})
	}
	fake.updateGlobalTableSettingsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateGlobalTableSettingsOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsWithContext(arg1 context.Context, arg2 *dynamodba.UpdateGlobalTableSettingsInput, arg3 ...request.Option) (*dynamodba.UpdateGlobalTableSettingsOutput, error) {
	fake.updateGlobalTableSettingsWithContextMutex.Lock()
	ret, specificReturn := fake.updateGlobalTableSettingsWithContextReturnsOnCall[len(fake.updateGlobalTableSettingsWithContextArgsForCall)]
	fake.updateGlobalTableSettingsWithContextArgsForCall = append(fake.updateGlobalTableSettingsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateGlobalTableSettingsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateGlobalTableSettingsWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateGlobalTableSettingsWithContextMutex.Unlock()
	if fake.UpdateGlobalTableSettingsWithContextStub != nil {
		return fake.UpdateGlobalTableSettingsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateGlobalTableSettingsWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsWithContextCallCount() int {
	fake.updateGlobalTableSettingsWithContextMutex.RLock()
	defer fake.updateGlobalTableSettingsWithContextMutex.RUnlock()
	return len(fake.updateGlobalTableSettingsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsWithContextCalls(stub func(context.Context, *dynamodba.UpdateGlobalTableSettingsInput, ...request.Option) (*dynamodba.UpdateGlobalTableSettingsOutput, error)) {
	fake.updateGlobalTableSettingsWithContextMutex.Lock()
	defer fake.updateGlobalTableSettingsWithContextMutex.Unlock()
	fake.UpdateGlobalTableSettingsWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateGlobalTableSettingsInput, []request.Option) {
	fake.updateGlobalTableSettingsWithContextMutex.RLock()
	defer fake.updateGlobalTableSettingsWithContextMutex.RUnlock()
	argsForCall := fake.updateGlobalTableSettingsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsWithContextReturns(result1 *dynamodba.UpdateGlobalTableSettingsOutput, result2 error) {
	fake.updateGlobalTableSettingsWithContextMutex.Lock()
	defer fake.updateGlobalTableSettingsWithContextMutex.Unlock()
	fake.UpdateGlobalTableSettingsWithContextStub = nil
	fake.updateGlobalTableSettingsWithContextReturns = struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableSettingsWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateGlobalTableSettingsOutput, result2 error) {
	fake.updateGlobalTableSettingsWithContextMutex.Lock()
	defer fake.updateGlobalTableSettingsWithContextMutex.Unlock()
	fake.UpdateGlobalTableSettingsWithContextStub = nil
	if fake.updateGlobalTableSettingsWithContextReturnsOnCall == nil {
		fake.updateGlobalTableSettingsWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateGlobalTableSettingsOutput
			result2 error
		})
	}
	fake.updateGlobalTableSettingsWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateGlobalTableSettingsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableWithContext(arg1 context.Context, arg2 *dynamodba.UpdateGlobalTableInput, arg3 ...request.Option) (*dynamodba.UpdateGlobalTableOutput, error) {
	fake.updateGlobalTableWithContextMutex.Lock()
	ret, specificReturn := fake.updateGlobalTableWithContextReturnsOnCall[len(fake.updateGlobalTableWithContextArgsForCall)]
	fake.updateGlobalTableWithContextArgsForCall = append(fake.updateGlobalTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateGlobalTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateGlobalTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateGlobalTableWithContextMutex.Unlock()
	if fake.UpdateGlobalTableWithContextStub != nil {
		return fake.UpdateGlobalTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateGlobalTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateGlobalTableWithContextCallCount() int {
	fake.updateGlobalTableWithContextMutex.RLock()
	defer fake.updateGlobalTableWithContextMutex.RUnlock()
	return len(fake.updateGlobalTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateGlobalTableWithContextCalls(stub func(context.Context, *dynamodba.UpdateGlobalTableInput, ...request.Option) (*dynamodba.UpdateGlobalTableOutput, error)) {
	fake.updateGlobalTableWithContextMutex.Lock()
	defer fake.updateGlobalTableWithContextMutex.Unlock()
	fake.UpdateGlobalTableWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateGlobalTableWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateGlobalTableInput, []request.Option) {
	fake.updateGlobalTableWithContextMutex.RLock()
	defer fake.updateGlobalTableWithContextMutex.RUnlock()
	argsForCall := fake.updateGlobalTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateGlobalTableWithContextReturns(result1 *dynamodba.UpdateGlobalTableOutput, result2 error) {
	fake.updateGlobalTableWithContextMutex.Lock()
	defer fake.updateGlobalTableWithContextMutex.Unlock()
	fake.UpdateGlobalTableWithContextStub = nil
	fake.updateGlobalTableWithContextReturns = struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateGlobalTableWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateGlobalTableOutput, result2 error) {
	fake.updateGlobalTableWithContextMutex.Lock()
	defer fake.updateGlobalTableWithContextMutex.Unlock()
	fake.UpdateGlobalTableWithContextStub = nil
	if fake.updateGlobalTableWithContextReturnsOnCall == nil {
		fake.updateGlobalTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateGlobalTableOutput
			result2 error
		})
	}
	fake.updateGlobalTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateGlobalTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateItem(arg1 *dynamodba.UpdateItemInput) (*dynamodba.UpdateItemOutput, error) {
	fake.updateItemMutex.Lock()
	ret, specificReturn := fake.updateItemReturnsOnCall[len(fake.updateItemArgsForCall)]
	fake.updateItemArgsForCall = append(fake.updateItemArgsForCall, struct {
		arg1 *dynamodba.UpdateItemInput
	}{arg1})
	fake.recordInvocation("UpdateItem", []interface{}{arg1})
	fake.updateItemMutex.Unlock()
	if fake.UpdateItemStub != nil {
		return fake.UpdateItemStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateItemReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateItemCallCount() int {
	fake.updateItemMutex.RLock()
	defer fake.updateItemMutex.RUnlock()
	return len(fake.updateItemArgsForCall)
}

func (fake *FakeDynamoDB) UpdateItemCalls(stub func(*dynamodba.UpdateItemInput) (*dynamodba.UpdateItemOutput, error)) {
	fake.updateItemMutex.Lock()
	defer fake.updateItemMutex.Unlock()
	fake.UpdateItemStub = stub
}

func (fake *FakeDynamoDB) UpdateItemArgsForCall(i int) *dynamodba.UpdateItemInput {
	fake.updateItemMutex.RLock()
	defer fake.updateItemMutex.RUnlock()
	argsForCall := fake.updateItemArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateItemReturns(result1 *dynamodba.UpdateItemOutput, result2 error) {
	fake.updateItemMutex.Lock()
	defer fake.updateItemMutex.Unlock()
	fake.UpdateItemStub = nil
	fake.updateItemReturns = struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateItemReturnsOnCall(i int, result1 *dynamodba.UpdateItemOutput, result2 error) {
	fake.updateItemMutex.Lock()
	defer fake.updateItemMutex.Unlock()
	fake.UpdateItemStub = nil
	if fake.updateItemReturnsOnCall == nil {
		fake.updateItemReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateItemOutput
			result2 error
		})
	}
	fake.updateItemReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateItemRequest(arg1 *dynamodba.UpdateItemInput) (*request.Request, *dynamodba.UpdateItemOutput) {
	fake.updateItemRequestMutex.Lock()
	ret, specificReturn := fake.updateItemRequestReturnsOnCall[len(fake.updateItemRequestArgsForCall)]
	fake.updateItemRequestArgsForCall = append(fake.updateItemRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateItemInput
	}{arg1})
	fake.recordInvocation("UpdateItemRequest", []interface{}{arg1})
	fake.updateItemRequestMutex.Unlock()
	if fake.UpdateItemRequestStub != nil {
		return fake.UpdateItemRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateItemRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateItemRequestCallCount() int {
	fake.updateItemRequestMutex.RLock()
	defer fake.updateItemRequestMutex.RUnlock()
	return len(fake.updateItemRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateItemRequestCalls(stub func(*dynamodba.UpdateItemInput) (*request.Request, *dynamodba.UpdateItemOutput)) {
	fake.updateItemRequestMutex.Lock()
	defer fake.updateItemRequestMutex.Unlock()
	fake.UpdateItemRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateItemRequestArgsForCall(i int) *dynamodba.UpdateItemInput {
	fake.updateItemRequestMutex.RLock()
	defer fake.updateItemRequestMutex.RUnlock()
	argsForCall := fake.updateItemRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateItemRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateItemOutput) {
	fake.updateItemRequestMutex.Lock()
	defer fake.updateItemRequestMutex.Unlock()
	fake.UpdateItemRequestStub = nil
	fake.updateItemRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateItemRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateItemOutput) {
	fake.updateItemRequestMutex.Lock()
	defer fake.updateItemRequestMutex.Unlock()
	fake.UpdateItemRequestStub = nil
	if fake.updateItemRequestReturnsOnCall == nil {
		fake.updateItemRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateItemOutput
		})
	}
	fake.updateItemRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateItemOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateItemWithContext(arg1 context.Context, arg2 *dynamodba.UpdateItemInput, arg3 ...request.Option) (*dynamodba.UpdateItemOutput, error) {
	fake.updateItemWithContextMutex.Lock()
	ret, specificReturn := fake.updateItemWithContextReturnsOnCall[len(fake.updateItemWithContextArgsForCall)]
	fake.updateItemWithContextArgsForCall = append(fake.updateItemWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateItemInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateItemWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateItemWithContextMutex.Unlock()
	if fake.UpdateItemWithContextStub != nil {
		return fake.UpdateItemWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateItemWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateItemWithContextCallCount() int {
	fake.updateItemWithContextMutex.RLock()
	defer fake.updateItemWithContextMutex.RUnlock()
	return len(fake.updateItemWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateItemWithContextCalls(stub func(context.Context, *dynamodba.UpdateItemInput, ...request.Option) (*dynamodba.UpdateItemOutput, error)) {
	fake.updateItemWithContextMutex.Lock()
	defer fake.updateItemWithContextMutex.Unlock()
	fake.UpdateItemWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateItemWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateItemInput, []request.Option) {
	fake.updateItemWithContextMutex.RLock()
	defer fake.updateItemWithContextMutex.RUnlock()
	argsForCall := fake.updateItemWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateItemWithContextReturns(result1 *dynamodba.UpdateItemOutput, result2 error) {
	fake.updateItemWithContextMutex.Lock()
	defer fake.updateItemWithContextMutex.Unlock()
	fake.UpdateItemWithContextStub = nil
	fake.updateItemWithContextReturns = struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateItemWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateItemOutput, result2 error) {
	fake.updateItemWithContextMutex.Lock()
	defer fake.updateItemWithContextMutex.Unlock()
	fake.UpdateItemWithContextStub = nil
	if fake.updateItemWithContextReturnsOnCall == nil {
		fake.updateItemWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateItemOutput
			result2 error
		})
	}
	fake.updateItemWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateItemOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTable(arg1 *dynamodba.UpdateTableInput) (*dynamodba.UpdateTableOutput, error) {
	fake.updateTableMutex.Lock()
	ret, specificReturn := fake.updateTableReturnsOnCall[len(fake.updateTableArgsForCall)]
	fake.updateTableArgsForCall = append(fake.updateTableArgsForCall, struct {
		arg1 *dynamodba.UpdateTableInput
	}{arg1})
	fake.recordInvocation("UpdateTable", []interface{}{arg1})
	fake.updateTableMutex.Unlock()
	if fake.UpdateTableStub != nil {
		return fake.UpdateTableStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTableReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTableCallCount() int {
	fake.updateTableMutex.RLock()
	defer fake.updateTableMutex.RUnlock()
	return len(fake.updateTableArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTableCalls(stub func(*dynamodba.UpdateTableInput) (*dynamodba.UpdateTableOutput, error)) {
	fake.updateTableMutex.Lock()
	defer fake.updateTableMutex.Unlock()
	fake.UpdateTableStub = stub
}

func (fake *FakeDynamoDB) UpdateTableArgsForCall(i int) *dynamodba.UpdateTableInput {
	fake.updateTableMutex.RLock()
	defer fake.updateTableMutex.RUnlock()
	argsForCall := fake.updateTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateTableReturns(result1 *dynamodba.UpdateTableOutput, result2 error) {
	fake.updateTableMutex.Lock()
	defer fake.updateTableMutex.Unlock()
	fake.UpdateTableStub = nil
	fake.updateTableReturns = struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReturnsOnCall(i int, result1 *dynamodba.UpdateTableOutput, result2 error) {
	fake.updateTableMutex.Lock()
	defer fake.updateTableMutex.Unlock()
	fake.UpdateTableStub = nil
	if fake.updateTableReturnsOnCall == nil {
		fake.updateTableReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateTableOutput
			result2 error
		})
	}
	fake.updateTableReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScaling(arg1 *dynamodba.UpdateTableReplicaAutoScalingInput) (*dynamodba.UpdateTableReplicaAutoScalingOutput, error) {
	fake.updateTableReplicaAutoScalingMutex.Lock()
	ret, specificReturn := fake.updateTableReplicaAutoScalingReturnsOnCall[len(fake.updateTableReplicaAutoScalingArgsForCall)]
	fake.updateTableReplicaAutoScalingArgsForCall = append(fake.updateTableReplicaAutoScalingArgsForCall, struct {
		arg1 *dynamodba.UpdateTableReplicaAutoScalingInput
	}{arg1})
	fake.recordInvocation("UpdateTableReplicaAutoScaling", []interface{}{arg1})
	fake.updateTableReplicaAutoScalingMutex.Unlock()
	if fake.UpdateTableReplicaAutoScalingStub != nil {
		return fake.UpdateTableReplicaAutoScalingStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTableReplicaAutoScalingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingCallCount() int {
	fake.updateTableReplicaAutoScalingMutex.RLock()
	defer fake.updateTableReplicaAutoScalingMutex.RUnlock()
	return len(fake.updateTableReplicaAutoScalingArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingCalls(stub func(*dynamodba.UpdateTableReplicaAutoScalingInput) (*dynamodba.UpdateTableReplicaAutoScalingOutput, error)) {
	fake.updateTableReplicaAutoScalingMutex.Lock()
	defer fake.updateTableReplicaAutoScalingMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingStub = stub
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingArgsForCall(i int) *dynamodba.UpdateTableReplicaAutoScalingInput {
	fake.updateTableReplicaAutoScalingMutex.RLock()
	defer fake.updateTableReplicaAutoScalingMutex.RUnlock()
	argsForCall := fake.updateTableReplicaAutoScalingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingReturns(result1 *dynamodba.UpdateTableReplicaAutoScalingOutput, result2 error) {
	fake.updateTableReplicaAutoScalingMutex.Lock()
	defer fake.updateTableReplicaAutoScalingMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingStub = nil
	fake.updateTableReplicaAutoScalingReturns = struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingReturnsOnCall(i int, result1 *dynamodba.UpdateTableReplicaAutoScalingOutput, result2 error) {
	fake.updateTableReplicaAutoScalingMutex.Lock()
	defer fake.updateTableReplicaAutoScalingMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingStub = nil
	if fake.updateTableReplicaAutoScalingReturnsOnCall == nil {
		fake.updateTableReplicaAutoScalingReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
			result2 error
		})
	}
	fake.updateTableReplicaAutoScalingReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingRequest(arg1 *dynamodba.UpdateTableReplicaAutoScalingInput) (*request.Request, *dynamodba.UpdateTableReplicaAutoScalingOutput) {
	fake.updateTableReplicaAutoScalingRequestMutex.Lock()
	ret, specificReturn := fake.updateTableReplicaAutoScalingRequestReturnsOnCall[len(fake.updateTableReplicaAutoScalingRequestArgsForCall)]
	fake.updateTableReplicaAutoScalingRequestArgsForCall = append(fake.updateTableReplicaAutoScalingRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateTableReplicaAutoScalingInput
	}{arg1})
	fake.recordInvocation("UpdateTableReplicaAutoScalingRequest", []interface{}{arg1})
	fake.updateTableReplicaAutoScalingRequestMutex.Unlock()
	if fake.UpdateTableReplicaAutoScalingRequestStub != nil {
		return fake.UpdateTableReplicaAutoScalingRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTableReplicaAutoScalingRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingRequestCallCount() int {
	fake.updateTableReplicaAutoScalingRequestMutex.RLock()
	defer fake.updateTableReplicaAutoScalingRequestMutex.RUnlock()
	return len(fake.updateTableReplicaAutoScalingRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingRequestCalls(stub func(*dynamodba.UpdateTableReplicaAutoScalingInput) (*request.Request, *dynamodba.UpdateTableReplicaAutoScalingOutput)) {
	fake.updateTableReplicaAutoScalingRequestMutex.Lock()
	defer fake.updateTableReplicaAutoScalingRequestMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingRequestArgsForCall(i int) *dynamodba.UpdateTableReplicaAutoScalingInput {
	fake.updateTableReplicaAutoScalingRequestMutex.RLock()
	defer fake.updateTableReplicaAutoScalingRequestMutex.RUnlock()
	argsForCall := fake.updateTableReplicaAutoScalingRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateTableReplicaAutoScalingOutput) {
	fake.updateTableReplicaAutoScalingRequestMutex.Lock()
	defer fake.updateTableReplicaAutoScalingRequestMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingRequestStub = nil
	fake.updateTableReplicaAutoScalingRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableReplicaAutoScalingOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateTableReplicaAutoScalingOutput) {
	fake.updateTableReplicaAutoScalingRequestMutex.Lock()
	defer fake.updateTableReplicaAutoScalingRequestMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingRequestStub = nil
	if fake.updateTableReplicaAutoScalingRequestReturnsOnCall == nil {
		fake.updateTableReplicaAutoScalingRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateTableReplicaAutoScalingOutput
		})
	}
	fake.updateTableReplicaAutoScalingRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableReplicaAutoScalingOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingWithContext(arg1 context.Context, arg2 *dynamodba.UpdateTableReplicaAutoScalingInput, arg3 ...request.Option) (*dynamodba.UpdateTableReplicaAutoScalingOutput, error) {
	fake.updateTableReplicaAutoScalingWithContextMutex.Lock()
	ret, specificReturn := fake.updateTableReplicaAutoScalingWithContextReturnsOnCall[len(fake.updateTableReplicaAutoScalingWithContextArgsForCall)]
	fake.updateTableReplicaAutoScalingWithContextArgsForCall = append(fake.updateTableReplicaAutoScalingWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateTableReplicaAutoScalingInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateTableReplicaAutoScalingWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateTableReplicaAutoScalingWithContextMutex.Unlock()
	if fake.UpdateTableReplicaAutoScalingWithContextStub != nil {
		return fake.UpdateTableReplicaAutoScalingWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTableReplicaAutoScalingWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingWithContextCallCount() int {
	fake.updateTableReplicaAutoScalingWithContextMutex.RLock()
	defer fake.updateTableReplicaAutoScalingWithContextMutex.RUnlock()
	return len(fake.updateTableReplicaAutoScalingWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingWithContextCalls(stub func(context.Context, *dynamodba.UpdateTableReplicaAutoScalingInput, ...request.Option) (*dynamodba.UpdateTableReplicaAutoScalingOutput, error)) {
	fake.updateTableReplicaAutoScalingWithContextMutex.Lock()
	defer fake.updateTableReplicaAutoScalingWithContextMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateTableReplicaAutoScalingInput, []request.Option) {
	fake.updateTableReplicaAutoScalingWithContextMutex.RLock()
	defer fake.updateTableReplicaAutoScalingWithContextMutex.RUnlock()
	argsForCall := fake.updateTableReplicaAutoScalingWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingWithContextReturns(result1 *dynamodba.UpdateTableReplicaAutoScalingOutput, result2 error) {
	fake.updateTableReplicaAutoScalingWithContextMutex.Lock()
	defer fake.updateTableReplicaAutoScalingWithContextMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingWithContextStub = nil
	fake.updateTableReplicaAutoScalingWithContextReturns = struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableReplicaAutoScalingWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateTableReplicaAutoScalingOutput, result2 error) {
	fake.updateTableReplicaAutoScalingWithContextMutex.Lock()
	defer fake.updateTableReplicaAutoScalingWithContextMutex.Unlock()
	fake.UpdateTableReplicaAutoScalingWithContextStub = nil
	if fake.updateTableReplicaAutoScalingWithContextReturnsOnCall == nil {
		fake.updateTableReplicaAutoScalingWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
			result2 error
		})
	}
	fake.updateTableReplicaAutoScalingWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateTableReplicaAutoScalingOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableRequest(arg1 *dynamodba.UpdateTableInput) (*request.Request, *dynamodba.UpdateTableOutput) {
	fake.updateTableRequestMutex.Lock()
	ret, specificReturn := fake.updateTableRequestReturnsOnCall[len(fake.updateTableRequestArgsForCall)]
	fake.updateTableRequestArgsForCall = append(fake.updateTableRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateTableInput
	}{arg1})
	fake.recordInvocation("UpdateTableRequest", []interface{}{arg1})
	fake.updateTableRequestMutex.Unlock()
	if fake.UpdateTableRequestStub != nil {
		return fake.UpdateTableRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTableRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTableRequestCallCount() int {
	fake.updateTableRequestMutex.RLock()
	defer fake.updateTableRequestMutex.RUnlock()
	return len(fake.updateTableRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTableRequestCalls(stub func(*dynamodba.UpdateTableInput) (*request.Request, *dynamodba.UpdateTableOutput)) {
	fake.updateTableRequestMutex.Lock()
	defer fake.updateTableRequestMutex.Unlock()
	fake.UpdateTableRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateTableRequestArgsForCall(i int) *dynamodba.UpdateTableInput {
	fake.updateTableRequestMutex.RLock()
	defer fake.updateTableRequestMutex.RUnlock()
	argsForCall := fake.updateTableRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateTableRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateTableOutput) {
	fake.updateTableRequestMutex.Lock()
	defer fake.updateTableRequestMutex.Unlock()
	fake.UpdateTableRequestStub = nil
	fake.updateTableRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateTableOutput) {
	fake.updateTableRequestMutex.Lock()
	defer fake.updateTableRequestMutex.Unlock()
	fake.UpdateTableRequestStub = nil
	if fake.updateTableRequestReturnsOnCall == nil {
		fake.updateTableRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateTableOutput
		})
	}
	fake.updateTableRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTableOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableWithContext(arg1 context.Context, arg2 *dynamodba.UpdateTableInput, arg3 ...request.Option) (*dynamodba.UpdateTableOutput, error) {
	fake.updateTableWithContextMutex.Lock()
	ret, specificReturn := fake.updateTableWithContextReturnsOnCall[len(fake.updateTableWithContextArgsForCall)]
	fake.updateTableWithContextArgsForCall = append(fake.updateTableWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateTableInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateTableWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateTableWithContextMutex.Unlock()
	if fake.UpdateTableWithContextStub != nil {
		return fake.UpdateTableWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTableWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTableWithContextCallCount() int {
	fake.updateTableWithContextMutex.RLock()
	defer fake.updateTableWithContextMutex.RUnlock()
	return len(fake.updateTableWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTableWithContextCalls(stub func(context.Context, *dynamodba.UpdateTableInput, ...request.Option) (*dynamodba.UpdateTableOutput, error)) {
	fake.updateTableWithContextMutex.Lock()
	defer fake.updateTableWithContextMutex.Unlock()
	fake.UpdateTableWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateTableWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateTableInput, []request.Option) {
	fake.updateTableWithContextMutex.RLock()
	defer fake.updateTableWithContextMutex.RUnlock()
	argsForCall := fake.updateTableWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateTableWithContextReturns(result1 *dynamodba.UpdateTableOutput, result2 error) {
	fake.updateTableWithContextMutex.Lock()
	defer fake.updateTableWithContextMutex.Unlock()
	fake.UpdateTableWithContextStub = nil
	fake.updateTableWithContextReturns = struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTableWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateTableOutput, result2 error) {
	fake.updateTableWithContextMutex.Lock()
	defer fake.updateTableWithContextMutex.Unlock()
	fake.UpdateTableWithContextStub = nil
	if fake.updateTableWithContextReturnsOnCall == nil {
		fake.updateTableWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateTableOutput
			result2 error
		})
	}
	fake.updateTableWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateTableOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTimeToLive(arg1 *dynamodba.UpdateTimeToLiveInput) (*dynamodba.UpdateTimeToLiveOutput, error) {
	fake.updateTimeToLiveMutex.Lock()
	ret, specificReturn := fake.updateTimeToLiveReturnsOnCall[len(fake.updateTimeToLiveArgsForCall)]
	fake.updateTimeToLiveArgsForCall = append(fake.updateTimeToLiveArgsForCall, struct {
		arg1 *dynamodba.UpdateTimeToLiveInput
	}{arg1})
	fake.recordInvocation("UpdateTimeToLive", []interface{}{arg1})
	fake.updateTimeToLiveMutex.Unlock()
	if fake.UpdateTimeToLiveStub != nil {
		return fake.UpdateTimeToLiveStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTimeToLiveReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTimeToLiveCallCount() int {
	fake.updateTimeToLiveMutex.RLock()
	defer fake.updateTimeToLiveMutex.RUnlock()
	return len(fake.updateTimeToLiveArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTimeToLiveCalls(stub func(*dynamodba.UpdateTimeToLiveInput) (*dynamodba.UpdateTimeToLiveOutput, error)) {
	fake.updateTimeToLiveMutex.Lock()
	defer fake.updateTimeToLiveMutex.Unlock()
	fake.UpdateTimeToLiveStub = stub
}

func (fake *FakeDynamoDB) UpdateTimeToLiveArgsForCall(i int) *dynamodba.UpdateTimeToLiveInput {
	fake.updateTimeToLiveMutex.RLock()
	defer fake.updateTimeToLiveMutex.RUnlock()
	argsForCall := fake.updateTimeToLiveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateTimeToLiveReturns(result1 *dynamodba.UpdateTimeToLiveOutput, result2 error) {
	fake.updateTimeToLiveMutex.Lock()
	defer fake.updateTimeToLiveMutex.Unlock()
	fake.UpdateTimeToLiveStub = nil
	fake.updateTimeToLiveReturns = struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTimeToLiveReturnsOnCall(i int, result1 *dynamodba.UpdateTimeToLiveOutput, result2 error) {
	fake.updateTimeToLiveMutex.Lock()
	defer fake.updateTimeToLiveMutex.Unlock()
	fake.UpdateTimeToLiveStub = nil
	if fake.updateTimeToLiveReturnsOnCall == nil {
		fake.updateTimeToLiveReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateTimeToLiveOutput
			result2 error
		})
	}
	fake.updateTimeToLiveReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTimeToLiveRequest(arg1 *dynamodba.UpdateTimeToLiveInput) (*request.Request, *dynamodba.UpdateTimeToLiveOutput) {
	fake.updateTimeToLiveRequestMutex.Lock()
	ret, specificReturn := fake.updateTimeToLiveRequestReturnsOnCall[len(fake.updateTimeToLiveRequestArgsForCall)]
	fake.updateTimeToLiveRequestArgsForCall = append(fake.updateTimeToLiveRequestArgsForCall, struct {
		arg1 *dynamodba.UpdateTimeToLiveInput
	}{arg1})
	fake.recordInvocation("UpdateTimeToLiveRequest", []interface{}{arg1})
	fake.updateTimeToLiveRequestMutex.Unlock()
	if fake.UpdateTimeToLiveRequestStub != nil {
		return fake.UpdateTimeToLiveRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTimeToLiveRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTimeToLiveRequestCallCount() int {
	fake.updateTimeToLiveRequestMutex.RLock()
	defer fake.updateTimeToLiveRequestMutex.RUnlock()
	return len(fake.updateTimeToLiveRequestArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTimeToLiveRequestCalls(stub func(*dynamodba.UpdateTimeToLiveInput) (*request.Request, *dynamodba.UpdateTimeToLiveOutput)) {
	fake.updateTimeToLiveRequestMutex.Lock()
	defer fake.updateTimeToLiveRequestMutex.Unlock()
	fake.UpdateTimeToLiveRequestStub = stub
}

func (fake *FakeDynamoDB) UpdateTimeToLiveRequestArgsForCall(i int) *dynamodba.UpdateTimeToLiveInput {
	fake.updateTimeToLiveRequestMutex.RLock()
	defer fake.updateTimeToLiveRequestMutex.RUnlock()
	argsForCall := fake.updateTimeToLiveRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) UpdateTimeToLiveRequestReturns(result1 *request.Request, result2 *dynamodba.UpdateTimeToLiveOutput) {
	fake.updateTimeToLiveRequestMutex.Lock()
	defer fake.updateTimeToLiveRequestMutex.Unlock()
	fake.UpdateTimeToLiveRequestStub = nil
	fake.updateTimeToLiveRequestReturns = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTimeToLiveOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTimeToLiveRequestReturnsOnCall(i int, result1 *request.Request, result2 *dynamodba.UpdateTimeToLiveOutput) {
	fake.updateTimeToLiveRequestMutex.Lock()
	defer fake.updateTimeToLiveRequestMutex.Unlock()
	fake.UpdateTimeToLiveRequestStub = nil
	if fake.updateTimeToLiveRequestReturnsOnCall == nil {
		fake.updateTimeToLiveRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *dynamodba.UpdateTimeToLiveOutput
		})
	}
	fake.updateTimeToLiveRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *dynamodba.UpdateTimeToLiveOutput
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTimeToLiveWithContext(arg1 context.Context, arg2 *dynamodba.UpdateTimeToLiveInput, arg3 ...request.Option) (*dynamodba.UpdateTimeToLiveOutput, error) {
	fake.updateTimeToLiveWithContextMutex.Lock()
	ret, specificReturn := fake.updateTimeToLiveWithContextReturnsOnCall[len(fake.updateTimeToLiveWithContextArgsForCall)]
	fake.updateTimeToLiveWithContextArgsForCall = append(fake.updateTimeToLiveWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.UpdateTimeToLiveInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateTimeToLiveWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateTimeToLiveWithContextMutex.Unlock()
	if fake.UpdateTimeToLiveWithContextStub != nil {
		return fake.UpdateTimeToLiveWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateTimeToLiveWithContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDynamoDB) UpdateTimeToLiveWithContextCallCount() int {
	fake.updateTimeToLiveWithContextMutex.RLock()
	defer fake.updateTimeToLiveWithContextMutex.RUnlock()
	return len(fake.updateTimeToLiveWithContextArgsForCall)
}

func (fake *FakeDynamoDB) UpdateTimeToLiveWithContextCalls(stub func(context.Context, *dynamodba.UpdateTimeToLiveInput, ...request.Option) (*dynamodba.UpdateTimeToLiveOutput, error)) {
	fake.updateTimeToLiveWithContextMutex.Lock()
	defer fake.updateTimeToLiveWithContextMutex.Unlock()
	fake.UpdateTimeToLiveWithContextStub = stub
}

func (fake *FakeDynamoDB) UpdateTimeToLiveWithContextArgsForCall(i int) (context.Context, *dynamodba.UpdateTimeToLiveInput, []request.Option) {
	fake.updateTimeToLiveWithContextMutex.RLock()
	defer fake.updateTimeToLiveWithContextMutex.RUnlock()
	argsForCall := fake.updateTimeToLiveWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) UpdateTimeToLiveWithContextReturns(result1 *dynamodba.UpdateTimeToLiveOutput, result2 error) {
	fake.updateTimeToLiveWithContextMutex.Lock()
	defer fake.updateTimeToLiveWithContextMutex.Unlock()
	fake.UpdateTimeToLiveWithContextStub = nil
	fake.updateTimeToLiveWithContextReturns = struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) UpdateTimeToLiveWithContextReturnsOnCall(i int, result1 *dynamodba.UpdateTimeToLiveOutput, result2 error) {
	fake.updateTimeToLiveWithContextMutex.Lock()
	defer fake.updateTimeToLiveWithContextMutex.Unlock()
	fake.UpdateTimeToLiveWithContextStub = nil
	if fake.updateTimeToLiveWithContextReturnsOnCall == nil {
		fake.updateTimeToLiveWithContextReturnsOnCall = make(map[int]struct {
			result1 *dynamodba.UpdateTimeToLiveOutput
			result2 error
		})
	}
	fake.updateTimeToLiveWithContextReturnsOnCall[i] = struct {
		result1 *dynamodba.UpdateTimeToLiveOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeDynamoDB) WaitUntilTableExists(arg1 *dynamodba.DescribeTableInput) error {
	fake.waitUntilTableExistsMutex.Lock()
	ret, specificReturn := fake.waitUntilTableExistsReturnsOnCall[len(fake.waitUntilTableExistsArgsForCall)]
	fake.waitUntilTableExistsArgsForCall = append(fake.waitUntilTableExistsArgsForCall, struct {
		arg1 *dynamodba.DescribeTableInput
	}{arg1})
	fake.recordInvocation("WaitUntilTableExists", []interface{}{arg1})
	fake.waitUntilTableExistsMutex.Unlock()
	if fake.WaitUntilTableExistsStub != nil {
		return fake.WaitUntilTableExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitUntilTableExistsReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) WaitUntilTableExistsCallCount() int {
	fake.waitUntilTableExistsMutex.RLock()
	defer fake.waitUntilTableExistsMutex.RUnlock()
	return len(fake.waitUntilTableExistsArgsForCall)
}

func (fake *FakeDynamoDB) WaitUntilTableExistsCalls(stub func(*dynamodba.DescribeTableInput) error) {
	fake.waitUntilTableExistsMutex.Lock()
	defer fake.waitUntilTableExistsMutex.Unlock()
	fake.WaitUntilTableExistsStub = stub
}

func (fake *FakeDynamoDB) WaitUntilTableExistsArgsForCall(i int) *dynamodba.DescribeTableInput {
	fake.waitUntilTableExistsMutex.RLock()
	defer fake.waitUntilTableExistsMutex.RUnlock()
	argsForCall := fake.waitUntilTableExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) WaitUntilTableExistsReturns(result1 error) {
	fake.waitUntilTableExistsMutex.Lock()
	defer fake.waitUntilTableExistsMutex.Unlock()
	fake.WaitUntilTableExistsStub = nil
	fake.waitUntilTableExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableExistsReturnsOnCall(i int, result1 error) {
	fake.waitUntilTableExistsMutex.Lock()
	defer fake.waitUntilTableExistsMutex.Unlock()
	fake.WaitUntilTableExistsStub = nil
	if fake.waitUntilTableExistsReturnsOnCall == nil {
		fake.waitUntilTableExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilTableExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableExistsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeTableInput, arg3 ...request.WaiterOption) error {
	fake.waitUntilTableExistsWithContextMutex.Lock()
	ret, specificReturn := fake.waitUntilTableExistsWithContextReturnsOnCall[len(fake.waitUntilTableExistsWithContextArgsForCall)]
	fake.waitUntilTableExistsWithContextArgsForCall = append(fake.waitUntilTableExistsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableInput
		arg3 []request.WaiterOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("WaitUntilTableExistsWithContext", []interface{}{arg1, arg2, arg3})
	fake.waitUntilTableExistsWithContextMutex.Unlock()
	if fake.WaitUntilTableExistsWithContextStub != nil {
		return fake.WaitUntilTableExistsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitUntilTableExistsWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) WaitUntilTableExistsWithContextCallCount() int {
	fake.waitUntilTableExistsWithContextMutex.RLock()
	defer fake.waitUntilTableExistsWithContextMutex.RUnlock()
	return len(fake.waitUntilTableExistsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) WaitUntilTableExistsWithContextCalls(stub func(context.Context, *dynamodba.DescribeTableInput, ...request.WaiterOption) error) {
	fake.waitUntilTableExistsWithContextMutex.Lock()
	defer fake.waitUntilTableExistsWithContextMutex.Unlock()
	fake.WaitUntilTableExistsWithContextStub = stub
}

func (fake *FakeDynamoDB) WaitUntilTableExistsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeTableInput, []request.WaiterOption) {
	fake.waitUntilTableExistsWithContextMutex.RLock()
	defer fake.waitUntilTableExistsWithContextMutex.RUnlock()
	argsForCall := fake.waitUntilTableExistsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) WaitUntilTableExistsWithContextReturns(result1 error) {
	fake.waitUntilTableExistsWithContextMutex.Lock()
	defer fake.waitUntilTableExistsWithContextMutex.Unlock()
	fake.WaitUntilTableExistsWithContextStub = nil
	fake.waitUntilTableExistsWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableExistsWithContextReturnsOnCall(i int, result1 error) {
	fake.waitUntilTableExistsWithContextMutex.Lock()
	defer fake.waitUntilTableExistsWithContextMutex.Unlock()
	fake.WaitUntilTableExistsWithContextStub = nil
	if fake.waitUntilTableExistsWithContextReturnsOnCall == nil {
		fake.waitUntilTableExistsWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilTableExistsWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableNotExists(arg1 *dynamodba.DescribeTableInput) error {
	fake.waitUntilTableNotExistsMutex.Lock()
	ret, specificReturn := fake.waitUntilTableNotExistsReturnsOnCall[len(fake.waitUntilTableNotExistsArgsForCall)]
	fake.waitUntilTableNotExistsArgsForCall = append(fake.waitUntilTableNotExistsArgsForCall, struct {
		arg1 *dynamodba.DescribeTableInput
	}{arg1})
	fake.recordInvocation("WaitUntilTableNotExists", []interface{}{arg1})
	fake.waitUntilTableNotExistsMutex.Unlock()
	if fake.WaitUntilTableNotExistsStub != nil {
		return fake.WaitUntilTableNotExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitUntilTableNotExistsReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsCallCount() int {
	fake.waitUntilTableNotExistsMutex.RLock()
	defer fake.waitUntilTableNotExistsMutex.RUnlock()
	return len(fake.waitUntilTableNotExistsArgsForCall)
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsCalls(stub func(*dynamodba.DescribeTableInput) error) {
	fake.waitUntilTableNotExistsMutex.Lock()
	defer fake.waitUntilTableNotExistsMutex.Unlock()
	fake.WaitUntilTableNotExistsStub = stub
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsArgsForCall(i int) *dynamodba.DescribeTableInput {
	fake.waitUntilTableNotExistsMutex.RLock()
	defer fake.waitUntilTableNotExistsMutex.RUnlock()
	argsForCall := fake.waitUntilTableNotExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsReturns(result1 error) {
	fake.waitUntilTableNotExistsMutex.Lock()
	defer fake.waitUntilTableNotExistsMutex.Unlock()
	fake.WaitUntilTableNotExistsStub = nil
	fake.waitUntilTableNotExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsReturnsOnCall(i int, result1 error) {
	fake.waitUntilTableNotExistsMutex.Lock()
	defer fake.waitUntilTableNotExistsMutex.Unlock()
	fake.WaitUntilTableNotExistsStub = nil
	if fake.waitUntilTableNotExistsReturnsOnCall == nil {
		fake.waitUntilTableNotExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilTableNotExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsWithContext(arg1 context.Context, arg2 *dynamodba.DescribeTableInput, arg3 ...request.WaiterOption) error {
	fake.waitUntilTableNotExistsWithContextMutex.Lock()
	ret, specificReturn := fake.waitUntilTableNotExistsWithContextReturnsOnCall[len(fake.waitUntilTableNotExistsWithContextArgsForCall)]
	fake.waitUntilTableNotExistsWithContextArgsForCall = append(fake.waitUntilTableNotExistsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *dynamodba.DescribeTableInput
		arg3 []request.WaiterOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("WaitUntilTableNotExistsWithContext", []interface{}{arg1, arg2, arg3})
	fake.waitUntilTableNotExistsWithContextMutex.Unlock()
	if fake.WaitUntilTableNotExistsWithContextStub != nil {
		return fake.WaitUntilTableNotExistsWithContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitUntilTableNotExistsWithContextReturns
	return fakeReturns.result1
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsWithContextCallCount() int {
	fake.waitUntilTableNotExistsWithContextMutex.RLock()
	defer fake.waitUntilTableNotExistsWithContextMutex.RUnlock()
	return len(fake.waitUntilTableNotExistsWithContextArgsForCall)
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsWithContextCalls(stub func(context.Context, *dynamodba.DescribeTableInput, ...request.WaiterOption) error) {
	fake.waitUntilTableNotExistsWithContextMutex.Lock()
	defer fake.waitUntilTableNotExistsWithContextMutex.Unlock()
	fake.WaitUntilTableNotExistsWithContextStub = stub
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsWithContextArgsForCall(i int) (context.Context, *dynamodba.DescribeTableInput, []request.WaiterOption) {
	fake.waitUntilTableNotExistsWithContextMutex.RLock()
	defer fake.waitUntilTableNotExistsWithContextMutex.RUnlock()
	argsForCall := fake.waitUntilTableNotExistsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsWithContextReturns(result1 error) {
	fake.waitUntilTableNotExistsWithContextMutex.Lock()
	defer fake.waitUntilTableNotExistsWithContextMutex.Unlock()
	fake.WaitUntilTableNotExistsWithContextStub = nil
	fake.waitUntilTableNotExistsWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) WaitUntilTableNotExistsWithContextReturnsOnCall(i int, result1 error) {
	fake.waitUntilTableNotExistsWithContextMutex.Lock()
	defer fake.waitUntilTableNotExistsWithContextMutex.Unlock()
	fake.WaitUntilTableNotExistsWithContextStub = nil
	if fake.waitUntilTableNotExistsWithContextReturnsOnCall == nil {
		fake.waitUntilTableNotExistsWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilTableNotExistsWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDynamoDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.batchExecuteStatementMutex.RLock()
	defer fake.batchExecuteStatementMutex.RUnlock()
	fake.batchExecuteStatementRequestMutex.RLock()
	defer fake.batchExecuteStatementRequestMutex.RUnlock()
	fake.batchExecuteStatementWithContextMutex.RLock()
	defer fake.batchExecuteStatementWithContextMutex.RUnlock()
	fake.batchGetItemMutex.RLock()
	defer fake.batchGetItemMutex.RUnlock()
	fake.batchGetItemPagesMutex.RLock()
	defer fake.batchGetItemPagesMutex.RUnlock()
	fake.batchGetItemPagesWithContextMutex.RLock()
	defer fake.batchGetItemPagesWithContextMutex.RUnlock()
	fake.batchGetItemRequestMutex.RLock()
	defer fake.batchGetItemRequestMutex.RUnlock()
	fake.batchGetItemWithContextMutex.RLock()
	defer fake.batchGetItemWithContextMutex.RUnlock()
	fake.batchWriteItemMutex.RLock()
	defer fake.batchWriteItemMutex.RUnlock()
	fake.batchWriteItemRequestMutex.RLock()
	defer fake.batchWriteItemRequestMutex.RUnlock()
	fake.batchWriteItemWithContextMutex.RLock()
	defer fake.batchWriteItemWithContextMutex.RUnlock()
	fake.createBackupMutex.RLock()
	defer fake.createBackupMutex.RUnlock()
	fake.createBackupRequestMutex.RLock()
	defer fake.createBackupRequestMutex.RUnlock()
	fake.createBackupWithContextMutex.RLock()
	defer fake.createBackupWithContextMutex.RUnlock()
	fake.createGlobalTableMutex.RLock()
	defer fake.createGlobalTableMutex.RUnlock()
	fake.createGlobalTableRequestMutex.RLock()
	defer fake.createGlobalTableRequestMutex.RUnlock()
	fake.createGlobalTableWithContextMutex.RLock()
	defer fake.createGlobalTableWithContextMutex.RUnlock()
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	fake.createTableRequestMutex.RLock()
	defer fake.createTableRequestMutex.RUnlock()
	fake.createTableWithContextMutex.RLock()
	defer fake.createTableWithContextMutex.RUnlock()
	fake.deleteBackupMutex.RLock()
	defer fake.deleteBackupMutex.RUnlock()
	fake.deleteBackupRequestMutex.RLock()
	defer fake.deleteBackupRequestMutex.RUnlock()
	fake.deleteBackupWithContextMutex.RLock()
	defer fake.deleteBackupWithContextMutex.RUnlock()
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	fake.deleteItemRequestMutex.RLock()
	defer fake.deleteItemRequestMutex.RUnlock()
	fake.deleteItemWithContextMutex.RLock()
	defer fake.deleteItemWithContextMutex.RUnlock()
	fake.deleteTableMutex.RLock()
	defer fake.deleteTableMutex.RUnlock()
	fake.deleteTableRequestMutex.RLock()
	defer fake.deleteTableRequestMutex.RUnlock()
	fake.deleteTableWithContextMutex.RLock()
	defer fake.deleteTableWithContextMutex.RUnlock()
	fake.describeBackupMutex.RLock()
	defer fake.describeBackupMutex.RUnlock()
	fake.describeBackupRequestMutex.RLock()
	defer fake.describeBackupRequestMutex.RUnlock()
	fake.describeBackupWithContextMutex.RLock()
	defer fake.describeBackupWithContextMutex.RUnlock()
	fake.describeContinuousBackupsMutex.RLock()
	defer fake.describeContinuousBackupsMutex.RUnlock()
	fake.describeContinuousBackupsRequestMutex.RLock()
	defer fake.describeContinuousBackupsRequestMutex.RUnlock()
	fake.describeContinuousBackupsWithContextMutex.RLock()
	defer fake.describeContinuousBackupsWithContextMutex.RUnlock()
	fake.describeContributorInsightsMutex.RLock()
	defer fake.describeContributorInsightsMutex.RUnlock()
	fake.describeContributorInsightsRequestMutex.RLock()
	defer fake.describeContributorInsightsRequestMutex.RUnlock()
	fake.describeContributorInsightsWithContextMutex.RLock()
	defer fake.describeContributorInsightsWithContextMutex.RUnlock()
	fake.describeEndpointsMutex.RLock()
	defer fake.describeEndpointsMutex.RUnlock()
	fake.describeEndpointsRequestMutex.RLock()
	defer fake.describeEndpointsRequestMutex.RUnlock()
	fake.describeEndpointsWithContextMutex.RLock()
	defer fake.describeEndpointsWithContextMutex.RUnlock()
	fake.describeExportMutex.RLock()
	defer fake.describeExportMutex.RUnlock()
	fake.describeExportRequestMutex.RLock()
	defer fake.describeExportRequestMutex.RUnlock()
	fake.describeExportWithContextMutex.RLock()
	defer fake.describeExportWithContextMutex.RUnlock()
	fake.describeGlobalTableMutex.RLock()
	defer fake.describeGlobalTableMutex.RUnlock()
	fake.describeGlobalTableRequestMutex.RLock()
	defer fake.describeGlobalTableRequestMutex.RUnlock()
	fake.describeGlobalTableSettingsMutex.RLock()
	defer fake.describeGlobalTableSettingsMutex.RUnlock()
	fake.describeGlobalTableSettingsRequestMutex.RLock()
	defer fake.describeGlobalTableSettingsRequestMutex.RUnlock()
	fake.describeGlobalTableSettingsWithContextMutex.RLock()
	defer fake.describeGlobalTableSettingsWithContextMutex.RUnlock()
	fake.describeGlobalTableWithContextMutex.RLock()
	defer fake.describeGlobalTableWithContextMutex.RUnlock()
	fake.describeKinesisStreamingDestinationMutex.RLock()
	defer fake.describeKinesisStreamingDestinationMutex.RUnlock()
	fake.describeKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.describeKinesisStreamingDestinationRequestMutex.RUnlock()
	fake.describeKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.describeKinesisStreamingDestinationWithContextMutex.RUnlock()
	fake.describeLimitsMutex.RLock()
	defer fake.describeLimitsMutex.RUnlock()
	fake.describeLimitsRequestMutex.RLock()
	defer fake.describeLimitsRequestMutex.RUnlock()
	fake.describeLimitsWithContextMutex.RLock()
	defer fake.describeLimitsWithContextMutex.RUnlock()
	fake.describeTableMutex.RLock()
	defer fake.describeTableMutex.RUnlock()
	fake.describeTableReplicaAutoScalingMutex.RLock()
	defer fake.describeTableReplicaAutoScalingMutex.RUnlock()
	fake.describeTableReplicaAutoScalingRequestMutex.RLock()
	defer fake.describeTableReplicaAutoScalingRequestMutex.RUnlock()
	fake.describeTableReplicaAutoScalingWithContextMutex.RLock()
	defer fake.describeTableReplicaAutoScalingWithContextMutex.RUnlock()
	fake.describeTableRequestMutex.RLock()
	defer fake.describeTableRequestMutex.RUnlock()
	fake.describeTableWithContextMutex.RLock()
	defer fake.describeTableWithContextMutex.RUnlock()
	fake.describeTimeToLiveMutex.RLock()
	defer fake.describeTimeToLiveMutex.RUnlock()
	fake.describeTimeToLiveRequestMutex.RLock()
	defer fake.describeTimeToLiveRequestMutex.RUnlock()
	fake.describeTimeToLiveWithContextMutex.RLock()
	defer fake.describeTimeToLiveWithContextMutex.RUnlock()
	fake.disableKinesisStreamingDestinationMutex.RLock()
	defer fake.disableKinesisStreamingDestinationMutex.RUnlock()
	fake.disableKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.disableKinesisStreamingDestinationRequestMutex.RUnlock()
	fake.disableKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.disableKinesisStreamingDestinationWithContextMutex.RUnlock()
	fake.enableKinesisStreamingDestinationMutex.RLock()
	defer fake.enableKinesisStreamingDestinationMutex.RUnlock()
	fake.enableKinesisStreamingDestinationRequestMutex.RLock()
	defer fake.enableKinesisStreamingDestinationRequestMutex.RUnlock()
	fake.enableKinesisStreamingDestinationWithContextMutex.RLock()
	defer fake.enableKinesisStreamingDestinationWithContextMutex.RUnlock()
	fake.executeStatementMutex.RLock()
	defer fake.executeStatementMutex.RUnlock()
	fake.executeStatementRequestMutex.RLock()
	defer fake.executeStatementRequestMutex.RUnlock()
	fake.executeStatementWithContextMutex.RLock()
	defer fake.executeStatementWithContextMutex.RUnlock()
	fake.executeTransactionMutex.RLock()
	defer fake.executeTransactionMutex.RUnlock()
	fake.executeTransactionRequestMutex.RLock()
	defer fake.executeTransactionRequestMutex.RUnlock()
	fake.executeTransactionWithContextMutex.RLock()
	defer fake.executeTransactionWithContextMutex.RUnlock()
	fake.exportTableToPointInTimeMutex.RLock()
	defer fake.exportTableToPointInTimeMutex.RUnlock()
	fake.exportTableToPointInTimeRequestMutex.RLock()
	defer fake.exportTableToPointInTimeRequestMutex.RUnlock()
	fake.exportTableToPointInTimeWithContextMutex.RLock()
	defer fake.exportTableToPointInTimeWithContextMutex.RUnlock()
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	fake.getItemRequestMutex.RLock()
	defer fake.getItemRequestMutex.RUnlock()
	fake.getItemWithContextMutex.RLock()
	defer fake.getItemWithContextMutex.RUnlock()
	fake.listBackupsMutex.RLock()
	defer fake.listBackupsMutex.RUnlock()
	fake.listBackupsRequestMutex.RLock()
	defer fake.listBackupsRequestMutex.RUnlock()
	fake.listBackupsWithContextMutex.RLock()
	defer fake.listBackupsWithContextMutex.RUnlock()
	fake.listContributorInsightsMutex.RLock()
	defer fake.listContributorInsightsMutex.RUnlock()
	fake.listContributorInsightsPagesMutex.RLock()
	defer fake.listContributorInsightsPagesMutex.RUnlock()
	fake.listContributorInsightsPagesWithContextMutex.RLock()
	defer fake.listContributorInsightsPagesWithContextMutex.RUnlock()
	fake.listContributorInsightsRequestMutex.RLock()
	defer fake.listContributorInsightsRequestMutex.RUnlock()
	fake.listContributorInsightsWithContextMutex.RLock()
	defer fake.listContributorInsightsWithContextMutex.RUnlock()
	fake.listExportsMutex.RLock()
	defer fake.listExportsMutex.RUnlock()
	fake.listExportsPagesMutex.RLock()
	defer fake.listExportsPagesMutex.RUnlock()
	fake.listExportsPagesWithContextMutex.RLock()
	defer fake.listExportsPagesWithContextMutex.RUnlock()
	fake.listExportsRequestMutex.RLock()
	defer fake.listExportsRequestMutex.RUnlock()
	fake.listExportsWithContextMutex.RLock()
	defer fake.listExportsWithContextMutex.RUnlock()
	fake.listGlobalTablesMutex.RLock()
	defer fake.listGlobalTablesMutex.RUnlock()
	fake.listGlobalTablesRequestMutex.RLock()
	defer fake.listGlobalTablesRequestMutex.RUnlock()
	fake.listGlobalTablesWithContextMutex.RLock()
	defer fake.listGlobalTablesWithContextMutex.RUnlock()
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	fake.listTablesPagesMutex.RLock()
	defer fake.listTablesPagesMutex.RUnlock()
	fake.listTablesPagesWithContextMutex.RLock()
	defer fake.listTablesPagesWithContextMutex.RUnlock()
	fake.listTablesRequestMutex.RLock()
	defer fake.listTablesRequestMutex.RUnlock()
	fake.listTablesWithContextMutex.RLock()
	defer fake.listTablesWithContextMutex.RUnlock()
	fake.listTagsOfResourceMutex.RLock()
	defer fake.listTagsOfResourceMutex.RUnlock()
	fake.listTagsOfResourceRequestMutex.RLock()
	defer fake.listTagsOfResourceRequestMutex.RUnlock()
	fake.listTagsOfResourceWithContextMutex.RLock()
	defer fake.listTagsOfResourceWithContextMutex.RUnlock()
	fake.putItemMutex.RLock()
	defer fake.putItemMutex.RUnlock()
	fake.putItemRequestMutex.RLock()
	defer fake.putItemRequestMutex.RUnlock()
	fake.putItemWithContextMutex.RLock()
	defer fake.putItemWithContextMutex.RUnlock()
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	fake.queryPagesMutex.RLock()
	defer fake.queryPagesMutex.RUnlock()
	fake.queryPagesWithContextMutex.RLock()
	defer fake.queryPagesWithContextMutex.RUnlock()
	fake.queryRequestMutex.RLock()
	defer fake.queryRequestMutex.RUnlock()
	fake.queryWithContextMutex.RLock()
	defer fake.queryWithContextMutex.RUnlock()
	fake.restoreTableFromBackupMutex.RLock()
	defer fake.restoreTableFromBackupMutex.RUnlock()
	fake.restoreTableFromBackupRequestMutex.RLock()
	defer fake.restoreTableFromBackupRequestMutex.RUnlock()
	fake.restoreTableFromBackupWithContextMutex.RLock()
	defer fake.restoreTableFromBackupWithContextMutex.RUnlock()
	fake.restoreTableToPointInTimeMutex.RLock()
	defer fake.restoreTableToPointInTimeMutex.RUnlock()
	fake.restoreTableToPointInTimeRequestMutex.RLock()
	defer fake.restoreTableToPointInTimeRequestMutex.RUnlock()
	fake.restoreTableToPointInTimeWithContextMutex.RLock()
	defer fake.restoreTableToPointInTimeWithContextMutex.RUnlock()
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	fake.scanPagesMutex.RLock()
	defer fake.scanPagesMutex.RUnlock()
	fake.scanPagesWithContextMutex.RLock()
	defer fake.scanPagesWithContextMutex.RUnlock()
	fake.scanRequestMutex.RLock()
	defer fake.scanRequestMutex.RUnlock()
	fake.scanWithContextMutex.RLock()
	defer fake.scanWithContextMutex.RUnlock()
	fake.tagResourceMutex.RLock()
	defer fake.tagResourceMutex.RUnlock()
	fake.tagResourceRequestMutex.RLock()
	defer fake.tagResourceRequestMutex.RUnlock()
	fake.tagResourceWithContextMutex.RLock()
	defer fake.tagResourceWithContextMutex.RUnlock()
	fake.transactGetItemsMutex.RLock()
	defer fake.transactGetItemsMutex.RUnlock()
	fake.transactGetItemsRequestMutex.RLock()
	defer fake.transactGetItemsRequestMutex.RUnlock()
	fake.transactGetItemsWithContextMutex.RLock()
	defer fake.transactGetItemsWithContextMutex.RUnlock()
	fake.transactWriteItemsMutex.RLock()
	defer fake.transactWriteItemsMutex.RUnlock()
	fake.transactWriteItemsRequestMutex.RLock()
	defer fake.transactWriteItemsRequestMutex.RUnlock()
	fake.transactWriteItemsWithContextMutex.RLock()
	defer fake.transactWriteItemsWithContextMutex.RUnlock()
	fake.untagResourceMutex.RLock()
	defer fake.untagResourceMutex.RUnlock()
	fake.untagResourceRequestMutex.RLock()
	defer fake.untagResourceRequestMutex.RUnlock()
	fake.untagResourceWithContextMutex.RLock()
	defer fake.untagResourceWithContextMutex.RUnlock()
	fake.updateContinuousBackupsMutex.RLock()
	defer fake.updateContinuousBackupsMutex.RUnlock()
	fake.updateContinuousBackupsRequestMutex.RLock()
	defer fake.updateContinuousBackupsRequestMutex.RUnlock()
	fake.updateContinuousBackupsWithContextMutex.RLock()
	defer fake.updateContinuousBackupsWithContextMutex.RUnlock()
	fake.updateContributorInsightsMutex.RLock()
	defer fake.updateContributorInsightsMutex.RUnlock()
	fake.updateContributorInsightsRequestMutex.RLock()
	defer fake.updateContributorInsightsRequestMutex.RUnlock()
	fake.updateContributorInsightsWithContextMutex.RLock()
	defer fake.updateContributorInsightsWithContextMutex.RUnlock()
	fake.updateGlobalTableMutex.RLock()
	defer fake.updateGlobalTableMutex.RUnlock()
	fake.updateGlobalTableRequestMutex.RLock()
	defer fake.updateGlobalTableRequestMutex.RUnlock()
	fake.updateGlobalTableSettingsMutex.RLock()
	defer fake.updateGlobalTableSettingsMutex.RUnlock()
	fake.updateGlobalTableSettingsRequestMutex.RLock()
	defer fake.updateGlobalTableSettingsRequestMutex.RUnlock()
	fake.updateGlobalTableSettingsWithContextMutex.RLock()
	defer fake.updateGlobalTableSettingsWithContextMutex.RUnlock()
	fake.updateGlobalTableWithContextMutex.RLock()
	defer fake.updateGlobalTableWithContextMutex.RUnlock()
	fake.updateItemMutex.RLock()
	defer fake.updateItemMutex.RUnlock()
	fake.updateItemRequestMutex.RLock()
	defer fake.updateItemRequestMutex.RUnlock()
	fake.updateItemWithContextMutex.RLock()
	defer fake.updateItemWithContextMutex.RUnlock()
	fake.updateTableMutex.RLock()
	defer fake.updateTableMutex.RUnlock()
	fake.updateTableReplicaAutoScalingMutex.RLock()
	defer fake.updateTableReplicaAutoScalingMutex.RUnlock()
	fake.updateTableReplicaAutoScalingRequestMutex.RLock()
	defer fake.updateTableReplicaAutoScalingRequestMutex.RUnlock()
	fake.updateTableReplicaAutoScalingWithContextMutex.RLock()
	defer fake.updateTableReplicaAutoScalingWithContextMutex.RUnlock()
	fake.updateTableRequestMutex.RLock()
	defer fake.updateTableRequestMutex.RUnlock()
	fake.updateTableWithContextMutex.RLock()
	defer fake.updateTableWithContextMutex.RUnlock()
	fake.updateTimeToLiveMutex.RLock()
	defer fake.updateTimeToLiveMutex.RUnlock()
	fake.updateTimeToLiveRequestMutex.RLock()
	defer fake.updateTimeToLiveRequestMutex.RUnlock()
	fake.updateTimeToLiveWithContextMutex.RLock()
	defer fake.updateTimeToLiveWithContextMutex.RUnlock()
	fake.waitUntilTableExistsMutex.RLock()
	defer fake.waitUntilTableExistsMutex.RUnlock()
	fake.waitUntilTableExistsWithContextMutex.RLock()
	defer fake.waitUntilTableExistsWithContextMutex.RUnlock()
	fake.waitUntilTableNotExistsMutex.RLock()
	defer fake.waitUntilTableNotExistsMutex.RUnlock()
	fake.waitUntilTableNotExistsWithContextMutex.RLock()
	defer fake.waitUntilTableNotExistsWithContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDynamoDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dynamodb.DynamoDB = new(FakeDynamoDB)
